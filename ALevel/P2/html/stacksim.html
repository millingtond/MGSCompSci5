<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Interactive Stack Simulation</title>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600;700&display=swap" rel="stylesheet">
    <!-- Pretty Print CSS -->
    <link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism-tomorrow.min.css" rel="stylesheet" />
    <style>
        :root {
            --primary-color: #4a90e2;
            --secondary-color: #50e3c2;
            --background-color: #f0f4f8;
            --surface-color: #ffffff;
            --text-color: #333;
            --light-text-color: #f9f9f9;
            --success-color: #28a745;
            --error-color: #dc3545;
            --border-radius: 12px;
            --shadow: 0 4px 15px rgba(0, 0, 0, 0.1);
            --transition-speed: 0.4s;
            --easing: cubic-bezier(0.25, 0.8, 0.25, 1);
        }

        *, *::before, *::after {
            box-sizing: border-box;
            margin: 0;
            padding: 0;
        }
        
        @media (prefers-reduced-motion: reduce) {
          *, *::before, *::after {
            animation-duration: 0.01ms !important;
            animation-iteration-count: 1 !important;
            transition-duration: 0.01ms !important;
            scroll-behavior: auto !important;
          }
        }

        body {
            font-family: 'Inter', sans-serif;
            background-color: var(--background-color);
            color: var(--text-color);
            line-height: 1.5; /* Reduced line-height */
            overflow-x: hidden;
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            padding: 2rem;
        }

        .container {
            width: 100%;
            max-width: 1200px;
            background: var(--surface-color);
            border-radius: var(--border-radius);
            box-shadow: var(--shadow);
            overflow: hidden;
            display: flex;
            flex-direction: column;
        }

        header {
            background: linear-gradient(135deg, var(--primary-color), var(--secondary-color));
            color: var(--light-text-color);
            padding: 1.5rem 2rem;
            text-align: center;
        }

        header h1 {
            font-size: 2.2rem;
            font-weight: 700;
            text-shadow: 1px 1px 3px rgba(0,0,0,0.2);
        }
        
        main {
            padding: 2rem;
            flex-grow: 1;
        }

        .simulation-section {
            display: none;
            animation: fadeIn var(--transition-speed) var(--easing);
        }

        .simulation-section.active {
            display: block;
        }

        @keyframes fadeIn {
            from { opacity: 0; transform: translateY(20px); }
            to { opacity: 1; transform: translateY(0); }
        }

        .controls {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 1rem 2rem;
            background-color: #e9ecef;
            border-top: 1px solid #dee2e6;
        }

        .btn {
            padding: 0.75rem 1.5rem;
            border: none;
            border-radius: var(--border-radius);
            font-size: 1rem;
            font-weight: 600;
            cursor: pointer;
            transition: all var(--transition-speed) var(--easing);
            position: relative;
            overflow: hidden;
            background-color: var(--primary-color);
            color: var(--light-text-color);
            box-shadow: 0 2px 5px rgba(0,0,0,0.1);
            will-change: transform;
        }
        
        .btn:hover {
            transform: translateY(-3px);
            box-shadow: 0 6px 12px rgba(74, 144, 226, 0.4);
        }

        .btn:disabled {
            background-color: #ced4da;
            cursor: not-allowed;
            transform: none;
            box-shadow: none;
        }

        .btn-secondary {
            background-color: #6c757d;
        }
        
        .btn-secondary:hover {
             box-shadow: 0 6px 12px rgba(108, 117, 125, 0.4);
        }

        .btn-reset {
            background-color: var(--error-color);
        }

        .btn-reset:hover {
            box-shadow: 0 6px 12px rgba(220, 53, 69, 0.4);
        }

        .simulation-area {
            display: flex;
            gap: 2rem;
            align-items: flex-start;
            margin-top: 2rem;
            flex-wrap: wrap;
        }

        .explanation, .interaction-panel {
            flex: 1;
            min-width: 300px;
        }
        
        .explanation h2 {
            font-size: 1.8rem;
            color: var(--primary-color);
            margin-bottom: 0.75rem;
        }

        .explanation p, .explanation li {
            font-size: 1.05rem; /* Slightly adjusted font size */
            margin-bottom: 0.75rem; /* Reduced margin */
        }
        
        .explanation code {
            background-color: #e9ecef;
            padding: 0.2em 0.4em;
            border-radius: 4px;
            font-family: 'Courier New', Courier, monospace;
        }

        .stack-visualizer {
            flex: 1;
            display: flex;
            flex-direction: column-reverse;
            align-items: center;
            padding: 1rem;
            background: #f8f9fa;
            border-radius: var(--border-radius);
            min-height: 400px;
            border: 2px dashed #ced4da;
            position: relative;
        }

        .stack-visualizer::before {
            content: 'Stack (LIFO)';
            position: absolute;
            top: 10px;
            font-weight: 600;
            color: #6c757d;
        }

        .stack-item {
            width: 100px;
            height: 50px;
            background: linear-gradient(135deg, var(--primary-color), var(--secondary-color));
            color: var(--light-text-color);
            display: flex;
            justify-content: center;
            align-items: center;
            font-size: 1.2rem;
            font-weight: 600;
            border-radius: 8px;
            margin-top: 5px;
            transition: all var(--transition-speed) var(--easing);
            transform-origin: bottom center;
            box-shadow: var(--shadow);
            opacity: 0;
            transform: translateY(50px);
            will-change: transform, opacity;
        }

        .stack-item.visible {
            opacity: 1;
            transform: translateY(0);
        }
        
        .stack-item.popping {
            opacity: 0;
            transform: translateY(-100px) scale(0.8);
        }
        
        .stack-item.pushing {
            animation: push-anim var(--transition-speed) var(--easing);
        }

        @keyframes push-anim {
            from { transform: translateY(-100px) scale(0.8); opacity: 0; }
            to { transform: translateY(0) scale(1); opacity: 1; }
        }

        .interaction-panel {
            background: #f8f9fa;
            padding: 1.5rem;
            border-radius: var(--border-radius);
        }

        .interaction-panel input {
            width: 100%;
            padding: 0.75rem;
            border: 1px solid #ced4da;
            border-radius: var(--border-radius);
            font-size: 1rem;
            margin-bottom: 1rem;
        }
        
        .interaction-panel .btn {
            width: 100%;
        }

        /* Modal Styles */
        .modal {
            position: fixed;
            z-index: 1000;
            left: 0;
            top: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.6);
            display: flex;
            justify-content: center;
            align-items: center;
            opacity: 0;
            visibility: hidden;
            transition: opacity 0.3s ease, visibility 0.3s ease;
            backdrop-filter: blur(5px);
        }

        .modal.visible {
            opacity: 1;
            visibility: visible;
        }

        .modal-content {
            background: var(--surface-color);
            padding: 2rem;
            border-radius: var(--border-radius);
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.2);
            width: 90%;
            max-width: 600px;
            transform: scale(0.9);
            transition: transform 0.3s ease;
        }
        
        .modal.visible .modal-content {
            transform: scale(1);
        }

        .modal h2 {
            margin-top: 0;
            color: var(--primary-color);
        }

        .modal-close {
            display: block;
            margin: 1.5rem auto 0;
        }
        
        /* Recursion Simulation */
        .recursion-area {
            display: flex;
            gap: 2rem;
            align-items: flex-start;
        }
        
        .code-container {
            flex: 1.2;
        }

        .code-toggle {
            display: flex;
            margin-bottom: 0.5rem;
            background: #e9ecef;
            border-radius: var(--border-radius);
            padding: 0.25rem;
        }

        .toggle-btn {
            flex: 1;
            padding: 0.5rem;
            border: none;
            background: transparent;
            cursor: pointer;
            font-weight: 600;
            border-radius: 9px;
            transition: background-color 0.3s ease, color 0.3s ease;
        }

        .toggle-btn.active {
            background-color: var(--primary-color);
            color: var(--light-text-color);
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }

        .code-display {
            border-radius: var(--border-radius);
            font-family: 'Courier New', Courier, monospace;
            display: none;
        }

        .code-display.active {
            display: block;
        }
        
        /* Prism line highlight adjustments */
        pre[class*="language-"].line-highlight {
            background: rgba(255, 255, 0, 0.2);
            border-radius: 4px;
        }
        
        /* Quiz Section */
        .quiz-container {
            max-width: 800px;
            margin: 0 auto;
        }
        
        .question-box {
            background: #f8f9fa;
            padding: 2rem;
            border-radius: var(--border-radius);
            margin-bottom: 1.5rem;
        }
        
        .question-box p {
            font-weight: 600;
            font-size: 1.2rem;
        }
        
        .options {
            display: flex;
            flex-direction: column;
            gap: 1rem;
            margin-top: 1rem;
        }
        
        .option {
            display: block;
            width: 100%;
            text-align: left;
            background: var(--surface-color);
            border: 2px solid #dee2e6;
            transition: all 0.2s ease;
            color: var(--text-color); /* Explicitly set text color */
        }
        
        .option:hover {
            border-color: var(--primary-color);
            background-color: #e9f2ff;
        }
        
        .option.selected {
            border-color: var(--primary-color);
            background-color: #d4e4ff;
        }
        
        .option.correct {
            background-color: #d4edda;
            border-color: var(--success-color);
        }
        
        .option.incorrect {
            background-color: #f8d7da;
            border-color: var(--error-color);
        }
        
        .feedback {
            margin-top: 1rem;
            padding: 1rem;
            border-radius: var(--border-radius);
            display: none;
        }
        
        .feedback.correct {
            background: #e2f0e6;
            color: #155724;
            display: block;
        }
        
        .feedback.incorrect {
            background: #fbe6e8;
            color: #721c24;
            display: block;
        }
        
        #quiz-results {
            text-align: center;
        }
        
        #quiz-results h2 {
            color: var(--primary-color);
        }
        
        #quiz-results p {
            font-size: 1.2rem;
        }

        /* Drag and Drop */
        .drop-zone {
            padding: 1rem;
            background: #e9ecef;
            border-radius: var(--border-radius);
            min-height: 50px;
            margin-top: 1rem;
            border: 2px dashed #ced4da;
        }
        
        .draggable {
            padding: 0.5rem 1rem;
            background: var(--surface-color);
            border-radius: 8px;
            margin: 0.5rem;
            cursor: grab;
            border: 1px solid #ccc;
            user-select: none;
        }
        
        .draggable-container {
            padding: 1rem;
            background: #f8f9fa;
            border-radius: var(--border-radius);
        }
        
        .dragging {
            opacity: 0.5;
        }
        
        .over {
            background-color: #d4e4ff;
        }
    </style>
</head>
<body>

    <div class="container">
        <header>
            <h1>Interactive Stack Simulation</h1>
            <p>A-Level Computer Science (Cambridge 9618)</p>
        </header>

        <main>
            <!-- Section 1: Introduction -->
            <div id="intro-section" class="simulation-section active">
                <div class="explanation">
                    <h2>Welcome!</h2>
                    <p>This simulation will guide you through the <strong>Stack</strong> data structure, a fundamental concept in computer science.</p>
                    <p>A Stack is an abstract data type that serves as a collection of elements, with two principal operations:</p>
                    <ul>
                        <li><strong>Push:</strong> Adds an element to the collection.</li>
                        <li><strong>Pop:</strong> Removes the most recently added element.</li>
                    </ul>
                    <p>This behavior is known as <strong>Last In, First Out (LIFO)</strong>. Think of it like a stack of plates: you can only add a new plate to the top, and you can only take a plate from the top.</p>
                    <p>Use the "Next" and "Previous" buttons or the right and left arrow keys on your keyboard to navigate through the simulation.</p>
                </div>
            </div>

            <!-- Section 2: Push Operation -->
            <div id="push-section" class="simulation-section">
                <div class="simulation-area">
                    <div class="explanation">
                        <h2>The <code>push</code> Operation</h2>
                        <p>The <code>push</code> operation adds a new item to the top of the stack.</p>
                        <p>In our visual stack, the "top" is the highest element shown.</p>
                        <strong>Instructions:</strong>
                        <ol>
                            <li>Enter a value (e.g., a number or short text) into the input box.</li>
                            <li>Click the "Push to Stack" button.</li>
                            <li>Observe how the new element is placed on top of the stack.</li>
                        </ol>
                        <button class="btn btn-reset" id="reset-push-sim">Reset Simulation</button>
                    </div>
                    <div class="stack-visualizer" id="push-stack-visualizer"></div>
                    <div class="interaction-panel">
                        <h3>Push Control</h3>
                        <input type="text" id="push-value" placeholder="Enter a value to push">
                        <button class="btn" id="push-btn">Push to Stack</button>
                    </div>
                </div>
            </div>

            <!-- Section 3: Pop Operation -->
            <div id="pop-section" class="simulation-section">
                <div class="simulation-area">
                    <div class="explanation">
                        <h2>The <code>pop</code> Operation</h2>
                        <p>The <code>pop</code> operation removes the item from the top of the stack. Remember LIFO - the last item pushed is the first one to be popped.</p>
                        <strong>Instructions:</strong>
                        <ol>
                            <li>The stack has been pre-filled for you.</li>
                            <li>Click the "Pop from Stack" button.</li>
                            <li>Observe how the top element is removed. The value that was popped is also returned by the operation.</li>
                        </ol>
                        <p><strong>Note:</strong> Attempting to pop from an empty stack results in a "Stack Underflow" error.</p>
                         <button class="btn btn-reset" id="reset-pop-sim">Reset Simulation</button>
                    </div>
                    <div class="stack-visualizer" id="pop-stack-visualizer"></div>
                    <div class="interaction-panel">
                        <h3>Pop Control</h3>
                        <button class="btn" id="pop-btn">Pop from Stack</button>
                        <p id="popped-value-display" style="margin-top: 1rem; font-weight: bold;"></p>
                    </div>
                </div>
            </div>

            <!-- Section 4: Stack in Recursion -->
            <div id="recursion-section" class="simulation-section">
                 <div class="explanation">
                    <h2>Stacks in Recursion: The Call Stack</h2>
                    <p>Stacks are crucial for managing function calls, especially in <strong>recursion</strong>. The computer uses a <strong>call stack</strong> to keep track of where it is in a sequence of nested function calls.</p>
                    <p>When a function is called, a "stack frame" is <strong>pushed</strong> onto the call stack. This is the <strong>winding phase</strong>.</p>
                    <p>When a function returns, its stack frame is <strong>popped</strong> off. This is the <strong>unwinding phase</strong>.</p>
                    <p>Let's visualize this with a recursive factorial function. You can switch between Pseudocode and Python.</p>
                </div>
                <div class="recursion-area">
                    <div class="code-container">
                        <div class="code-toggle">
                            <button class="toggle-btn active" data-lang="pseudo">Pseudocode</button>
                            <button class="toggle-btn" data-lang="python">Python</button>
                        </div>
<pre id="pseudo-code" class="code-display active line-numbers"><code class="language-clike">FUNCTION Factorial(n)
  IF n = 0 THEN
    RETURN 1
  ELSE
    RETURN n * Factorial(n - 1)
  ENDIF
ENDFUNCTION</code></pre>
<pre id="python-code" class="code-display line-numbers"><code class="language-python">def factorial(n):
  if n == 0:
    return 1
  else:
    return n * factorial(n - 1)
</code></pre>
                    </div>
                    <div class="stack-visualizer" id="recursion-stack-visualizer"></div>
                </div>
                <div class="interaction-panel" style="margin-top: 1rem;">
                    <h3>Recursion Control</h3>
                    <p>Simulate <code>Factorial(3)</code></p>
                    <button class="btn" id="start-recursion-btn">Start Winding</button>
                    <button class="btn btn-secondary" id="next-recursion-step-btn" disabled>Next Step</button>
                    <button class="btn btn-reset" id="reset-recursion-sim">Reset Simulation</button>
                </div>
            </div>

            <!-- Section 5: Quiz -->
            <div id="quiz-section" class="simulation-section">
                <div class="quiz-container">
                    <h2>Test Your Knowledge</h2>
                    <p>Answer the following questions to check your understanding.</p>
                    
                    <form id="quiz-form">
                        <!-- Question 1 -->
                        <div class="question-box" data-question="1">
                            <p>1. Which principle does a stack follow?</p>
                            <div class="options">
                                <button type="button" class="option btn" data-answer="FIFO">First In, First Out (FIFO)</button>
                                <button type="button" class="option btn" data-answer="LIFO">Last In, First Out (LIFO)</button>
                                <button type="button" class="option btn" data-answer="LILO">Last In, Last Out (LILO)</button>
                                <button type="button" class="option btn" data-answer="Random">Random Access</button>
                            </div>
                            <div class="feedback"></div>
                        </div>

                        <!-- Question 2 -->
                        <div class="question-box" data-question="2">
                            <p>2. What is the term for adding an element to a stack?</p>
                            <input type="text" class="quiz-input" placeholder="Your answer..." data-answer="push">
                            <button type="button" class="btn check-answer-btn">Check Answer</button>
                            <div class="feedback"></div>
                        </div>
                        
                        <!-- Question 3 -->
                        <div class="question-box" data-question="3">
                            <p>3. During recursion, the process of adding stack frames for each function call is known as...</p>
                             <div class="options">
                                <button type="button" class="option btn" data-answer="unwinding">Unwinding</button>
                                <button type="button" class="option btn" data-answer="compiling">Compiling</button>
                                <button type="button" class="option btn" data-answer="winding">Winding</button>
                                <button type="button" class="option btn" data-answer="overflowing">Overflowing</button>
                            </div>
                            <div class="feedback"></div>
                        </div>

                        <!-- Question 4 -->
                        <div class="question-box" data-question="4">
                             <p>4. Arrange the steps for a recursive function call in the correct order.</p>
                             <div class="draggable-container" id="draggable-options">
                                <div class="draggable" draggable="true" data-id="3">Base case is reached.</div>
                                <div class="draggable" draggable="true" data-id="1">Recursive function is called.</div>
                                <div class="draggable" draggable="true" data-id="4">Stack frames are popped off (unwinding).</div>
                                <div class="draggable" draggable="true" data-id="2">Stack frame is pushed onto the call stack (winding).</div>
                             </div>
                             <p style="margin-top:1rem;">Drop here:</p>
                             <div class="drop-zone" id="q4-drop-zone"></div>
                             <button type="button" class="btn check-answer-btn" style="margin-top:1rem;">Check Order</button>
                             <div class="feedback"></div>
                        </div>

                        <div id="quiz-results" style="display: none;">
                            <h2>Quiz Complete!</h2>
                            <p id="quiz-score"></p>
                            <button type="button" class="btn" id="retake-quiz-btn">Retake Quiz</button>
                        </div>
                    </form>
                </div>
            </div>
        </main>

        <div class="controls">
            <button class="btn btn-secondary" id="prev-btn" disabled>Previous Step</button>
            <span id="step-indicator">Step 1 / 5</span>
            <button class="btn" id="next-btn">Next Step</button>
        </div>
    </div>

    <!-- Modal for instructions and popups -->
    <div id="info-modal" class="modal">
        <div class="modal-content">
            <h2 id="modal-title"></h2>
            <p id="modal-text"></p>
            <button id="modal-close-btn" class="btn modal-close">Got it!</button>
        </div>
    </div>

    <!-- Pretty Print JS -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-core.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/plugins/autoloader/prism-autoloader.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/plugins/line-highlight/prism-line-highlight.min.js"></script>

    <script>
        document.addEventListener('DOMContentLoaded', () => {
            // --- DOM Caching ---
            const sections = document.querySelectorAll('.simulation-section');
            const nextBtn = document.getElementById('next-btn');
            const prevBtn = document.getElementById('prev-btn');
            const stepIndicator = document.getElementById('step-indicator');
            const infoModal = document.getElementById('info-modal');
            const modalTitle = document.getElementById('modal-title');
            const modalText = document.getElementById('modal-text');
            const modalCloseBtn = document.getElementById('modal-close-btn');

            let currentSectionIndex = 0;
            const totalSections = sections.length;
            let animationLock = false;

            // --- Core Navigation ---
            function updateNav() {
                sections.forEach((section, index) => {
                    section.classList.toggle('active', index === currentSectionIndex);
                });
                stepIndicator.textContent = `Step ${currentSectionIndex + 1} / ${totalSections}`;
                prevBtn.disabled = currentSectionIndex === 0;
                nextBtn.disabled = currentSectionIndex === totalSections - 1;
                
                // Initialize section-specific logic
                if (currentSectionIndex === 1) initPushSim();
                if (currentSectionIndex === 2) initPopSim();
                if (currentSectionIndex === 3) initRecursionSim();
                if (currentSectionIndex === 4) initQuiz();
            }

            function navigate(direction) {
                const newIndex = currentSectionIndex + direction;
                if (newIndex >= 0 && newIndex < totalSections) {
                    currentSectionIndex = newIndex;
                    updateNav();
                }
            }

            nextBtn.addEventListener('click', () => navigate(1));
            prevBtn.addEventListener('click', () => navigate(-1));
            
            document.addEventListener('keydown', (e) => {
                if (document.activeElement.tagName === 'INPUT' || document.activeElement.tagName === 'TEXTAREA') {
                    return; // Ignore arrow keys if typing in an input
                }
                if (e.key === 'ArrowRight') nextBtn.click();
                if (e.key === 'ArrowLeft') prevBtn.click();
            });
            
            // --- Modal Logic ---
            let afterModalAction = null;
            function showModal(title, text, callback) {
                modalTitle.textContent = title;
                modalText.innerHTML = text; // Use innerHTML to allow for bold tags etc.
                infoModal.classList.add('visible');
                afterModalAction = callback;
            }

            modalCloseBtn.addEventListener('click', () => {
                infoModal.classList.remove('visible');
                if (typeof afterModalAction === 'function') {
                    // Delay action slightly to allow modal to close
                    setTimeout(afterModalAction, 300);
                    afterModalAction = null;
                }
            });

            // --- Section 1: Introduction ---
            // No specific JS needed, just the initial view.

            // --- Section 2: Push Simulation ---
            const pushValueInput = document.getElementById('push-value');
            const pushBtn = document.getElementById('push-btn');
            const pushStackVisualizer = document.getElementById('push-stack-visualizer');
            const resetPushBtn = document.getElementById('reset-push-sim');
            let pushStack = [];

            function initPushSim() {
                pushStack = [];
                renderStack(pushStack, pushStackVisualizer);
                pushValueInput.value = '';
            }
            
            resetPushBtn.addEventListener('click', initPushSim);

            pushBtn.addEventListener('click', () => {
                if (animationLock) return;
                const value = pushValueInput.value.trim();
                if (!value) {
                    showModal('Input Required', 'Please enter a value to push onto the stack.');
                    return;
                }
                if (pushStack.length >= 6) {
                    showModal('Stack Full', 'The visual stack is full. Please reset the simulation to continue.');
                    return;
                }
                
                animationLock = true;
                pushStack.push(value);
                const newItem = createStackItem(value);
                newItem.classList.add('pushing');
                pushStackVisualizer.appendChild(newItem);
                
                requestAnimationFrame(() => {
                    newItem.classList.add('visible');
                });
                
                pushValueInput.value = '';
                pushValueInput.focus();
                
                setTimeout(() => {
                    newItem.classList.remove('pushing');
                    animationLock = false;
                }, 500);
            });

            // --- Section 3: Pop Simulation ---
            const popBtn = document.getElementById('pop-btn');
            const popStackVisualizer = document.getElementById('pop-stack-visualizer');
            const poppedValueDisplay = document.getElementById('popped-value-display');
            const resetPopBtn = document.getElementById('reset-pop-sim');
            let popStack = [];

            function initPopSim() {
                popStack = ['Apples', 'Oranges', 'Bananas', 'Grapes'];
                renderStack(popStack, popStackVisualizer, true);
                poppedValueDisplay.textContent = '';
            }
            
            resetPopBtn.addEventListener('click', initPopSim);

            popBtn.addEventListener('click', () => {
                if (animationLock) return;
                if (popStack.length === 0) {
                    showModal('Stack Underflow', 'Cannot pop from an empty stack!');
                    return;
                }
                
                animationLock = true;
                const poppedValue = popStack.pop();
                const items = popStackVisualizer.querySelectorAll('.stack-item');
                const itemToPop = items[items.length - 1];
                
                itemToPop.classList.add('popping');
                poppedValueDisplay.textContent = `Popped: ${poppedValue}`;
                
                setTimeout(() => {
                    itemToPop.remove();
                    animationLock = false;
                }, 500);
            });

            // --- Section 4: Recursion Simulation ---
            const recursionStackVisualizer = document.getElementById('recursion-stack-visualizer');
            const codeToggleButtons = document.querySelectorAll('.code-toggle .toggle-btn');
            const pseudoCodeDisplay = document.getElementById('pseudo-code');
            const pythonCodeDisplay = document.getElementById('python-code');
            const startRecursionBtn = document.getElementById('start-recursion-btn');
            const nextRecursionStepBtn = document.getElementById('next-recursion-step-btn');
            const resetRecursionBtn = document.getElementById('reset-recursion-sim');
            
            let recursionStack = [];
            let recursionStep = 0;
            const pseudoSteps = [
                { line: 1, highlight: '5', text: 'Call Factorial(3). Push frame to stack.' },
                { line: 5, highlight: '5', text: 'n is not 0. Call Factorial(2). Push frame.' },
                { line: 5, highlight: '5', text: 'n is not 0. Call Factorial(1). Push frame.' },
                { line: 5, highlight: '2', text: 'n is not 0. Call Factorial(0). Push frame.' },
                { line: 2, highlight: '3', text: 'n is 0. Base case reached. Return 1.' },
                { line: 3, highlight: '5', text: 'Pop. Return 1 to Factorial(1). Calculate 1 * 1.' },
                { line: 5, highlight: '5', text: 'Pop. Return 1 to Factorial(2). Calculate 2 * 1.' },
                { line: 5, highlight: '5', text: 'Pop. Return 2 to Factorial(3). Calculate 3 * 2.' },
                { line: 5, highlight: '7', text: 'Final result: 6. Stack is empty.' }
            ];
            const pythonSteps = [
                { line: 1, highlight: '5', text: 'Call factorial(3). Push frame to stack.' },
                { line: 5, highlight: '5', text: 'n is not 0. Call factorial(2). Push frame.' },
                { line: 5, highlight: '5', text: 'n is not 0. Call factorial(1). Push frame.' },
                { line: 5, highlight: '2', text: 'n is not 0. Call factorial(0). Push frame.' },
                { line: 2, highlight: '3', text: 'n is 0. Base case reached. Return 1.' },
                { line: 3, highlight: '5', text: 'Pop. Return 1 to factorial(1). Calculate 1 * 1.' },
                { line: 5, highlight: '5', text: 'Pop. Return 1 to factorial(2). Calculate 2 * 1.' },
                { line: 5, highlight: '5', text: 'Pop. Return 2 to factorial(3). Calculate 3 * 2.' },
                { line: 5, highlight: '1-6', text: 'Final result: 6. Stack is empty.' }
            ];
            const recursionActions = ['call', 'call', 'call', 'call', 'base_case', 'unwind', 'unwind', 'unwind', 'final'];

            function initRecursionSim() {
                recursionStack = [];
                recursionStep = 0;
                renderStack(recursionStack, recursionStackVisualizer);
                clearHighlights();
                startRecursionBtn.disabled = false;
                nextRecursionStepBtn.disabled = true;
                nextRecursionStepBtn.textContent = 'Next Step';
            }
            
            resetRecursionBtn.addEventListener('click', initRecursionSim);

            codeToggleButtons.forEach(btn => {
                btn.addEventListener('click', () => {
                    codeToggleButtons.forEach(b => b.classList.remove('active'));
                    btn.classList.add('active');
                    
                    const lang = btn.dataset.lang;
                    pseudoCodeDisplay.classList.toggle('active', lang === 'pseudo');
                    pythonCodeDisplay.classList.toggle('active', lang === 'python');
                    
                    // Re-apply highlight to the new active code
                    if (recursionStep > 0 && recursionStep <= recursionActions.length) {
                        const currentLangSteps = lang === 'pseudo' ? pseudoSteps : pythonSteps;
                        const stepInfo = currentLangSteps[recursionStep - 1];
                        highlightLine(stepInfo.highlight);
                    } else {
                        clearHighlights();
                    }
                });
            });

            startRecursionBtn.addEventListener('click', () => {
                showModal('Recursion Started', 'We will now trace the execution of <code>Factorial(3)</code>. Click "Next Step" to proceed.', () => {
                   startRecursionBtn.disabled = true;
                   nextRecursionStepBtn.disabled = false;
                   nextRecursionStepBtn.click(); // auto-run first step
                });
            });
            
            nextRecursionStepBtn.addEventListener('click', () => {
                if (animationLock || recursionStep >= recursionActions.length) return;
                
                animationLock = true;
                const action = recursionActions[recursionStep];
                const activeLang = document.querySelector('.toggle-btn.active').dataset.lang;
                const stepInfo = (activeLang === 'pseudo' ? pseudoSteps : pythonSteps)[recursionStep];

                highlightLine(stepInfo.highlight);
                
                showModal(`Step ${recursionStep + 1}`, stepInfo.text, () => {
                    if (action === 'call') {
                        const n = 3 - recursionStep;
                        const frame = `Factorial(${n})`;
                        recursionStack.push(frame);
                        const newItem = createStackItem(frame);
                        recursionStackVisualizer.appendChild(newItem);
                        requestAnimationFrame(() => newItem.classList.add('visible'));
                    } else if (action === 'unwind' || action === 'base_case') {
                        recursionStack.pop();
                        const items = recursionStackVisualizer.querySelectorAll('.stack-item');
                        const itemToPop = items[items.length - 1];
                        if (itemToPop) {
                            itemToPop.classList.add('popping');
                            setTimeout(() => itemToPop.remove(), 500);
                        }
                    } else if (action === 'final') {
                         nextRecursionStepBtn.disabled = true;
                         nextRecursionStepBtn.textContent = 'Finished';
                    }
                    
                    setTimeout(() => {
                        animationLock = false;
                        recursionStep++;
                        if (recursionStep >= recursionActions.length) {
                             nextRecursionStepBtn.disabled = true;
                             nextRecursionStepBtn.textContent = 'Finished';
                        }
                    }, 500);
                });
            });

            function highlightLine(lineStr) {
                const activeCode = document.querySelector('.code-display.active');
                if (activeCode) {
                    activeCode.setAttribute('data-line', lineStr);
                    Prism.highlightAllUnder(activeCode.parentElement);
                }
            }
            
            function clearHighlights() {
                pseudoCodeDisplay.removeAttribute('data-line');
                pythonCodeDisplay.removeAttribute('data-line');
                Prism.highlightAll();
            }
            
            // --- Section 5: Quiz ---
            const quizForm = document.getElementById('quiz-form');
            const quizResults = document.getElementById('quiz-results');
            const quizScoreEl = document.getElementById('quiz-score');
            const retakeQuizBtn = document.getElementById('retake-quiz-btn');
            let score = 0;
            const totalQuestions = 4;
            let answeredQuestions = 0;
            
            function initQuiz() {
                score = 0;
                answeredQuestions = 0;
                quizResults.style.display = 'none';
                quizForm.style.display = 'block';
                
                quizForm.querySelectorAll('.question-box').forEach(q => {
                    q.dataset.answered = 'false';
                    q.querySelectorAll('.option').forEach(opt => {
                        opt.classList.remove('correct', 'incorrect', 'selected');
                        opt.disabled = false;
                    });
                    const feedback = q.querySelector('.feedback');
                    if (feedback) {
                        feedback.style.display = 'none';
                        feedback.textContent = '';
                    }
                    const input = q.querySelector('.quiz-input');
                    if (input) {
                        input.value = '';
                        input.disabled = false;
                    }
                    const checkBtn = q.querySelector('.check-answer-btn');
                    if(checkBtn) {
                       checkBtn.style.display = 'block';
                       checkBtn.disabled = false;
                    }
                });
                
                const draggableContainer = document.getElementById('draggable-options');
                const dropZone = document.getElementById('q4-drop-zone');
                dropZone.innerHTML = '';
                document.querySelectorAll('.draggable').forEach(d => draggableContainer.appendChild(d));
            }
            
            retakeQuizBtn.addEventListener('click', initQuiz);

            quizForm.addEventListener('click', (e) => {
                if (e.target.classList.contains('option')) {
                    const questionBox = e.target.closest('.question-box');
                    if (questionBox.dataset.answered === 'true') return;
                    
                    const options = questionBox.querySelectorAll('.option');
                    options.forEach(opt => opt.classList.remove('selected'));
                    e.target.classList.add('selected');
                    
                    const isCorrect = e.target.dataset.answer === getCorrectAnswer(questionBox.dataset.question);
                    
                    handleAnswer(questionBox, isCorrect);
                }
            });
            
            quizForm.querySelectorAll('.check-answer-btn').forEach(btn => {
                btn.addEventListener('click', (e) => {
                    const questionBox = e.target.closest('.question-box');
                    if (questionBox.dataset.answered === 'true') return;

                    const qNum = questionBox.dataset.question;
                    let isCorrect = false;

                    switch (qNum) {
                        case '2': {
                            const input = questionBox.querySelector('input');
                            if (input.value.length < 3) {
                                showModal("Answer Required", "Please provide a complete answer before checking.");
                                return;
                            }
                            isCorrect = input.value.trim().toLowerCase() === getCorrectAnswer(qNum);
                            break;
                        }
                        case '4': {
                            const droppedItems = Array.from(questionBox.querySelectorAll('.drop-zone .draggable'));
                            if (droppedItems.length < 4) {
                                showModal("Task Incomplete", "Please drag all four items into the drop zone in the correct order.");
                                return;
                            }
                            const userAnswer = droppedItems.map(item => item.dataset.id);
                            isCorrect = userAnswer.join(',') === getCorrectAnswer(qNum);
                            break;
                        }
                    }
                    
                    handleAnswer(questionBox, isCorrect);
                });
            });

            function getCorrectAnswer(questionNumber) {
                const answers = {
                    '1': 'LIFO',
                    '2': 'push',
                    '3': 'winding',
                    '4': '1,2,3,4'
                };
                return answers[questionNumber];
            }
            
            function handleAnswer(questionBox, isCorrect) {
                 if (questionBox.dataset.answered === 'true') return;
                 questionBox.dataset.answered = 'true';

                const feedbackEl = questionBox.querySelector('.feedback');
                const selectedOption = questionBox.querySelector('.selected');
                
                if (isCorrect) {
                    score++;
                    feedbackEl.textContent = 'Correct! Well done.';
                    feedbackEl.className = 'feedback correct';
                    if (selectedOption) selectedOption.classList.add('correct');
                } else {
                    feedbackEl.textContent = 'Not quite. Review the relevant section for a hint.';
                    feedbackEl.className = 'feedback incorrect';
                    if (selectedOption) selectedOption.classList.add('incorrect');
                }
                
                questionBox.querySelectorAll('.option, .quiz-input, .check-answer-btn').forEach(el => el.disabled = true);
                
                answeredQuestions++;
                if (answeredQuestions === totalQuestions) {
                    setTimeout(showResults, 1000);
                }
            }
            
            function showResults() {
                quizForm.style.display = 'none';
                quizResults.style.display = 'block';
                quizScoreEl.textContent = `You scored ${score} out of ${totalQuestions}.`;
            }

            // Drag and Drop Logic
            const draggables = document.querySelectorAll('.draggable');
            const dropZone = document.getElementById('q4-drop-zone');

            draggables.forEach(draggable => {
                draggable.addEventListener('dragstart', () => {
                    draggable.classList.add('dragging');
                });
                draggable.addEventListener('dragend', () => {
                    draggable.classList.remove('dragging');
                });
            });
            
            dropZone.addEventListener('dragover', e => {
                e.preventDefault();
                dropZone.classList.add('over');
            });
            
            dropZone.addEventListener('dragleave', () => {
                dropZone.classList.remove('over');
            });

            dropZone.addEventListener('drop', e => {
                e.preventDefault();
                dropZone.classList.remove('over');
                const draggable = document.querySelector('.dragging');
                if (draggable) {
                    dropZone.appendChild(draggable);
                }
            });


            // --- Helper Functions ---
            function createStackItem(value) {
                const item = document.createElement('div');
                item.className = 'stack-item';
                item.textContent = value;
                return item;
            }

            function renderStack(stackArray, visualizer, makeVisible = false) {
                visualizer.innerHTML = '';
                stackArray.forEach(value => {
                    const item = createStackItem(value);
                    if (makeVisible) {
                       requestAnimationFrame(() => item.classList.add('visible'));
                    }
                    visualizer.appendChild(item);
                });
            }

            // --- Initial Load ---
            showModal(
                'Welcome to the Stack Simulation!', 
                'This interactive guide is designed for the Cambridge 9618 syllabus. You will learn about Stacks, their LIFO principle, and their use in recursion. Click "Got it!" to begin.',
                () => updateNav()
            );
        });
    </script>
</body>
</html>
