<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Graphs - Non-Linear Data Structures | Interactive Lesson</title>
    <style>
        :root {
            --primary-color: #2563eb;
            --primary-dark: #1d4ed8;
            --primary-light: #60a5fa;
            --secondary-color: #7c3aed;
            --secondary-dark: #6d28d9;
            --success-color: #10b981;
            --success-dark: #059669;
            --error-color: #ef4444;
            --error-dark: #dc2626;
            --warning-color: #f59e0b;
            --warning-dark: #d97706;
            --bg-color: #ffffff;
            --bg-secondary: #f3f4f6;
            --text-color: #1f2937;
            --text-secondary: #6b7280;
            --card-bg: #ffffff;
            --border-color: #e5e7eb;
            --highlight-color: #fef3c7;
            --shadow-sm: 0 1px 2px 0 rgb(0 0 0 / 0.05);
            --shadow-md: 0 4px 6px -1px rgb(0 0 0 / 0.1);
            --shadow-lg: 0 10px 15px -3px rgb(0 0 0 / 0.1);
            --shadow-xl: 0 20px 25px -5px rgb(0 0 0 / 0.1);
            --gradient-primary: linear-gradient(135deg, #2563eb 0%, #7c3aed 100%);
            --gradient-success: linear-gradient(135deg, #10b981 0%, #34d399 100%);
            --gradient-graph: linear-gradient(135deg, #3b82f6 0%, #8b5cf6 100%);
            --animation-duration: 0.3s;
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background-color: var(--bg-secondary);
            color: var(--text-color);
            line-height: 1.6;
            overflow-x: hidden;
            min-height: 100vh;
        }

        /* Performance optimization */
        * {
            will-change: auto;
        }

        /* High Contrast Mode */
        body.high-contrast {
            --bg-color: #000000;
            --bg-secondary: #0a0a0a;
            --text-color: #ffffff;
            --text-secondary: #e0e0e0;
            --card-bg: #1a1a1a;
            --border-color: #ffffff;
            --primary-color: #00ff00;
            --secondary-color: #ffff00;
        }

        /* Dyslexia Font */
        body.dyslexia-font {
            font-family: 'Comic Sans MS', 'OpenDyslexic', sans-serif;
            letter-spacing: 0.05em;
            word-spacing: 0.1em;
            line-height: 1.8;
        }

        /* Header with Glassmorphism */
        .header {
            background: var(--gradient-primary);
            color: white;
            padding: 1.5rem 1rem;
            position: sticky;
            top: 0;
            z-index: 1000;
            backdrop-filter: blur(20px);
            box-shadow: var(--shadow-lg);
        }

        .header::after {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: linear-gradient(90deg, rgba(255,255,255,0.1) 0%, transparent 50%, rgba(255,255,255,0.1) 100%);
            pointer-events: none;
        }

        .header-content {
            max-width: 1200px;
            margin: 0 auto;
            display: flex;
            justify-content: space-between;
            align-items: center;
            flex-wrap: wrap;
            gap: 1rem;
            position: relative;
            z-index: 1;
        }

        .header h1 {
            font-size: 1.5rem;
            font-weight: 700;
            text-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }

        /* XP Container */
        .xp-container {
            display: flex;
            align-items: center;
            gap: 1rem;
            background: rgba(255,255,255,0.15);
            padding: 0.5rem 1.5rem;
            border-radius: 2rem;
            backdrop-filter: blur(20px);
            border: 1px solid rgba(255,255,255,0.2);
            box-shadow: inset 0 1px 2px rgba(0,0,0,0.1);
        }

        .xp-bar {
            width: 200px;
            height: 24px;
            background: rgba(0,0,0,0.2);
            border-radius: 12px;
            overflow: hidden;
            position: relative;
            box-shadow: inset 0 2px 4px rgba(0,0,0,0.2);
        }

        .xp-fill {
            height: 100%;
            background: linear-gradient(90deg, #fbbf24 0%, #f59e0b 100%);
            transition: width 0.6s cubic-bezier(0.4, 0, 0.2, 1);
            position: relative;
            overflow: hidden;
            box-shadow: 0 0 20px rgba(251, 191, 36, 0.5);
        }

        .xp-fill::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: linear-gradient(90deg, transparent, rgba(255,255,255,0.4), transparent);
            animation: shimmer 2s infinite;
        }

        @keyframes shimmer {
            0% { transform: translateX(-100%); }
            100% { transform: translateX(100%); }
        }

        .level-badge {
            font-size: 1.1rem;
            font-weight: 700;
            background: rgba(255,255,255,0.2);
            padding: 0.5rem 1rem;
            border-radius: 1.5rem;
            text-shadow: 0 1px 2px rgba(0,0,0,0.1);
        }

        /* Navigation */
        .nav-container {
            background: rgba(255,255,255,0.8);
            backdrop-filter: blur(20px);
            padding: 0.75rem;
            border-bottom: 1px solid var(--border-color);
            position: sticky;
            top: 80px;
            z-index: 999;
            box-shadow: var(--shadow-md);
        }

        .nav-pills {
            display: flex;
            gap: 0.75rem;
            overflow-x: auto;
            padding: 0.5rem;
            max-width: 1200px;
            margin: 0 auto;
            scrollbar-width: none;
        }

        .nav-pills::-webkit-scrollbar {
            display: none;
        }

        .nav-pill {
            padding: 0.625rem 1.25rem;
            background: var(--card-bg);
            border: 2px solid var(--border-color);
            border-radius: 2rem;
            cursor: pointer;
            white-space: nowrap;
            transition: all var(--animation-duration) cubic-bezier(0.4, 0, 0.2, 1);
            font-size: 0.875rem;
            font-weight: 500;
        }

        .nav-pill:hover {
            transform: translateY(-2px);
            box-shadow: var(--shadow-md);
            border-color: var(--primary-light);
        }

        .nav-pill.active {
            background: var(--primary-color);
            color: white;
            border-color: var(--primary-color);
            box-shadow: 0 0 20px rgba(37, 99, 235, 0.3);
        }

        .nav-pill.completed {
            border-color: var(--success-color);
            position: relative;
        }

        .nav-pill.completed::after {
            content: '‚úì';
            position: absolute;
            top: -8px;
            right: -8px;
            background: var(--gradient-success);
            color: white;
            width: 24px;
            height: 24px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 0.75rem;
            font-weight: bold;
            animation: bounceIn 0.5s ease;
        }

        @keyframes bounceIn {
            0% { transform: scale(0); }
            50% { transform: scale(1.2); }
            100% { transform: scale(1); }
        }

        /* Main Content */
        .main-content {
            max-width: 1200px;
            margin: 2rem auto;
            padding: 0 1rem;
            min-height: calc(100vh - 200px);
        }

        .section {
            display: none;
            opacity: 0;
            transform: translateY(20px);
            transition: opacity 0.5s ease, transform 0.5s ease;
        }

        .section.active {
            display: block;
            opacity: 1;
            transform: translateY(0);
        }

        /* Cards */
        .card {
            background: var(--card-bg);
            border-radius: 1.5rem;
            padding: 2.5rem;
            margin-bottom: 2rem;
            box-shadow: var(--shadow-lg);
            border: 1px solid var(--border-color);
            position: relative;
            overflow: hidden;
            transition: transform var(--animation-duration) ease, box-shadow var(--animation-duration) ease;
        }

        .card::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            height: 4px;
            background: var(--gradient-graph);
            transform: scaleX(0);
            transform-origin: left;
            transition: transform 0.6s ease;
        }

        .card:hover::before {
            transform: scaleX(1);
        }

        .card-title {
            font-size: 1.75rem;
            font-weight: 700;
            background: var(--gradient-graph);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
            margin-bottom: 1.5rem;
            display: flex;
            align-items: center;
            gap: 0.75rem;
        }

        /* Interactive Areas */
        .interactive-area {
            background: var(--bg-secondary);
            border: 2px dashed var(--border-color);
            border-radius: 1rem;
            padding: 2rem;
            margin: 1.5rem 0;
            min-height: 120px;
            position: relative;
            transition: all var(--animation-duration) ease;
        }

        .interactive-area:hover {
            border-color: var(--primary-light);
            background: rgba(37, 99, 235, 0.02);
        }

        .highlight-active {
            border-color: var(--primary-color);
            background: rgba(37, 99, 235, 0.05);
            box-shadow: 0 0 0 4px rgba(37, 99, 235, 0.1);
            animation: pulse 2s infinite;
        }

        @keyframes pulse {
            0%, 100% { box-shadow: 0 0 0 0 rgba(37, 99, 235, 0.4); }
            50% { box-shadow: 0 0 0 12px rgba(37, 99, 235, 0); }
        }

        /* Buttons */
        .btn {
            padding: 0.875rem 2rem;
            border: none;
            border-radius: 0.75rem;
            font-size: 1rem;
            font-weight: 600;
            cursor: pointer;
            transition: all var(--animation-duration) cubic-bezier(0.4, 0, 0.2, 1);
            display: inline-flex;
            align-items: center;
            gap: 0.5rem;
            position: relative;
            overflow: hidden;
        }

        .btn::before {
            content: '';
            position: absolute;
            top: 50%;
            left: 50%;
            width: 0;
            height: 0;
            background: rgba(255,255,255,0.2);
            border-radius: 50%;
            transform: translate(-50%, -50%);
            transition: width 0.6s, height 0.6s;
        }

        .btn:active::before {
            width: 300px;
            height: 300px;
        }

        .btn-primary {
            background: var(--gradient-primary);
            color: white;
            box-shadow: 0 4px 15px rgba(37, 99, 235, 0.3);
        }

        .btn-primary:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(37, 99, 235, 0.4);
        }

        .btn-secondary {
            background: var(--card-bg);
            color: var(--text-color);
            border: 2px solid var(--border-color);
        }

        .btn-secondary:hover {
            background: var(--bg-secondary);
            border-color: var(--primary-light);
            transform: translateY(-2px);
        }

        .btn-success {
            background: linear-gradient(135deg, var(--success-color), var(--success-dark));
            color: white;
        }

        .btn-danger {
            background: linear-gradient(135deg, var(--error-color), var(--error-dark));
            color: white;
        }

        .btn-group {
            display: flex;
            gap: 1rem;
            margin-top: 2rem;
            flex-wrap: wrap;
        }

        /* Graph Visualization */
        .graph-canvas {
            border: 2px solid var(--border-color);
            border-radius: 1rem;
            background: white;
            margin: 1rem 0;
            position: relative;
            overflow: hidden;
            cursor: pointer;
        }

        .graph-node {
            position: absolute;
            width: 40px;
            height: 40px;
            background: var(--gradient-graph);
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            color: white;
            font-weight: bold;
            cursor: pointer;
            transition: transform 0.2s ease;
            z-index: 10;
            box-shadow: var(--shadow-md);
        }

        .graph-node:hover {
            transform: scale(1.1);
            box-shadow: var(--shadow-lg);
        }

        .graph-node.selected {
            box-shadow: 0 0 0 4px rgba(124, 58, 237, 0.3);
            transform: scale(1.15);
        }

        .graph-edge {
            position: absolute;
            background: var(--primary-color);
            height: 3px;
            transform-origin: 0 50%;
            z-index: 5;
            transition: background 0.3s ease;
        }

        .graph-edge.directed::after {
            content: '';
            position: absolute;
            right: -10px;
            top: -7px;
            width: 0;
            height: 0;
            border-left: 10px solid var(--primary-color);
            border-top: 8px solid transparent;
            border-bottom: 8px solid transparent;
        }

        /* Quiz Elements */
        .quiz-option {
            display: block;
            width: 100%;
            padding: 1.25rem;
            margin: 0.75rem 0;
            background: var(--card-bg);
            border: 2px solid var(--border-color);
            border-radius: 1rem;
            text-align: left;
            cursor: pointer;
            transition: all var(--animation-duration) cubic-bezier(0.4, 0, 0.2, 1);
            position: relative;
            overflow: hidden;
        }

        .quiz-option:hover {
            background: var(--bg-secondary);
            border-color: var(--primary-light);
            transform: translateX(8px);
        }

        .quiz-option.selected {
            background: var(--gradient-primary);
            color: white;
            border-color: var(--primary-color);
        }

        .quiz-option.correct {
            background: linear-gradient(135deg, var(--success-color), var(--success-dark));
            color: white;
            border-color: var(--success-color);
            animation: correctAnswer 0.6s ease;
        }

        .quiz-option.incorrect {
            background: linear-gradient(135deg, var(--error-color), var(--error-dark));
            color: white;
            border-color: var(--error-color);
            animation: shake 0.5s ease;
        }

        @keyframes correctAnswer {
            0%, 100% { transform: translateX(0); }
            25% { transform: translateX(-5px); }
            75% { transform: translateX(5px); }
        }

        @keyframes shake {
            0%, 100% { transform: translateX(0); }
            10%, 30%, 50%, 70%, 90% { transform: translateX(-5px); }
            20%, 40%, 60%, 80% { transform: translateX(5px); }
        }

        /* Input Fields */
        .input-field {
            width: 100%;
            padding: 0.875rem 1.25rem;
            border: 2px solid var(--border-color);
            border-radius: 0.75rem;
            font-size: 1rem;
            transition: all var(--animation-duration) ease;
            background: var(--card-bg);
            font-family: inherit;
        }

        .input-field:focus {
            outline: none;
            border-color: var(--primary-color);
            box-shadow: 0 0 0 4px rgba(37, 99, 235, 0.1);
        }

        /* Matching Container */
        .matching-container {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 2rem;
            margin: 2rem 0;
        }

        .match-item {
            padding: 1.25rem;
            margin: 0.75rem 0;
            background: var(--card-bg);
            border: 2px solid var(--border-color);
            border-radius: 1rem;
            cursor: pointer;
            transition: all var(--animation-duration) ease;
            text-align: center;
            font-weight: 500;
        }

        .match-item:hover {
            background: var(--bg-secondary);
            transform: translateY(-2px);
            box-shadow: var(--shadow-md);
        }

        .match-item.selected {
            background: var(--gradient-primary);
            color: white;
            transform: scale(1.05);
        }

        .match-item.matched {
            opacity: 0.5;
            pointer-events: none;
            background: var(--success-color);
            color: white;
        }

        /* Code Editor */
        .code-editor {
            background: #1e293b;
            color: #e2e8f0;
            padding: 1.75rem;
            border-radius: 1rem;
            font-family: 'Consolas', 'Monaco', 'Courier New', monospace;
            font-size: 0.95rem;
            overflow-x: auto;
            margin: 1.5rem 0;
            line-height: 1.6;
            box-shadow: var(--shadow-lg);
        }

        .code-editor .keyword {
            color: #c084fc;
            font-weight: 600;
        }

        .code-editor .string {
            color: #86efac;
        }

        .code-editor .comment {
            color: #64748b;
            font-style: italic;
        }

        /* Graph Simulation Controls */
        .sim-controls {
            display: flex;
            gap: 1rem;
            margin: 1rem 0;
            padding: 1rem;
            background: var(--bg-secondary);
            border-radius: 0.75rem;
            align-items: center;
            flex-wrap: wrap;
        }

        .sim-step {
            padding: 0.5rem 1rem;
            background: var(--card-bg);
            border: 1px solid var(--border-color);
            border-radius: 0.5rem;
            font-size: 0.875rem;
        }

        .sim-step.active {
            background: var(--primary-color);
            color: white;
            border-color: var(--primary-color);
        }

        /* Achievement Popup */
        .achievement-popup {
            position: fixed;
            top: 100px;
            right: 20px;
            background: white;
            border-radius: 1.5rem;
            padding: 1.5rem 2rem;
            box-shadow: var(--shadow-xl);
            transform: translateX(400px);
            transition: transform 0.5s cubic-bezier(0.4, 0, 0.2, 1);
            z-index: 2000;
            max-width: 320px;
            border: 1px solid var(--border-color);
            overflow: hidden;
        }

        .achievement-popup::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            height: 4px;
            background: var(--gradient-graph);
        }

        .achievement-popup.show {
            transform: translateX(0);
        }

        .achievement-icon {
            font-size: 3.5rem;
            text-align: center;
            margin-bottom: 0.75rem;
            animation: bounceRotate 0.6s ease;
        }

        @keyframes bounceRotate {
            0% { transform: scale(0) rotate(0deg); }
            50% { transform: scale(1.2) rotate(180deg); }
            100% { transform: scale(1) rotate(360deg); }
        }

        /* Drawing Canvas */
        .drawing-canvas {
            border: 3px solid var(--border-color);
            border-radius: 1rem;
            background: white;
            touch-action: none;
            cursor: crosshair;
            margin: 1.5rem 0;
            box-shadow: var(--shadow-md);
        }

        /* Feedback Button */
        .feedback-btn {
            position: fixed;
            bottom: 20px;
            right: 20px;
            background: var(--gradient-primary);
            color: white;
            border: none;
            border-radius: 50%;
            width: 60px;
            height: 60px;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            box-shadow: var(--shadow-lg);
            transition: all var(--animation-duration) cubic-bezier(0.4, 0, 0.2, 1);
            z-index: 1000;
            font-size: 1.5rem;
        }

        .feedback-btn:hover {
            transform: scale(1.1) rotate(15deg);
        }

        /* Feedback Modal */
        .feedback-modal {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0,0,0,0.6);
            backdrop-filter: blur(8px);
            z-index: 2000;
            align-items: center;
            justify-content: center;
        }

        .feedback-content {
            background: white;
            padding: 2.5rem;
            border-radius: 1.5rem;
            max-width: 500px;
            width: 90%;
            max-height: 80vh;
            overflow-y: auto;
            box-shadow: var(--shadow-xl);
            animation: slideUp 0.3s ease;
        }

        @keyframes slideUp {
            from { transform: translateY(20px); opacity: 0; }
            to { transform: translateY(0); opacity: 1; }
        }

        /* Accessibility Controls */
        .accessibility-controls {
            position: fixed;
            top: 150px;
            right: 20px;
            background: white;
            border-radius: 1rem;
            padding: 1.25rem;
            box-shadow: var(--shadow-lg);
            z-index: 1000;
            border: 1px solid var(--border-color);
        }

        .accessibility-controls h4 {
            font-size: 0.875rem;
            font-weight: 600;
            margin-bottom: 0.75rem;
            color: var(--text-secondary);
            text-transform: uppercase;
            letter-spacing: 0.05em;
        }

        .accessibility-controls button {
            display: block;
            width: 100%;
            margin: 0.5rem 0;
            padding: 0.625rem;
            border: 1px solid var(--border-color);
            background: var(--bg-secondary);
            border-radius: 0.5rem;
            cursor: pointer;
            font-size: 0.875rem;
            transition: all var(--animation-duration) ease;
        }

        .accessibility-controls button:hover {
            background: var(--primary-color);
            color: white;
            border-color: var(--primary-color);
        }

        /* Shame Message */
        .shame-message {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%) scale(0);
            background: linear-gradient(135deg, var(--error-color), var(--error-dark));
            color: white;
            padding: 2rem 3rem;
            border-radius: 1.5rem;
            font-size: 1.25rem;
            font-weight: bold;
            text-align: center;
            z-index: 3000;
            box-shadow: var(--shadow-xl);
            animation: shameAnimation 3s ease forwards;
        }

        @keyframes shameAnimation {
            0% { transform: translate(-50%, -50%) scale(0) rotate(0deg); }
            20% { transform: translate(-50%, -50%) scale(1.2) rotate(-5deg); }
            40% { transform: translate(-50%, -50%) scale(0.9) rotate(5deg); }
            60% { transform: translate(-50%, -50%) scale(1) rotate(-5deg); }
            80% { transform: translate(-50%, -50%) scale(1) rotate(0deg); }
            100% { transform: translate(-50%, -50%) scale(0) rotate(0deg); }
        }

        /* Hint Container */
        .hint-container {
            margin-top: 1rem;
            padding: 1.25rem;
            background: linear-gradient(135deg, rgba(245, 158, 11, 0.1), rgba(245, 158, 11, 0.05));
            border-left: 4px solid var(--warning-color);
            border-radius: 0.75rem;
            display: none;
            animation: slideDown 0.3s ease;
        }

        .hint-container.show {
            display: block;
        }

        @keyframes slideDown {
            from { opacity: 0; transform: translateY(-10px); }
            to { opacity: 1; transform: translateY(0); }
        }

        /* Mark Scheme */
        .mark-scheme {
            background: linear-gradient(135deg, rgba(16, 185, 129, 0.1), rgba(16, 185, 129, 0.05));
            border: 2px solid var(--success-color);
            border-radius: 1rem;
            padding: 2rem;
            margin-top: 1.5rem;
            display: none;
        }

        .mark-scheme.show {
            display: block;
        }

        /* Font Size Controls */
        .font-size-controls {
            display: flex;
            gap: 0.5rem;
            align-items: center;
            margin-top: 0.5rem;
        }

        .font-size-controls button {
            padding: 0.5rem 0.75rem;
            margin: 0;
        }

        body.font-small { font-size: 14px; }
        body.font-large { font-size: 18px; }
        body.font-xlarge { font-size: 20px; }

        /* Loading Animation */
        .loading {
            display: inline-block;
            width: 20px;
            height: 20px;
            border: 3px solid transparent;
            border-top-color: var(--primary-color);
            border-radius: 50%;
            animation: spin 1s linear infinite;
        }

        @keyframes spin {
            to { transform: rotate(360deg); }
        }

        /* Particle Container */
        #particle-container {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 2999;
        }

        .particle {
            position: absolute;
            width: 8px;
            height: 8px;
            border-radius: 50%;
            pointer-events: none;
            animation: particleFall 2s linear forwards;
        }

        @keyframes particleFall {
            to {
                transform: translateY(100vh);
                opacity: 0;
            }
        }

        /* Quiz Question Styling */
        .quiz-question {
            margin-bottom: 2rem;
            padding: 1.5rem;
            background: var(--bg-secondary);
            border-radius: 1rem;
            border: 1px solid var(--border-color);
        }

        .quiz-question p {
            font-weight: 600;
            margin-bottom: 1rem;
            color: var(--text-color);
        }

        /* Success Animation */
        @keyframes successPulse {
            0% { box-shadow: 0 0 0 0 rgba(16, 185, 129, 0.4); }
            70% { box-shadow: 0 0 0 20px rgba(16, 185, 129, 0); }
            100% { box-shadow: 0 0 0 0 rgba(16, 185, 129, 0); }
        }

        .success-animation {
            animation: successPulse 1s ease;
        }

        /* Graph Visualization Specific */
        .adjacency-matrix {
            display: grid;
            gap: 0.25rem;
            margin: 1rem 0;
            padding: 1rem;
            background: var(--bg-secondary);
            border-radius: 0.75rem;
        }

        .matrix-cell {
            padding: 0.5rem;
            background: white;
            border: 1px solid var(--border-color);
            text-align: center;
            font-weight: 600;
            transition: all 0.2s ease;
        }

        .matrix-cell:hover {
            background: var(--primary-light);
            color: white;
        }

        .matrix-cell.header {
            background: var(--primary-color);
            color: white;
        }

        /* Mobile Responsive */
        @media (max-width: 768px) {
            .header h1 {
                font-size: 1.25rem;
            }

            .header-content {
                flex-direction: column;
                text-align: center;
            }

            .xp-container {
                width: 100%;
                justify-content: center;
            }

            .xp-bar {
                width: 150px;
            }

            .matching-container {
                grid-template-columns: 1fr;
                gap: 1rem;
            }

            .nav-container {
                top: 140px;
            }

            .btn-group {
                flex-direction: column;
            }

            .btn {
                width: 100%;
                justify-content: center;
            }

            .accessibility-controls {
                top: auto;
                bottom: 90px;
                right: 10px;
                padding: 1rem;
            }

            .card {
                padding: 1.5rem;
            }

            .achievement-popup {
                right: 10px;
                left: 10px;
                max-width: none;
            }
        }

        /* Print Styles */
        @media print {
            .header, .nav-container, .feedback-btn, .accessibility-controls, .btn {
                display: none !important;
            }

            .section {
                display: block !important;
                opacity: 1 !important;
                transform: none !important;
                page-break-after: always;
            }

            .card {
                box-shadow: none;
                border: 1px solid #000;
            }
        }

        /* Custom Scrollbar */
        ::-webkit-scrollbar {
            width: 12px;
            height: 12px;
        }

        ::-webkit-scrollbar-track {
            background: var(--bg-secondary);
        }

        ::-webkit-scrollbar-thumb {
            background: var(--primary-light);
            border-radius: 6px;
            border: 2px solid var(--bg-secondary);
        }

        ::-webkit-scrollbar-thumb:hover {
            background: var(--primary-color);
        }

        /* Performance Optimizations */
        .section:not(.active) {
            visibility: hidden;
        }

        iframe {
            width: 100%;
            height: 80vh;
            border: none;
            display: block;
        }

        /* Additional for Graph Lesson */
        .graph-type-toggle {
            display: flex;
            gap: 1rem;
            margin: 1rem 0;
        }

        .toggle-btn {
            padding: 0.75rem 1.5rem;
            background: var(--card-bg);
            border: 2px solid var(--border-color);
            border-radius: 0.75rem;
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .toggle-btn.active {
            background: var(--primary-color);
            color: white;
            border-color: var(--primary-color);
        }

        /* Fill in the blanks specific */
        .fill-blank-select {
            padding: 0.5rem 1rem;
            margin: 0 0.25rem;
            border: 2px solid var(--primary-light);
            border-radius: 0.5rem;
            background: var(--bg-secondary);
            cursor: pointer;
            font-size: inherit;
            font-family: inherit;
            transition: all 0.2s ease;
        }

        .fill-blank-select:focus {
            outline: none;
            border-color: var(--primary-color);
            background: white;
        }

        /* Floating XP indicator */
        @keyframes floatUp {
            0% { transform: translateY(0); opacity: 1; }
            100% { transform: translateY(-50px); opacity: 0; }
        }
    </style>
</head>
<body>
    <!-- Header -->
    <header class="header" role="banner">
        <div class="header-content">
            <h1>üåê Graphs - Non-Linear Data Structures</h1>
            <div class="xp-container" role="status" aria-live="polite">
                <span class="level-badge">Level <span id="current-level">1</span></span>
                <div class="xp-bar" role="progressbar" aria-valuenow="0" aria-valuemin="0" aria-valuemax="100">
                    <div class="xp-fill" id="xp-fill" style="width: 0%"></div>
                </div>
                <span id="xp-text">0 / 100 XP</span>
            </div>
        </div>
    </header>

    <!-- Navigation -->
    <nav class="nav-container" role="navigation" aria-label="Lesson sections">
        <div class="nav-pills" id="nav-pills">
            <button class="nav-pill active" data-section="intro">Introduction</button>
            <button class="nav-pill" data-section="starter">Starter Activity</button>
            <button class="nav-pill" data-section="fundamentals">Graph Fundamentals</button>
            <button class="nav-pill" data-section="types">Types of Graphs</button>
            <button class="nav-pill" data-section="representations">Representations</button>
            <button class="nav-pill" data-section="applications">Real-World Applications</button>
            <button class="nav-pill" data-section="ai">Graphs in AI</button>
            <button class="nav-pill" data-section="algorithms">Graph Algorithms</button>
            <button class="nav-pill" data-section="practice">Build a Graph</button>
            <button class="nav-pill" data-section="summary">Summary & Quiz</button>
            <button class="nav-pill" data-section="exam">Exam Practice</button>
            <button class="nav-pill" data-section="extension">Extension</button>
            <button class="nav-pill" data-section="videos">Videos</button>
        </div>
    </nav>

    <!-- Main Content -->
    <main class="main-content" role="main">
        <!-- Introduction Section -->
        <section id="intro" class="section active">
            <div class="card">
                <h2 class="card-title">
                    <span>üìö</span> Welcome to Graphs!
                </h2>
                
                <h3>Learning Outcomes</h3>
                <ul style="margin: 1rem 0; padding-left: 1.5rem; line-height: 1.8;">
                    <li>Understand what graphs are and their components (nodes and edges)</li>
                    <li>Differentiate between directed and undirected graphs</li>
                    <li>Represent graphs using adjacency matrices and lists</li>
                    <li>Identify real-world applications of graphs</li>
                    <li>Understand how graphs are used in AI and machine learning</li>
                    <li>Apply basic graph algorithms like traversal</li>
                    <li>Analyze the advantages of using graphs for modeling relationships</li>
                </ul>

                <div class="interactive-area highlight-active">
                    <h4>Pre-Assessment: Test Your Knowledge</h4>
                    <p>Let's see what you already know about graphs!</p>
                    
                    <div id="pre-quiz">
                        <p><strong>Question 1:</strong> Which of these is NOT typically represented using a graph?</p>
                        <button class="quiz-option" data-answer="a">Social media connections</button>
                        <button class="quiz-option" data-answer="b">A shopping list</button>
                        <button class="quiz-option" data-answer="c">Road networks</button>
                        <button class="quiz-option" data-answer="d">Website links</button>
                    </div>
                    
                    <button class="btn btn-primary" onclick="checkPreQuiz()" style="margin-top: 1rem;">
                        Check Answer
                    </button>
                </div>

                <div class="btn-group">
                    <button class="btn btn-primary" onclick="navigateSection('next')">
                        Start Learning ‚Üí
                    </button>
                </div>
            </div>
        </section>

        <!-- Starter Activity -->
        <section id="starter" class="section">
            <div class="card">
                <h2 class="card-title">
                    <span>üéØ</span> Starter Activity: Graph Components
                </h2>
                
                <p>Match the graph terminology to their definitions by clicking items in the correct order!</p>
                
                <div class="matching-container" id="starter-matching">
                    <div>
                        <h4>Terms</h4>
                        <div class="match-item" data-id="node">Node (Vertex)</div>
                        <div class="match-item" data-id="edge">Edge</div>
                        <div class="match-item" data-id="directed">Directed Graph</div>
                        <div class="match-item" data-id="undirected">Undirected Graph</div>
                        <div class="match-item" data-id="weight">Weighted Edge</div>
                        <div class="match-item" data-id="path">Path</div>
                    </div>
                    <div>
                        <h4>Definitions</h4>
                        <div class="match-item" data-match="node">A point that stores data in a graph</div>
                        <div class="match-item" data-match="edge">A connection between two nodes</div>
                        <div class="match-item" data-match="directed">Graph where edges have a specific direction</div>
                        <div class="match-item" data-match="undirected">Graph where edges work both ways</div>
                        <div class="match-item" data-match="weight">Edge with an associated value or cost</div>
                        <div class="match-item" data-match="path">A sequence of edges connecting nodes</div>
                    </div>
                </div>
                
                <div class="btn-group">
                    <button class="btn btn-secondary" onclick="resetStarterActivity()">Reset Activity</button>
                    <button class="btn btn-secondary" onclick="navigateSection('prev')">‚Üê Previous</button>
                    <button class="btn btn-primary" onclick="navigateSection('next')">Next ‚Üí</button>
                </div>
            </div>
        </section>

        <!-- Graph Fundamentals -->
        <section id="fundamentals" class="section">
            <div class="card">
                <h2 class="card-title">
                    <span>üîß</span> Graph Fundamentals
                </h2>
                
                <h3>What is a Graph?</h3>
                <p>A graph is a non-linear data structure consisting of nodes (vertices) and edges that connect pairs of nodes. Unlike linear structures (arrays, linked lists), graphs can represent complex relationships between data.</p>
                
                <div class="interactive-area">
                    <h4>Interactive: Build Your First Graph</h4>
                    <p>Click on the canvas to add nodes. Click two nodes to connect them with an edge!</p>
                    
                    <div id="graph-canvas-1" class="graph-canvas" style="height: 300px; position: relative;">
                        <!-- Nodes will be added dynamically -->
                    </div>
                    
                    <div class="sim-controls">
                        <button class="btn btn-secondary" onclick="clearGraph('graph-canvas-1')">Clear Graph</button>
                        <span class="sim-step">Nodes: <span id="node-count-1">0</span></span>
                        <span class="sim-step">Edges: <span id="edge-count-1">0</span></span>
                    </div>
                </div>
                
                <div class="interactive-area highlight-active">
                    <h4>Quick Check: Graph Components</h4>
                    <p>Fill in the blanks with the correct terms:</p>
                    
                    <div style="margin: 1rem 0; line-height: 2;">
                        <p>1. In a graph, data is stored in 
                            <select class="fill-blank-select" id="blank1">
                                <option value="">Choose...</option>
                                <option value="nodes">nodes</option>
                                <option value="edges">edges</option>
                                <option value="arrays">arrays</option>
                                <option value="pointers">pointers</option>
                                <option value="lists">lists</option>
                            </select>
                        </p>
                        
                        <p>2. The connections between nodes are called 
                            <select class="fill-blank-select" id="blank2">
                                <option value="">Choose...</option>
                                <option value="vertices">vertices</option>
                                <option value="links">links</option>
                                <option value="edges">edges</option>
                                <option value="nodes">nodes</option>
                                <option value="paths">paths</option>
                            </select>
                        </p>
                        
                        <p>3. A graph is a 
                            <select class="fill-blank-select" id="blank3">
                                <option value="">Choose...</option>
                                <option value="linear">linear</option>
                                <option value="non-linear">non-linear</option>
                                <option value="circular">circular</option>
                                <option value="sequential">sequential</option>
                                <option value="hierarchical">hierarchical</option>
                            </select>
                            data structure.
                        </p>
                    </div>
                    
                    <button class="btn btn-primary" onclick="checkFundamentals()">Check Answers</button>
                    <button class="btn btn-secondary" onclick="showHint('fundamentals')">Need a Hint?</button>
                </div>
                
                <div class="hint-container" id="fundamentals-hint">
                    <p>üí° Hint: Think about what stores the actual data and what connects different pieces of data together. Graphs can have connections in multiple directions!</p>
                </div>
                
                <div class="btn-group">
                    <button class="btn btn-secondary" onclick="navigateSection('prev')">‚Üê Previous</button>
                    <button class="btn btn-primary" onclick="navigateSection('next')">Next ‚Üí</button>
                </div>
            </div>
        </section>

        <!-- Types of Graphs -->
        <section id="types" class="section">
            <div class="card">
                <h2 class="card-title">
                    <span>üìä</span> Types of Graphs
                </h2>
                
                <h3>Directed vs Undirected Graphs</h3>
                
                <div class="interactive-area">
                    <h4>Interactive Demonstration</h4>
                    <p>Toggle between directed and undirected graphs to see the difference!</p>
                    
                    <div class="graph-type-toggle">
                        <button class="toggle-btn active" onclick="setGraphType('undirected')">Undirected</button>
                        <button class="toggle-btn" onclick="setGraphType('directed')">Directed</button>
                    </div>
                    
                    <div id="graph-canvas-2" class="graph-canvas" style="height: 300px; position: relative;">
                        <!-- Pre-populated graph will be shown here -->
                    </div>
                    
                    <div id="graph-explanation" style="margin-top: 1rem; padding: 1rem; background: var(--highlight-color); border-radius: 0.5rem;">
                        <p><strong>Undirected Graph:</strong> Edges have no direction. If A connects to B, then B also connects to A.</p>
                    </div>
                </div>
                
                <div class="interactive-area highlight-active">
                    <h4>Identify the Graph Type</h4>
                    <p>Based on the following scenarios, identify whether you would use a directed or undirected graph:</p>
                    
                    <div class="quiz-question">
                        <p>1. Facebook friendships (if A is friends with B, B is friends with A)</p>
                        <button class="quiz-option" data-q="1" data-a="directed">Directed Graph</button>
                        <button class="quiz-option" data-q="1" data-a="undirected">Undirected Graph</button>
                    </div>
                    
                    <div class="quiz-question">
                        <p>2. Twitter follows (A can follow B without B following A)</p>
                        <button class="quiz-option" data-q="2" data-a="undirected">Undirected Graph</button>
                        <button class="quiz-option" data-q="2" data-a="directed">Directed Graph</button>
                    </div>
                    
                    <div class="quiz-question">
                        <p>3. Road network between cities (roads work both ways)</p>
                        <button class="quiz-option" data-q="3" data-a="directed">Directed Graph</button>
                        <button class="quiz-option" data-q="3" data-a="undirected">Undirected Graph</button>
                    </div>
                    
                    <button class="btn btn-primary" onclick="checkGraphTypes()">Check Answers</button>
                </div>
                
                <button class="btn btn-secondary" onclick="resetTypesSection()">Reset Section</button>
                
                <div class="btn-group">
                    <button class="btn btn-secondary" onclick="navigateSection('prev')">‚Üê Previous</button>
                    <button class="btn btn-primary" onclick="navigateSection('next')">Next ‚Üí</button>
                </div>
            </div>
        </section>

        <!-- Graph Representations -->
        <section id="representations" class="section">
            <div class="card">
                <h2 class="card-title">
                    <span>üóÇÔ∏è</span> Graph Representations
                </h2>
                
                <h3>Adjacency Matrix</h3>
                <p>A 2D array where matrix[i][j] = 1 if there's an edge from node i to node j, 0 otherwise.</p>
                
                <div class="interactive-area">
                    <h4>Interactive Adjacency Matrix</h4>
                    <p>Click cells to toggle connections between nodes!</p>
                    
                    <div id="adjacency-matrix" class="adjacency-matrix" style="grid-template-columns: repeat(5, 1fr);">
                        <!-- Matrix will be generated dynamically -->
                    </div>
                    
                    <div id="matrix-graph" class="graph-canvas" style="height: 250px; margin-top: 1rem; position: relative;">
                        <!-- Graph visualization of matrix -->
                    </div>
                </div>
                
                <h3 style="margin-top: 2rem;">Adjacency List</h3>
                <p>Each node stores a list of its connected nodes. More memory-efficient for sparse graphs.</p>
                
                <div class="code-editor">
                    <span class="comment">// Example adjacency list representation</span><br>
                    <span class="keyword">const</span> graph = {<br>
                    &nbsp;&nbsp;A: [<span class="string">'B'</span>, <span class="string">'C'</span>],<br>
                    &nbsp;&nbsp;B: [<span class="string">'A'</span>, <span class="string">'D'</span>],<br>
                    &nbsp;&nbsp;C: [<span class="string">'A'</span>, <span class="string">'D'</span>],<br>
                    &nbsp;&nbsp;D: [<span class="string">'B'</span>, <span class="string">'C'</span>]<br>
                    };
                </div>
                
                <div class="interactive-area highlight-active">
                    <h4>Representation Quiz</h4>
                    <p>Which representation is more memory-efficient for a sparse graph (few edges)?</p>
                    
                    <button class="quiz-option" onclick="checkRepresentation('matrix')">Adjacency Matrix</button>
                    <button class="quiz-option" onclick="checkRepresentation('list')">Adjacency List</button>
                    
                    <p style="margin-top: 1.5rem;">For a graph with n nodes, what is the space complexity of an adjacency matrix?</p>
                    <button class="quiz-option" onclick="checkComplexity('n')">O(n)</button>
                    <button class="quiz-option" onclick="checkComplexity('n2')">O(n¬≤)</button>
                    <button class="quiz-option" onclick="checkComplexity('nlogn')">O(n log n)</button>
                    <button class="quiz-option" onclick="checkComplexity('2n')">O(2n)</button>
                </div>
                
                <button class="btn btn-secondary" onclick="resetRepresentations()">Reset Section</button>
                
                <div class="btn-group">
                    <button class="btn btn-secondary" onclick="navigateSection('prev')">‚Üê Previous</button>
                    <button class="btn btn-primary" onclick="navigateSection('next')">Next ‚Üí</button>
                </div>
            </div>
        </section>

        <!-- Real-World Applications -->
        <section id="applications" class="section">
            <div class="card">
                <h2 class="card-title">
                    <span>üåç</span> Real-World Applications
                </h2>
                
                <div class="interactive-area">
                    <h4>Explore Graph Applications</h4>
                    <p>Click on each application to see how graphs are used:</p>
                    
                    <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(200px, 1fr)); gap: 1rem; margin: 1rem 0;">
                        <div class="match-item" onclick="showApplication('bus')">
                            üöå Bus Routes
                        </div>
                        <div class="match-item" onclick="showApplication('web')">
                            üåê Websites
                        </div>
                        <div class="match-item" onclick="showApplication('social')">
                            üë• Social Networks
                        </div>
                        <div class="match-item" onclick="showApplication('gps')">
                            üìç GPS Navigation
                        </div>
                    </div>
                    
                    <div id="application-details" style="margin-top: 1.5rem; padding: 1.5rem; background: var(--bg-secondary); border-radius: 0.75rem; display: none;">
                        <!-- Application details will appear here -->
                    </div>
                </div>
                
                <div class="interactive-area highlight-active">
                    <h4>Application Scenarios</h4>
                    <p>Match each scenario to the graph concept it represents:</p>
                    
                    <div style="margin: 1.5rem 0;">
                        <p>1. Finding the shortest route between two cities</p>
                        <select class="fill-blank-select" id="app1">
                            <option value="">Choose concept...</option>
                            <option value="traversal">Graph Traversal</option>
                            <option value="shortest">Shortest Path Algorithm</option>
                            <option value="cycle">Cycle Detection</option>
                            <option value="spanning">Spanning Tree</option>
                        </select>
                        
                        <p style="margin-top: 1rem;">2. Detecting if a website has circular references</p>
                        <select class="fill-blank-select" id="app2">
                            <option value="">Choose concept...</option>
                            <option value="shortest">Shortest Path Algorithm</option>
                            <option value="traversal">Graph Traversal</option>
                            <option value="spanning">Spanning Tree</option>
                            <option value="cycle">Cycle Detection</option>
                        </select>
                        
                        <p style="margin-top: 1rem;">3. Finding all friends within 2 connections on social media</p>
                        <select class="fill-blank-select" id="app3">
                            <option value="">Choose concept...</option>
                            <option value="cycle">Cycle Detection</option>
                            <option value="traversal">Breadth-First Search</option>
                            <option value="shortest">Shortest Path Algorithm</option>
                            <option value="spanning">Spanning Tree</option>
                        </select>
                    </div>
                    
                    <button class="btn btn-primary" onclick="checkApplications()">Check Answers</button>
                </div>
                
                <button class="btn btn-secondary" onclick="resetApplications()">Reset Section</button>
                
                <div class="btn-group">
                    <button class="btn btn-secondary" onclick="navigateSection('prev')">‚Üê Previous</button>
                    <button class="btn btn-primary" onclick="navigateSection('next')">Next ‚Üí</button>
                </div>
            </div>
        </section>

        <!-- Graphs in AI -->
        <section id="ai" class="section">
            <div class="card">
                <h2 class="card-title">
                    <span>ü§ñ</span> Graphs in Artificial Intelligence
                </h2>
                
                <h3>Neural Networks as Graphs</h3>
                <p>Artificial Neural Networks can be represented as directed graphs where:</p>
                <ul style="margin: 1rem 0; padding-left: 1.5rem;">
                    <li>Nodes represent neurons</li>
                    <li>Edges represent weighted connections</li>
                    <li>The graph structure defines information flow</li>
                </ul>
                
                <div class="interactive-area">
                    <h4>Interactive Neural Network</h4>
                    <p>This simplified neural network shows how data flows through layers:</p>
                    
                    <div id="neural-network" class="graph-canvas" style="height: 350px; position: relative;">
                        <!-- Neural network visualization -->
                    </div>
                    
                    <div class="sim-controls">
                        <button class="btn btn-secondary" onclick="animateNeuralNetwork()">Animate Data Flow</button>
                        <button class="btn btn-secondary" onclick="resetNeuralNetwork()">Reset</button>
                    </div>
                </div>
                
                <h3 style="margin-top: 2rem;">Graph Algorithms in AI</h3>
                
                <div class="interactive-area highlight-active">
                    <h4>AI Algorithm Applications</h4>
                    <p>Match the algorithm to its AI application:</p>
                    
                    <div class="quiz-question">
                        <p>1. A* Algorithm is commonly used in:</p>
                        <button class="quiz-option" data-q="ai1" data-a="path">Pathfinding in games</button>
                        <button class="quiz-option" data-q="ai1" data-a="train">Training neural networks</button>
                        <button class="quiz-option" data-q="ai1" data-a="sort">Sorting data</button>
                        <button class="quiz-option" data-q="ai1" data-a="compress">Data compression</button>
                    </div>
                    
                    <div class="quiz-question">
                        <p>2. Backpropagation in neural networks involves:</p>
                        <button class="quiz-option" data-q="ai2" data-a="forward">Moving data forward only</button>
                        <button class="quiz-option" data-q="ai2" data-a="sort">Sorting network layers</button>
                        <button class="quiz-option" data-q="ai2" data-a="backward">Propagating errors backward through the graph</button>
                        <button class="quiz-option" data-q="ai2" data-a="delete">Removing unnecessary nodes</button>
                    </div>
                    
                    <button class="btn btn-primary" onclick="checkAIQuestions()">Check Answers</button>
                </div>
                
                <button class="btn btn-secondary" onclick="showHint('ai')">Need a Hint?</button>
                
                <div class="hint-container" id="ai-hint">
                    <p>üí° Hint: A* is famous for finding optimal paths, while backpropagation is how neural networks learn from their mistakes!</p>
                </div>
                
                <div class="btn-group">
                    <button class="btn btn-secondary" onclick="navigateSection('prev')">‚Üê Previous</button>
                    <button class="btn btn-primary" onclick="navigateSection('next')">Next ‚Üí</button>
                </div>
            </div>
        </section>

        <!-- Graph Algorithms -->
        <section id="algorithms" class="section">
            <div class="card">
                <h2 class="card-title">
                    <span>‚ö°</span> Graph Algorithms
                </h2>
                
                <h3>Introduction to Graph Traversal</h3>
                <p>Two main approaches to visit all nodes in a graph:</p>
                
                <div class="interactive-area">
                    <h4>Depth-First Search (DFS) vs Breadth-First Search (BFS)</h4>
                    <p>Watch how each algorithm explores the graph differently:</p>
                    
                    <div id="traversal-graph" class="graph-canvas" style="height: 300px; position: relative;">
                        <!-- Graph for traversal demonstration -->
                    </div>
                    
                    <div class="sim-controls">
                        <button class="btn btn-secondary" onclick="startDFS()">Run DFS</button>
                        <button class="btn btn-secondary" onclick="startBFS()">Run BFS</button>
                        <button class="btn btn-secondary" onclick="resetTraversal()">Reset</button>
                        <div class="sim-step">Visited: <span id="visited-nodes">[]</span></div>
                    </div>
                </div>
                
                <h3 style="margin-top: 2rem;">Dijkstra's Algorithm</h3>
                <p>Finds the shortest path between nodes in a weighted graph.</p>
                
                <div class="code-editor">
                    <span class="comment">// Dijkstra's algorithm concept</span><br>
                    1. Start at the source node<br>
                    2. Set distance to source = 0, all others = infinity<br>
                    3. For current node, update distances to neighbors<br>
                    4. Mark current node as visited<br>
                    5. Select unvisited node with minimum distance<br>
                    6. Repeat until destination reached
                </div>
                
                <div class="interactive-area highlight-active">
                    <h4>Algorithm Complexity</h4>
                    <p>Test your understanding of algorithm characteristics:</p>
                    
                    <p>1. Which algorithm guarantees the shortest path in a weighted graph?</p>
                    <button class="quiz-option" onclick="checkAlgorithm('dfs')">Depth-First Search</button>
                    <button class="quiz-option" onclick="checkAlgorithm('bfs')">Breadth-First Search</button>
                    <button class="quiz-option" onclick="checkAlgorithm('dijkstra')">Dijkstra's Algorithm</button>
                    <button class="quiz-option" onclick="checkAlgorithm('random')">Random Walk</button>
                    
                    <p style="margin-top: 1.5rem;">2. True or False: A* algorithm uses heuristics to improve on Dijkstra's algorithm</p>
                    <button class="quiz-option" onclick="checkTrueFalse('true', 'astar')">True</button>
                    <button class="quiz-option" onclick="checkTrueFalse('false', 'astar')">False</button>
                </div>
                
                <div class="btn-group">
                    <button class="btn btn-secondary" onclick="navigateSection('prev')">‚Üê Previous</button>
                    <button class="btn btn-primary" onclick="navigateSection('next')">Next ‚Üí</button>
                </div>
            </div>
        </section>

        <!-- Build a Graph Practice -->
        <section id="practice" class="section">
            <div class="card">
                <h2 class="card-title">
                    <span>üî®</span> Build a Graph - Practical Exercise
                </h2>
                
                <div class="interactive-area highlight-active">
                    <h4>Challenge: Create a Social Network Graph</h4>
                    <p>Build a graph representing a small social network with at least 5 people and their friendships.</p>
                    
                    <div id="practice-graph" class="graph-canvas" style="height: 400px; position: relative;">
                        <!-- Practice graph canvas -->
                    </div>
                    
                    <div class="sim-controls">
                        <input type="text" id="person-name" class="input-field" style="width: 200px; display: inline-block;" placeholder="Enter person's name">
                        <button class="btn btn-secondary" onclick="addPerson()">Add Person</button>
                        <button class="btn btn-secondary" onclick="clearPracticeGraph()">Clear All</button>
                    </div>
                    
                    <div style="margin-top: 1rem;">
                        <p><strong>Instructions:</strong></p>
                        <ol style="padding-left: 1.5rem;">
                            <li>Enter a name and click "Add Person" to create nodes</li>
                            <li>Click two people to create a friendship (edge)</li>
                            <li>Create at least 5 people and 6 friendships</li>
                            <li>Try to create a realistic social network!</li>
                        </ol>
                    </div>
                    
                    <button class="btn btn-primary" onclick="checkPracticeGraph()" style="margin-top: 1rem;">
                        Submit Graph
                    </button>
                </div>
                
                <div class="interactive-area" style="margin-top: 2rem;">
                    <h4>Graph Analysis</h4>
                    <p>Answer these questions about your social network graph:</p>
                    
                    <textarea class="input-field" id="analysis1" rows="3" placeholder="1. Who has the most connections in your network? Why might this person be considered influential?"></textarea>
                    
                    <textarea class="input-field" id="analysis2" rows="3" placeholder="2. Are there any isolated groups (clusters) in your network? What might this represent in real life?" style="margin-top: 1rem;"></textarea>
                    
                    <textarea class="input-field" id="analysis3" rows="3" placeholder="3. What is the shortest path between your two most distant people? How many 'hops' does it take?" style="margin-top: 1rem;"></textarea>
                    
                    <button class="btn btn-primary" onclick="submitAnalysis()">Submit Analysis</button>
                </div>
                
                <div class="btn-group">
                    <button class="btn btn-secondary" onclick="navigateSection('prev')">‚Üê Previous</button>
                    <button class="btn btn-primary" onclick="navigateSection('next')">Next ‚Üí</button>
                </div>
            </div>
        </section>

        <!-- Summary & Quiz -->
        <section id="summary" class="section">
            <div class="card">
                <h2 class="card-title">
                    <span>üìù</span> Summary & Final Quiz
                </h2>
                
                <h3>Key Takeaways</h3>
                <ul style="margin: 1rem 0; padding-left: 1.5rem;">
                    <li><strong>Graphs</strong> are non-linear data structures with nodes and edges</li>
                    <li><strong>Directed graphs</strong> have edges with specific directions</li>
                    <li><strong>Undirected graphs</strong> have bidirectional edges</li>
                    <li><strong>Adjacency matrices</strong> use 2D arrays, while <strong>adjacency lists</strong> use linked structures</li>
                    <li>Graphs model real-world relationships in social networks, maps, and websites</li>
                    <li><strong>AI applications</strong> include neural networks and pathfinding algorithms</li>
                    <li>Key algorithms: DFS, BFS, Dijkstra's, A*</li>
                </ul>
                
                <div class="interactive-area highlight-active">
                    <h4>Final Assessment</h4>
                    <div id="final-quiz">
                        <!-- Question 1 -->
                        <div class="quiz-question">
                            <p><strong>1. What is the main characteristic of a graph data structure?</strong></p>
                            <button class="quiz-option" data-q="1" data-a="a">It stores data in a linear sequence</button>
                            <button class="quiz-option" data-q="1" data-a="b">It consists of nodes connected by edges</button>
                            <button class="quiz-option" data-q="1" data-a="c">It only works with numeric data</button>
                            <button class="quiz-option" data-q="1" data-a="d">It requires sorted data</button>
                        </div>
                        
                        <!-- Question 2 -->
                        <div class="quiz-question">
                            <p><strong>2. In a directed graph, edges:</strong></p>
                            <button class="quiz-option" data-q="2" data-a="a">Work in both directions</button>
                            <button class="quiz-option" data-q="2" data-a="b">Have no direction</button>
                            <button class="quiz-option" data-q="2" data-a="c">Have a specific direction from one node to another</button>
                            <button class="quiz-option" data-q="2" data-a="d">Connect more than two nodes</button>
                        </div>
                        
                        <!-- Question 3 -->
                        <div class="quiz-question">
                            <p><strong>3. Which representation uses O(n¬≤) space for n nodes?</strong></p>
                            <button class="quiz-option" data-q="3" data-a="a">Adjacency List</button>
                            <button class="quiz-option" data-q="3" data-a="b">Adjacency Matrix</button>
                            <button class="quiz-option" data-q="3" data-a="c">Edge List</button>
                            <button class="quiz-option" data-q="3" data-a="d">Node Array</button>
                        </div>
                        
                        <!-- Question 4 -->
                        <div class="quiz-question">
                            <p><strong>4. Which algorithm is specifically designed for finding shortest paths?</strong></p>
                            <button class="quiz-option" data-q="4" data-a="a">Depth-First Search</button>
                            <button class="quiz-option" data-q="4" data-a="b">Breadth-First Search</button>
                            <button class="quiz-option" data-q="4" data-a="c">Binary Search</button>
                            <button class="quiz-option" data-q="4" data-a="d">Dijkstra's Algorithm</button>
                        </div>
                        
                        <!-- Question 5 -->
                        <div class="quiz-question">
                            <p><strong>5. In AI, neural networks can be represented as:</strong></p>
                            <button class="quiz-option" data-q="5" data-a="a">Undirected graphs only</button>
                            <button class="quiz-option" data-q="5" data-a="b">Trees only</button>
                            <button class="quiz-option" data-q="5" data-a="c">Directed graphs with weighted edges</button>
                            <button class="quiz-option" data-q="5" data-a="d">Lists of numbers</button>
                        </div>
                        
                        <!-- Question 6 -->
                        <div class="quiz-question">
                            <p><strong>6. Which is NOT a typical application of graphs?</strong></p>
                            <button class="quiz-option" data-q="6" data-a="a">Social media connections</button>
                            <button class="quiz-option" data-q="6" data-a="b">GPS navigation</button>
                            <button class="quiz-option" data-q="6" data-a="c">Sorting numbers</button>
                            <button class="quiz-option" data-q="6" data-a="d">Website link structure</button>
                        </div>
                        
                        <!-- Question 7 -->
                        <div class="quiz-question">
                            <p><strong>7. True or False: In an undirected graph, if A connects to B, then B connects to A</strong></p>
                            <button class="quiz-option" data-q="7" data-a="a">True</button>
                            <button class="quiz-option" data-q="7" data-a="b">False</button>
                        </div>
                        
                        <!-- Question 8 -->
                        <div class="quiz-question">
                            <p><strong>8. Backpropagation in neural networks uses graphs to:</strong></p>
                            <button class="quiz-option" data-q="8" data-a="a">Store training data</button>
                            <button class="quiz-option" data-q="8" data-a="b">Propagate errors backward through the network</button>
                            <button class="quiz-option" data-q="8" data-a="c">Sort neurons by importance</button>
                            <button class="quiz-option" data-q="8" data-a="d">Delete unnecessary connections</button>
                        </div>
                    </div>
                    
                    <button class="btn btn-primary" onclick="submitFinalQuiz()">Submit Quiz</button>
                    
                    <div id="quiz-results" style="margin-top: 2rem; display: none;">
                        <h4>Your Results:</h4>
                        <p id="quiz-score"></p>
                        <div id="quiz-feedback"></div>
                    </div>
                </div>
                
                <div class="btn-group">
                    <button class="btn btn-secondary" onclick="navigateSection('prev')">‚Üê Previous</button>
                    <button class="btn btn-primary" onclick="navigateSection('next')">Next ‚Üí</button>
                </div>
            </div>
        </section>

        <!-- Exam Practice -->
        <section id="exam" class="section">
            <div class="card">
                <h2 class="card-title">
                    <span>üìã</span> Exam Practice Questions
                </h2>
                
                <div class="interactive-area">
                    <h4>Question 1 (4 marks)</h4>
                    <p>Explain the difference between directed and undirected graphs. Give one example of each from real-world applications.</p>
                    
                    <textarea class="input-field" id="exam-q1" rows="8" placeholder="Write your answer here..."></textarea>
                    
                    <div style="margin-top: 1rem;">
                        <label>Predicted marks: 
                            <input type="number" id="marks-q1" min="0" max="4" style="width: 50px;" class="input-field">
                        </label>
                        <button class="btn btn-secondary" onclick="showMarkScheme('q1')">Show Mark Scheme</button>
                    </div>
                    
                    <div class="mark-scheme" id="mark-scheme-q1">
                        <h5>Mark Scheme:</h5>
                        <ul style="padding-left: 1.5rem;">
                            <li>Directed graph: edges have direction/one-way connections (1 mark)</li>
                            <li>Undirected graph: edges work both ways/bidirectional (1 mark)</li>
                            <li>Valid example of directed graph (e.g., Twitter follows, web links) (1 mark)</li>
                            <li>Valid example of undirected graph (e.g., Facebook friends, road networks) (1 mark)</li>
                        </ul>
                    </div>
                </div>
                
                <div class="interactive-area" style="margin-top: 2rem;">
                    <h4>Question 2 (6 marks)</h4>
                    <p>A social media company wants to implement a "friend suggestion" feature. Explain how graphs would be used to implement this feature, including:</p>
                    <ul style="padding-left: 1.5rem;">
                        <li>How users and friendships would be represented</li>
                        <li>An algorithm to find potential friends</li>
                        <li>Why graphs are suitable for this application</li>
                    </ul>
                    
                    <textarea class="input-field" id="exam-q2" rows="10" placeholder="Write your answer here..."></textarea>
                    
                    <div style="margin-top: 1rem;">
                        <label>Predicted marks: 
                            <input type="number" id="marks-q2" min="0" max="6" style="width: 50px;" class="input-field">
                        </label>
                        <button class="btn btn-secondary" onclick="showMarkScheme('q2')">Show Mark Scheme</button>
                    </div>
                    
                    <div class="mark-scheme" id="mark-scheme-q2">
                        <h5>Mark Scheme:</h5>
                        <ul style="padding-left: 1.5rem;">
                            <li>Users represented as nodes/vertices in the graph (1 mark)</li>
                            <li>Friendships represented as edges (undirected) (1 mark)</li>
                            <li>Algorithm: Find friends of friends (2-hop connections) (2 marks)</li>
                            <li>Could use BFS to explore connections at specific depths (1 mark)</li>
                            <li>Graphs suitable because they naturally model relationships/connections between entities (1 mark)</li>
                        </ul>
                    </div>
                </div>
                
                <div class="interactive-area" style="margin-top: 2rem;">
                    <h4>Question 3 (5 marks)</h4>
                    <p>Describe how graphs are used in artificial neural networks, specifically mentioning nodes, edges, and the flow of information.</p>
                    
                    <textarea class="input-field" id="exam-q3" rows="8" placeholder="Write your answer here..."></textarea>
                    
                    <div style="margin-top: 1rem;">
                        <label>Predicted marks: 
                            <input type="number" id="marks-q3" min="0" max="5" style="width: 50px;" class="input-field">
                        </label>
                        <button class="btn btn-secondary" onclick="showMarkScheme('q3')">Show Mark Scheme</button>
                    </div>
                    
                    <div class="mark-scheme" id="mark-scheme-q3">
                        <h5>Mark Scheme:</h5>
                        <ul style="padding-left: 1.5rem;">
                            <li>Nodes represent neurons/processing units (1 mark)</li>
                            <li>Edges represent weighted connections between neurons (1 mark)</li>
                            <li>Information flows from input layer through hidden layers to output (1 mark)</li>
                            <li>Graph is directed - information flows in one direction (1 mark)</li>
                            <li>Weights on edges determine strength of connections/influence (1 mark)</li>
                        </ul>
                    </div>
                </div>
                
                <h4 style="margin-top: 2rem;">Drawing Canvas for Rough Work</h4>
                <p>Use this canvas for drawing graphs or calculations:</p>
                <canvas id="drawing-canvas" class="drawing-canvas" width="600" height="300"></canvas>
                <button class="btn btn-secondary" onclick="clearCanvas()">Clear Canvas</button>
                
                <div class="btn-group">
                    <button class="btn btn-secondary" onclick="navigateSection('prev')">‚Üê Previous</button>
                    <button class="btn btn-primary" onclick="navigateSection('next')">Next ‚Üí</button>
                </div>
            </div>
        </section>

        <!-- Extension Activities -->
        <section id="extension" class="section">
            <div class="card">
                <h2 class="card-title">
                    <span>üåü</span> Extension Activities
                </h2>
                
                <h3>Beyond the Specification</h3>
                
                <div class="interactive-area">
                    <h4>Advanced Graph Algorithms</h4>
                    <p>Research and explain ONE of the following advanced graph concepts:</p>
                    <ul style="padding-left: 1.5rem; margin: 1rem 0;">
                        <li>Minimum Spanning Trees (Kruskal's or Prim's algorithm)</li>
                        <li>Topological Sorting in directed acyclic graphs</li>
                        <li>Graph coloring problems</li>
                        <li>Maximum flow algorithms (Ford-Fulkerson)</li>
                    </ul>
                    
                    <textarea class="input-field" rows="6" placeholder="Explain your chosen algorithm, its purpose, and a real-world application..."></textarea>
                </div>
                
                <div class="interactive-area" style="margin-top: 2rem;">
                    <h4>Graph Database Systems</h4>
                    <p>Modern graph databases like Neo4j are becoming increasingly popular. Research and explain:</p>
                    <ol style="padding-left: 1.5rem;">
                        <li>What is a graph database?</li>
                        <li>How does it differ from relational databases?</li>
                        <li>Give an example use case where a graph database would be superior</li>
                    </ol>
                    
                    <textarea class="input-field" rows="8" placeholder="Your research findings..."></textarea>
                </div>
                
                <div class="interactive-area" style="margin-top: 2rem;">
                    <h4>Implement a Graph Algorithm</h4>
                    <p>Write pseudocode for a breadth-first search algorithm that finds the shortest path between two nodes:</p>
                    
                    <textarea class="input-field" rows="10" placeholder="Write your pseudocode here..."></textarea>
                </div>
                
                <button class="btn btn-primary" onclick="submitExtension()">Submit Extension Work</button>
                
                <div class="btn-group">
                    <button class="btn btn-secondary" onclick="navigateSection('prev')">‚Üê Previous</button>
                    <button class="btn btn-primary" onclick="navigateSection('next')">Next ‚Üí</button>
                </div>
            </div>
        </section>

        <!-- Videos Section -->
        <section id="videos" class="section">
            <div class="card">
                <h2 class="card-title">
                    <span>üé•</span> Video Resources
                </h2>
                
                <div class="interactive-area">
                    <h4>Supplementary Videos</h4>
                    <p>Your teacher will add video links here to support your learning:</p>
                    
                    <div style="background: var(--bg-secondary); padding: 3rem; border-radius: 1rem; text-align: center; margin: 2rem 0;">
                        <p style="color: var(--text-secondary); font-size: 4rem;">üìπ</p>
                        <p style="color: var(--text-secondary);">Video content will be added here</p>
                    </div>
                </div>
                
                <h4>Additional Resources</h4>
                <ul style="margin: 1rem 0; padding-left: 1.5rem;">
                    <li>Cambridge 9618 Specification - Graphs</li>
                    <li>Graph Visualization Tools</li>
                    <li>Algorithm Animations</li>
                    <li>Past Paper Questions on Graphs</li>
                </ul>
                
                <div class="btn-group">
                    <button class="btn btn-secondary" onclick="navigateSection('prev')">‚Üê Previous</button>
                    <button class="btn btn-primary" onclick="navigateSection('intro')">Start Over</button>
                </div>
            </div>
        </section>
    </main>

    <!-- Achievement Popup -->
    <div class="achievement-popup" id="achievement-popup">
        <div class="achievement-icon" id="achievement-icon">üèÜ</div>
        <h4 id="achievement-title">Achievement Unlocked!</h4>
        <p id="achievement-desc">You've earned a new achievement</p>
    </div>

    <!-- Shame Message -->
    <div class="shame-message" id="shame-message">
        üö´ No pasting allowed! Do your own work! üö´
    </div>

    <!-- Particle Container -->
    <div id="particle-container"></div>

    <!-- Feedback Button & Modal -->
    <button class="feedback-btn" onclick="openFeedback()" aria-label="Send feedback">
        <span>üí¨</span>
    </button>

    <div class="feedback-modal" id="feedback-modal">
        <div class="feedback-content">
            <h3 style="margin-bottom: 1rem; color: var(--primary-color);">Send Feedback</h3>
            <p>Found a bug or have a suggestion? Let us know!</p>
            <p style="font-size: 0.875rem; color: var(--text-secondary); margin-top: 0.5rem;">
                Current page: <span id="feedback-page" style="font-weight: 600;"></span>
            </p>
            <textarea class="input-field" id="feedback-text" rows="5" placeholder="Describe the issue or suggestion..." style="margin-top: 1rem;"></textarea>
            <div class="btn-group">
                <button class="btn btn-secondary" onclick="closeFeedback()">Cancel</button>
                <button class="btn btn-primary" onclick="sendFeedback()">Send</button>
            </div>
        </div>
    </div>

    <!-- Accessibility Controls -->
    <div class="accessibility-controls">
        <h4>Accessibility</h4>
        <button onclick="toggleHighContrast()">High Contrast</button>
        <button onclick="toggleDyslexiaFont()">Dyslexia Font</button>
        <div class="font-size-controls">
            <button onclick="changeFontSize('small')">A-</button>
            <button onclick="changeFontSize('normal')">A</button>
            <button onclick="changeFontSize('large')">A+</button>
        </div>
    </div>

    <script>
        // Performance optimization: Cache DOM elements
        const DOM = {
            xpFill: null,
            xpText: null,
            currentLevel: null,
            navPills: null,
            sections: null,
            achievementPopup: null,
            shameMessage: null,
            feedbackModal: null,
            feedbackPage: null,
            feedbackText: null,
            particleContainer: null
        };

        // Initialize DOM cache
        function initializeDOM() {
            DOM.xpFill = document.getElementById('xp-fill');
            DOM.xpText = document.getElementById('xp-text');
            DOM.currentLevel = document.getElementById('current-level');
            DOM.navPills = document.querySelectorAll('.nav-pill');
            DOM.sections = document.querySelectorAll('.section');
            DOM.achievementPopup = document.getElementById('achievement-popup');
            DOM.shameMessage = document.getElementById('shame-message');
            DOM.feedbackModal = document.getElementById('feedback-modal');
            DOM.feedbackPage = document.getElementById('feedback-page');
            DOM.feedbackText = document.getElementById('feedback-text');
            DOM.particleContainer = document.getElementById('particle-container');
        }

        // Game State
        let gameState = {
            xp: 0,
            level: 1,
            completedSections: new Set(),
            achievements: new Set(),
            actionsPerformed: new Set(),
            currentSection: 'intro',
            sectionScores: {},
            selectedItems: {},
            hintUsage: {},
            graphData: {
                nodes: [],
                edges: [],
                selectedNode: null,
                graphType: 'undirected'
            }
        };

        // XP Requirements per level
        const XP_PER_LEVEL = [0, 100, 250, 450, 700, 1000];

        // Performance: Debounce function
        function debounce(func, wait) {
            let timeout;
            return function executedFunction(...args) {
                const later = () => {
                    clearTimeout(timeout);
                    func(...args);
                };
                clearTimeout(timeout);
                timeout = setTimeout(later, wait);
            };
        }

        // Performance: Throttle function
        function throttle(func, limit) {
            let inThrottle;
            return function(...args) {
                if (!inThrottle) {
                    func.apply(this, args);
                    inThrottle = true;
                    setTimeout(() => inThrottle = false, limit);
                }
            };
        }

        // Initialize
        document.addEventListener('DOMContentLoaded', function() {
            initializeDOM();
            setupEventListeners();
            loadProgress();
            updateXPDisplay();
            
            // Initialize graphs
            setTimeout(() => {
                initializeGraphCanvas('graph-canvas-1');
                initializeTypesGraph();
                initializeAdjacencyMatrix();
                initializeNeuralNetwork();
                initializeTraversalGraph();
                initializePracticeGraph();
            }, 200);
            
            // Initialize canvas
            setTimeout(() => {
                const canvas = document.getElementById('drawing-canvas');
                if (canvas) {
                    initializeCanvas();
                }
            }, 100);
        });

        // Graph Canvas Functions
        function initializeGraphCanvas(canvasId) {
            const canvas = document.getElementById(canvasId);
            if (!canvas) return;
            
            canvas.addEventListener('click', function(e) {
                const rect = canvas.getBoundingClientRect();
                const x = e.clientX - rect.left;
                const y = e.clientY - rect.top;
                
                // Check if clicking on existing node
                const clickedNode = getNodeAtPosition(canvasId, x, y);
                
                if (clickedNode) {
                    handleNodeClick(canvasId, clickedNode);
                } else {
                    addNode(canvasId, x, y);
                }
            });
        }

        function addNode(canvasId, x, y) {
            const canvas = document.getElementById(canvasId);
            const nodeId = `node-${Date.now()}`;
            const node = document.createElement('div');
            node.className = 'graph-node';
            node.id = nodeId;
            node.style.left = (x - 20) + 'px';
            node.style.top = (y - 20) + 'px';
            node.textContent = String.fromCharCode(65 + canvas.querySelectorAll('.graph-node').length);
            
            canvas.appendChild(node);
            updateNodeCount(canvasId);
            awardXP(2, 'Add Node', `add_node_${canvasId}`);
        }

        function handleNodeClick(canvasId, node) {
            if (gameState.graphData.selectedNode) {
                if (gameState.graphData.selectedNode !== node) {
                    addEdge(canvasId, gameState.graphData.selectedNode, node);
                }
                document.querySelectorAll('.graph-node').forEach(n => n.classList.remove('selected'));
                gameState.graphData.selectedNode = null;
            } else {
                node.classList.add('selected');
                gameState.graphData.selectedNode = node;
            }
        }

        function addEdge(canvasId, node1, node2) {
            const canvas = document.getElementById(canvasId);
            const edge = document.createElement('div');
            edge.className = 'graph-edge';
            if (gameState.graphData.graphType === 'directed') {
                edge.classList.add('directed');
            }
            
            const rect1 = node1.getBoundingClientRect();
            const rect2 = node2.getBoundingClientRect();
            const canvasRect = canvas.getBoundingClientRect();
            
            const x1 = rect1.left - canvasRect.left + rect1.width / 2;
            const y1 = rect1.top - canvasRect.top + rect1.height / 2;
            const x2 = rect2.left - canvasRect.left + rect2.width / 2;
            const y2 = rect2.top - canvasRect.top + rect2.height / 2;
            
            const length = Math.sqrt(Math.pow(x2 - x1, 2) + Math.pow(y2 - y1, 2));
            const angle = Math.atan2(y2 - y1, x2 - x1) * 180 / Math.PI;
            
            edge.style.width = length + 'px';
            edge.style.left = x1 + 'px';
            edge.style.top = y1 + 'px';
            edge.style.transform = `rotate(${angle}deg)`;
            
            canvas.appendChild(edge);
            updateEdgeCount(canvasId);
            awardXP(3, 'Add Edge', `add_edge_${canvasId}`);
        }

        function getNodeAtPosition(canvasId, x, y) {
            const canvas = document.getElementById(canvasId);
            const nodes = canvas.querySelectorAll('.graph-node');
            
            for (let node of nodes) {
                const rect = node.getBoundingClientRect();
                const canvasRect = canvas.getBoundingClientRect();
                const nodeX = rect.left - canvasRect.left;
                const nodeY = rect.top - canvasRect.top;
                
                if (x >= nodeX && x <= nodeX + rect.width &&
                    y >= nodeY && y <= nodeY + rect.height) {
                    return node;
                }
            }
            return null;
        }

        function clearGraph(canvasId) {
            const canvas = document.getElementById(canvasId);
            if (!canvas) return;
            
            canvas.innerHTML = '';
            updateNodeCount(canvasId);
            updateEdgeCount(canvasId);
            gameState.graphData.selectedNode = null;
        }

        function updateNodeCount(canvasId) {
            const count = document.getElementById(`node-count-${canvasId.split('-').pop()}`);
            if (count) {
                const canvas = document.getElementById(canvasId);
                count.textContent = canvas.querySelectorAll('.graph-node').length;
            }
        }

        function updateEdgeCount(canvasId) {
            const count = document.getElementById(`edge-count-${canvasId.split('-').pop()}`);
            if (count) {
                const canvas = document.getElementById(canvasId);
                count.textContent = canvas.querySelectorAll('.graph-edge').length;
            }
        }

        // Types of Graphs Section
        function initializeTypesGraph() {
            const canvas = document.getElementById('graph-canvas-2');
            if (!canvas) return;
            
            // Create example graph
            const positions = [
                {x: 150, y: 100, label: 'A'},
                {x: 250, y: 100, label: 'B'},
                {x: 200, y: 200, label: 'C'}
            ];
            
            positions.forEach(pos => {
                const node = document.createElement('div');
                node.className = 'graph-node';
                node.style.left = (pos.x - 20) + 'px';
                node.style.top = (pos.y - 20) + 'px';
                node.textContent = pos.label;
                canvas.appendChild(node);
            });
            
            // Add edges
            updateGraphTypeDisplay();
        }

        function setGraphType(type) {
            gameState.graphData.graphType = type;
            
            // Update toggle buttons
            document.querySelectorAll('.toggle-btn').forEach(btn => {
                btn.classList.remove('active');
            });
            event.target.classList.add('active');
            
            updateGraphTypeDisplay();
            
            // Update explanation
            const explanation = document.getElementById('graph-explanation');
            if (explanation) {
                if (type === 'directed') {
                    explanation.innerHTML = '<p><strong>Directed Graph:</strong> Edges have a specific direction. A‚ÜíB does not imply B‚ÜíA.</p>';
                } else {
                    explanation.innerHTML = '<p><strong>Undirected Graph:</strong> Edges have no direction. If A connects to B, then B also connects to A.</p>';
                }
            }
            
            awardXP(5, 'Explore Graph Types', `graph_type_${type}`);
        }

        function updateGraphTypeDisplay() {
            const canvas = document.getElementById('graph-canvas-2');
            if (!canvas) return;
            
            // Clear existing edges
            canvas.querySelectorAll('.graph-edge').forEach(edge => edge.remove());
            
            const nodes = canvas.querySelectorAll('.graph-node');
            if (nodes.length >= 3) {
                // Add edges based on type
                addEdgeByIndex(canvas, nodes[0], nodes[1]);
                addEdgeByIndex(canvas, nodes[1], nodes[2]);
                addEdgeByIndex(canvas, nodes[2], nodes[0]);
            }
        }

        function addEdgeByIndex(canvas, node1, node2) {
            const edge = document.createElement('div');
            edge.className = 'graph-edge';
            if (gameState.graphData.graphType === 'directed') {
                edge.classList.add('directed');
            }
            
            const rect1 = node1.getBoundingClientRect();
            const rect2 = node2.getBoundingClientRect();
            const canvasRect = canvas.getBoundingClientRect();
            
            const x1 = parseInt(node1.style.left) + 20;
            const y1 = parseInt(node1.style.top) + 20;
            const x2 = parseInt(node2.style.left) + 20;
            const y2 = parseInt(node2.style.top) + 20;
            
            const length = Math.sqrt(Math.pow(x2 - x1, 2) + Math.pow(y2 - y1, 2));
            const angle = Math.atan2(y2 - y1, x2 - x1) * 180 / Math.PI;
            
            edge.style.width = length + 'px';
            edge.style.left = x1 + 'px';
            edge.style.top = y1 + 'px';
            edge.style.transform = `rotate(${angle}deg)`;
            
            canvas.appendChild(edge);
        }

        // Adjacency Matrix
        function initializeAdjacencyMatrix() {
            const matrix = document.getElementById('adjacency-matrix');
            if (!matrix) return;
            
            const size = 4;
            const labels = ['A', 'B', 'C', 'D'];
            
            // Create header row
            const headerCell = document.createElement('div');
            headerCell.className = 'matrix-cell header';
            headerCell.textContent = '';
            matrix.appendChild(headerCell);
            
            for (let label of labels) {
                const cell = document.createElement('div');
                cell.className = 'matrix-cell header';
                cell.textContent = label;
                matrix.appendChild(cell);
            }
            
            // Create matrix rows
            for (let i = 0; i < size; i++) {
                const rowHeader = document.createElement('div');
                rowHeader.className = 'matrix-cell header';
                rowHeader.textContent = labels[i];
                matrix.appendChild(rowHeader);
                
                for (let j = 0; j < size; j++) {
                    const cell = document.createElement('div');
                    cell.className = 'matrix-cell';
                    cell.textContent = '0';
                    cell.dataset.row = i;
                    cell.dataset.col = j;
                    cell.addEventListener('click', toggleMatrixCell);
                    matrix.appendChild(cell);
                }
            }
            
            updateMatrixGraph();
        }

        function toggleMatrixCell(e) {
            const cell = e.target;
            const value = cell.textContent === '0' ? '1' : '0';
            cell.textContent = value;
            
            // For undirected graph, update symmetric cell
            const row = parseInt(cell.dataset.row);
            const col = parseInt(cell.dataset.col);
            if (row !== col) {
                const symmetricCell = document.querySelector(`[data-row="${col}"][data-col="${row}"]`);
                if (symmetricCell) symmetricCell.textContent = value;
            }
            
            updateMatrixGraph();
            awardXP(2, 'Matrix Edit', 'matrix_edit');
        }

        function updateMatrixGraph() {
            const canvas = document.getElementById('matrix-graph');
            if (!canvas) return;
            
            canvas.innerHTML = '';
            
            // Add nodes in a circle
            const labels = ['A', 'B', 'C', 'D'];
            const centerX = 125;
            const centerY = 125;
            const radius = 80;
            
            const nodes = [];
            labels.forEach((label, i) => {
                const angle = (i * 2 * Math.PI) / labels.length - Math.PI / 2;
                const x = centerX + radius * Math.cos(angle);
                const y = centerY + radius * Math.sin(angle);
                
                const node = document.createElement('div');
                node.className = 'graph-node';
                node.style.left = (x - 20) + 'px';
                node.style.top = (y - 20) + 'px';
                node.textContent = label;
                canvas.appendChild(node);
                nodes.push(node);
            });
            
            // Add edges based on matrix
            const cells = document.querySelectorAll('#adjacency-matrix .matrix-cell:not(.header)');
            cells.forEach(cell => {
                if (cell.textContent === '1') {
                    const row = parseInt(cell.dataset.row);
                    const col = parseInt(cell.dataset.col);
                    if (row < col) { // Avoid duplicate edges
                        addEdgeByIndex(canvas, nodes[row], nodes[col]);
                    }
                }
            });
        }

        // Neural Network Visualization
        function initializeNeuralNetwork() {
            const canvas = document.getElementById('neural-network');
            if (!canvas) return;
            
            // Create layers
            const layers = [
                {x: 50, neurons: 3, label: 'Input'},
                {x: 200, neurons: 4, label: 'Hidden'},
                {x: 350, neurons: 2, label: 'Output'}
            ];
            
            const allNodes = [];
            
            layers.forEach((layer, layerIndex) => {
                const layerNodes = [];
                const startY = (350 - layer.neurons * 60) / 2;
                
                for (let i = 0; i < layer.neurons; i++) {
                    const node = document.createElement('div');
                    node.className = 'graph-node';
                    node.style.left = (layer.x - 20) + 'px';
                    node.style.top = (startY + i * 60) + 'px';
                    node.textContent = layerIndex === 0 ? 'I' : (layerIndex === 1 ? 'H' : 'O');
                    node.dataset.layer = layerIndex;
                    canvas.appendChild(node);
                    layerNodes.push(node);
                }
                allNodes.push(layerNodes);
            });
            
            // Connect layers
            for (let i = 0; i < allNodes.length - 1; i++) {
                for (let j = 0; j < allNodes[i].length; j++) {
                    for (let k = 0; k < allNodes[i + 1].length; k++) {
                        const edge = createNeuralEdge(allNodes[i][j], allNodes[i + 1][k]);
                        canvas.appendChild(edge);
                    }
                }
            }
        }

        function createNeuralEdge(node1, node2) {
            const edge = document.createElement('div');
            edge.className = 'graph-edge';
            edge.style.opacity = '0.3';
            
            const x1 = parseInt(node1.style.left) + 20;
            const y1 = parseInt(node1.style.top) + 20;
            const x2 = parseInt(node2.style.left) + 20;
            const y2 = parseInt(node2.style.top) + 20;
            
            const length = Math.sqrt(Math.pow(x2 - x1, 2) + Math.pow(y2 - y1, 2));
            const angle = Math.atan2(y2 - y1, x2 - x1) * 180 / Math.PI;
            
            edge.style.width = length + 'px';
            edge.style.left = x1 + 'px';
            edge.style.top = y1 + 'px';
            edge.style.transform = `rotate(${angle}deg)`;
            
            return edge;
        }

        function animateNeuralNetwork() {
            const canvas = document.getElementById('neural-network');
            if (!canvas) return;
            
            const edges = canvas.querySelectorAll('.graph-edge');
            edges.forEach((edge, index) => {
                setTimeout(() => {
                    edge.style.opacity = '1';
                    edge.style.background = '#10b981';
                    setTimeout(() => {
                        edge.style.opacity = '0.3';
                        edge.style.background = 'var(--primary-color)';
                    }, 500);
                }, index * 50);
            });
            
            awardXP(10, 'Neural Network Animation', 'nn_animate');
        }

        function resetNeuralNetwork() {
            const canvas = document.getElementById('neural-network');
            if (!canvas) return;
            
            canvas.querySelectorAll('.graph-edge').forEach(edge => {
                edge.style.opacity = '0.3';
                edge.style.background = 'var(--primary-color)';
            });
        }

        // Graph Traversal
        function initializeTraversalGraph() {
            const canvas = document.getElementById('traversal-graph');
            if (!canvas) return;
            
            // Create a sample graph for traversal
            const positions = [
                {x: 150, y: 50, label: 'A'},
                {x: 100, y: 150, label: 'B'},
                {x: 200, y: 150, label: 'C'},
                {x: 50, y: 250, label: 'D'},
                {x: 150, y: 250, label: 'E'},
                {x: 250, y: 250, label: 'F'}
            ];
            
            positions.forEach(pos => {
                const node = document.createElement('div');
                node.className = 'graph-node';
                node.style.left = (pos.x - 20) + 'px';
                node.style.top = (pos.y - 20) + 'px';
                node.textContent = pos.label;
                node.id = `traverse-${pos.label}`;
                canvas.appendChild(node);
            });
            
            // Add edges
            const connections = [
                ['A', 'B'], ['A', 'C'],
                ['B', 'D'], ['B', 'E'],
                ['C', 'E'], ['C', 'F']
            ];
            
            connections.forEach(([from, to]) => {
                const node1 = document.getElementById(`traverse-${from}`);
                const node2 = document.getElementById(`traverse-${to}`);
                if (node1 && node2) {
                    addEdgeByIndex(canvas, node1, node2);
                }
            });
        }

        async function startDFS() {
            const visited = [];
            const stack = ['A'];
            
            while (stack.length > 0) {
                const current = stack.pop();
                if (!visited.includes(current)) {
                    visited.push(current);
                    highlightNode(`traverse-${current}`);
                    updateVisited(visited);
                    
                    // Add neighbors to stack (in reverse order for proper DFS)
                    const neighbors = getNeighbors(current).reverse();
                    neighbors.forEach(n => {
                        if (!visited.includes(n)) stack.push(n);
                    });
                    
                    await sleep(800);
                }
            }
            
            awardXP(15, 'DFS Complete', 'dfs_complete');
        }

        async function startBFS() {
            const visited = [];
            const queue = ['A'];
            
            while (queue.length > 0) {
                const current = queue.shift();
                if (!visited.includes(current)) {
                    visited.push(current);
                    highlightNode(`traverse-${current}`);
                    updateVisited(visited);
                    
                    // Add neighbors to queue
                    const neighbors = getNeighbors(current);
                    neighbors.forEach(n => {
                        if (!visited.includes(n) && !queue.includes(n)) queue.push(n);
                    });
                    
                    await sleep(800);
                }
            }
            
            awardXP(15, 'BFS Complete', 'bfs_complete');
        }

        function getNeighbors(node) {
            const adjacency = {
                'A': ['B', 'C'],
                'B': ['A', 'D', 'E'],
                'C': ['A', 'E', 'F'],
                'D': ['B'],
                'E': ['B', 'C'],
                'F': ['C']
            };
            return adjacency[node] || [];
        }

        function highlightNode(nodeId) {
            const node = document.getElementById(nodeId);
            if (node) {
                node.style.background = 'var(--success-color)';
                node.style.color = 'white';
            }
        }

        function updateVisited(visited) {
            const display = document.getElementById('visited-nodes');
            if (display) {
                display.textContent = '[' + visited.join(', ') + ']';
            }
        }

        function resetTraversal() {
            const canvas = document.getElementById('traversal-graph');
            if (!canvas) return;
            
            canvas.querySelectorAll('.graph-node').forEach(node => {
                node.style.background = '';
                node.style.color = '';
            });
            
            updateVisited([]);
        }

        function sleep(ms) {
            return new Promise(resolve => setTimeout(resolve, ms));
        }

        // Practice Graph
        function initializePracticeGraph() {
            initializeGraphCanvas('practice-graph');
        }

        function addPerson() {
            const input = document.getElementById('person-name');
            if (!input || !input.value.trim()) return;
            
            const name = input.value.trim();
            const canvas = document.getElementById('practice-graph');
            if (!canvas) return;
            
            // Random position
            const x = 50 + Math.random() * (canvas.offsetWidth - 100);
            const y = 50 + Math.random() * (canvas.offsetHeight - 100);
            
            const node = document.createElement('div');
            node.className = 'graph-node';
            node.style.left = (x - 20) + 'px';
            node.style.top = (y - 20) + 'px';
            node.textContent = name.charAt(0).toUpperCase();
            node.title = name;
            node.dataset.name = name;
            
            node.addEventListener('click', function() {
                handleNodeClick('practice-graph', this);
            });
            
            canvas.appendChild(node);
            input.value = '';
            
            awardXP(5, 'Add Person', 'add_person');
        }

        function clearPracticeGraph() {
            clearGraph('practice-graph');
        }

        function checkPracticeGraph() {
            const canvas = document.getElementById('practice-graph');
            if (!canvas) return;
            
            const nodes = canvas.querySelectorAll('.graph-node').length;
            const edges = canvas.querySelectorAll('.graph-edge').length;
            
            if (nodes >= 5 && edges >= 6) {
                awardXP(30, 'Social Network Complete', 'practice_complete');
                markSectionComplete('practice');
                alert('Excellent work! Your social network graph is complete.');
            } else {
                alert(`You need at least 5 people and 6 friendships. Currently: ${nodes} people, ${edges} friendships.`);
            }
        }

        function submitAnalysis() {
            const analyses = ['analysis1', 'analysis2', 'analysis3'];
            let totalWords = 0;
            
            analyses.forEach(id => {
                const textarea = document.getElementById(id);
                if (textarea) {
                    totalWords += textarea.value.split(' ').filter(word => word.length > 0).length;
                }
            });
            
            if (totalWords > 30) {
                awardXP(20, 'Graph Analysis', 'analysis_complete');
                alert('Great analysis! You\'ve shown good understanding of graph properties.');
            } else {
                alert('Please provide more detailed analysis for each question.');
            }
        }

        // Starter Activity
        function resetStarterActivity() {
            const container = document.getElementById('starter-matching');
            if (!container) return;
            
            container.querySelectorAll('.match-item').forEach(item => {
                item.classList.remove('selected', 'matched');
            });
            
            gameState.selectedItems = {};
        }

        // Matching functionality
        document.addEventListener('click', function(e) {
            if (e.target.classList.contains('match-item')) {
                handleMatchClick(e.target);
            }
        });

        function handleMatchClick(item) {
            const container = item.closest('.matching-container');
            if (!container) return;
            
            if (item.classList.contains('matched')) return;
            
            const isLeft = item.hasAttribute('data-id');
            const key = isLeft ? 'left' : 'right';
            
            // Clear previous selection on same side
            container.querySelectorAll('.match-item').forEach(el => {
                if ((el.hasAttribute('data-id') === isLeft) && el !== item) {
                    el.classList.remove('selected');
                }
            });
            
            item.classList.toggle('selected');
            
            if (item.classList.contains('selected')) {
                gameState.selectedItems[key] = item;
            } else {
                delete gameState.selectedItems[key];
            }
            
            // Check for match
            if (gameState.selectedItems.left && gameState.selectedItems.right) {
                const leftId = gameState.selectedItems.left.dataset.id;
                const rightMatch = gameState.selectedItems.right.dataset.match;
                
                if (leftId === rightMatch) {
                    gameState.selectedItems.left.classList.add('matched');
                    gameState.selectedItems.right.classList.add('matched');
                    gameState.selectedItems.left.classList.remove('selected');
                    gameState.selectedItems.right.classList.remove('selected');
                    awardXP(5, 'Correct Match', `match_${leftId}`);
                    
                    // Check if all matched
                    const allMatched = container.querySelectorAll('.match-item[data-id]').length === 
                                      container.querySelectorAll('.match-item.matched[data-id]').length;
                    if (allMatched) {
                        awardXP(20, 'All Matches Complete', 'starter_complete');
                        markSectionComplete('starter');
                    }
                } else {
                    // Wrong match
                    setTimeout(() => {
                        gameState.selectedItems.left.classList.remove('selected');
                        gameState.selectedItems.right.classList.remove('selected');
                    }, 500);
                }
                
                gameState.selectedItems = {};
            }
        }

        // Pre-quiz
        function checkPreQuiz() {
            const selected = document.querySelector('#pre-quiz .quiz-option.selected');
            if (!selected) return;
            
            const correct = selected.dataset.answer === 'b';
            if (correct) {
                selected.classList.add('correct');
                awardXP(10, 'Pre-Quiz Correct', 'pre_quiz');
            } else {
                selected.classList.add('incorrect');
                document.querySelector('#pre-quiz .quiz-option[data-answer="b"]').classList.add('correct');
            }
        }

        // Fundamentals
        function checkFundamentals() {
            const answers = {
                'blank1': 'nodes',
                'blank2': 'edges',
                'blank3': 'non-linear'
            };
            
            let correct = 0;
            Object.keys(answers).forEach(id => {
                const select = document.getElementById(id);
                if (!select) return;
                
                if (select.value === answers[id]) {
                    select.style.borderColor = 'var(--success-color)';
                    correct++;
                } else {
                    select.style.borderColor = 'var(--error-color)';
                }
            });
            
            if (correct === 3) {
                awardXP(15, 'Fundamentals Complete', 'fundamentals_complete');
                markSectionComplete('fundamentals');
            }
        }

        // Types Section
        function checkGraphTypes() {
            const answers = {
                '1': 'undirected',
                '2': 'directed',
                '3': 'undirected'
            };
            
            let correct = 0;
            Object.keys(answers).forEach(q => {
                const selected = document.querySelector(`.quiz-option[data-q="${q}"].selected`);
                if (selected && selected.dataset.a === answers[q]) {
                    selected.classList.add('correct');
                    correct++;
                } else {
                    if (selected) selected.classList.add('incorrect');
                    document.querySelector(`.quiz-option[data-q="${q}"][data-a="${answers[q]}"]`)?.classList.add('correct');
                }
            });
            
            if (correct === 3) {
                awardXP(20, 'Graph Types Mastered', 'types_complete');
                markSectionComplete('types');
            }
        }

        function resetTypesSection() {
            document.querySelectorAll('#types .quiz-option').forEach(opt => {
                opt.classList.remove('selected', 'correct', 'incorrect');
            });
        }

        // Representations
        function checkRepresentation(answer) {
            const correct = answer === 'list';
            const btn = event.target;
            
            if (correct) {
                btn.classList.add('correct');
                awardXP(10, 'Representation Knowledge', 'rep_sparse');
            } else {
                btn.classList.add('incorrect');
            }
        }

        function checkComplexity(answer) {
            const correct = answer === 'n2';
            const btn = event.target;
            
            if (correct) {
                btn.classList.add('correct');
                awardXP(10, 'Complexity Understanding', 'complexity_matrix');
                markSectionComplete('representations');
            } else {
                btn.classList.add('incorrect');
            }
        }

        function resetRepresentations() {
            const matrix = document.getElementById('adjacency-matrix');
            if (matrix) {
                matrix.querySelectorAll('.matrix-cell:not(.header)').forEach(cell => {
                    cell.textContent = '0';
                });
            }
            updateMatrixGraph();
        }

        // Applications
        function showApplication(type) {
            const details = document.getElementById('application-details');
            if (!details) return;
            
            const applications = {
                'bus': {
                    title: 'üöå Bus Routes',
                    desc: 'Nodes represent bus stops, edges connect consecutive stops. The graph helps find routes between any two stops.',
                    graphType: 'Usually undirected (buses go both ways) or directed for one-way streets'
                },
                'web': {
                    title: 'üåê Websites',
                    desc: 'Nodes are web pages, edges are hyperlinks. Search engines use graphs to rank pages and find content.',
                    graphType: 'Directed graph (links have specific directions)'
                },
                'social': {
                    title: 'üë• Social Networks',
                    desc: 'Nodes represent people, edges show relationships. Used for friend suggestions and content distribution.',
                    graphType: 'Can be directed (Twitter) or undirected (Facebook friends)'
                },
                'gps': {
                    title: 'üìç GPS Navigation',
                    desc: 'Nodes are locations, edges are roads with weights (distance/time). Finds shortest paths between locations.',
                    graphType: 'Weighted graph, can be directed for one-way roads'
                }
            };
            
            const app = applications[type];
            if (app) {
                details.innerHTML = `
                    <h5>${app.title}</h5>
                    <p>${app.desc}</p>
                    <p><strong>Graph Type:</strong> ${app.graphType}</p>
                `;
                details.style.display = 'block';
                awardXP(3, 'Explore Application', `app_${type}`);
            }
        }

        function checkApplications() {
            const answers = {
                'app1': 'shortest',
                'app2': 'cycle',
                'app3': 'traversal'
            };
            
            let correct = 0;
            Object.keys(answers).forEach(id => {
                const select = document.getElementById(id);
                if (!select) return;
                
                if (select.value === answers[id]) {
                    select.style.borderColor = 'var(--success-color)';
                    correct++;
                } else {
                    select.style.borderColor = 'var(--error-color)';
                }
            });
            
            if (correct === 3) {
                awardXP(20, 'Applications Understood', 'applications_complete');
                markSectionComplete('applications');
            }
        }

        function resetApplications() {
            ['app1', 'app2', 'app3'].forEach(id => {
                const select = document.getElementById(id);
                if (select) {
                    select.value = '';
                    select.style.borderColor = '';
                }
            });
            
            const details = document.getElementById('application-details');
            if (details) details.style.display = 'none';
        }

        // AI Section
        function checkAIQuestions() {
            const answers = {
                'ai1': 'path',
                'ai2': 'backward'
            };
            
            let correct = 0;
            Object.keys(answers).forEach(q => {
                const selected = document.querySelector(`.quiz-option[data-q="${q}"].selected`);
                if (selected && selected.dataset.a === answers[q]) {
                    selected.classList.add('correct');
                    correct++;
                } else {
                    if (selected) selected.classList.add('incorrect');
                    document.querySelector(`.quiz-option[data-q="${q}"][data-a="${answers[q]}"]`)?.classList.add('correct');
                }
            });
            
            if (correct === 2) {
                awardXP(20, 'AI Concepts', 'ai_complete');
                markSectionComplete('ai');
            }
        }

        // Algorithms
        function checkAlgorithm(answer) {
            const correct = answer === 'dijkstra';
            const btn = event.target;
            
            if (correct) {
                btn.classList.add('correct');
                awardXP(10, 'Algorithm Knowledge', 'algo_shortest');
            } else {
                btn.classList.add('incorrect');
            }
        }

        function checkTrueFalse(answer, question) {
            const correct = answer === 'true';
            const btn = event.target;
            
            if (correct) {
                btn.classList.add('correct');
                awardXP(10, 'A* Understanding', 'astar_true');
                markSectionComplete('algorithms');
            } else {
                btn.classList.add('incorrect');
            }
        }

        // Final Quiz
        function submitFinalQuiz() {
            const answers = {
                '1': 'b', '2': 'c', '3': 'b', '4': 'd',
                '5': 'c', '6': 'c', '7': 'a', '8': 'b'
            };
            
            let score = 0;
            const feedback = [];
            
            Object.keys(answers).forEach(q => {
                const selected = document.querySelector(`.quiz-option[data-q="${q}"].selected`);
                if (selected && selected.dataset.a === answers[q]) {
                    selected.classList.add('correct');
                    score++;
                } else {
                    if (selected) selected.classList.add('incorrect');
                    const correctOption = document.querySelector(`.quiz-option[data-q="${q}"][data-a="${answers[q]}"]`);
                    if (correctOption) correctOption.classList.add('correct');
                    
                    // Add feedback
                    const topics = {
                        '1': 'Graphs consist of nodes and edges',
                        '2': 'Directed graphs have edges with specific directions',
                        '3': 'Adjacency matrix uses O(n¬≤) space',
                        '4': 'Dijkstra\'s algorithm finds shortest paths',
                        '5': 'Neural networks are directed graphs with weights',
                        '6': 'Sorting is not a graph application',
                        '7': 'Undirected graphs have bidirectional edges',
                        '8': 'Backpropagation propagates errors backward'
                    };
                    feedback.push(`Q${q}: ${topics[q]}`);
                }
            });
            
            gameState.sectionScores.finalQuiz = score;
            
            const scoreEl = document.getElementById('quiz-score');
            const feedbackEl = document.getElementById('quiz-feedback');
            const resultsEl = document.getElementById('quiz-results');
            
            if (scoreEl) scoreEl.textContent = `You scored ${score}/8 (${Math.round(score/8*100)}%)`;
            
            if (feedbackEl) {
                if (feedback.length > 0) {
                    feedbackEl.innerHTML = 
                        '<h5>Review these topics:</h5><ul>' + 
                        feedback.map(f => `<li>${f}</li>`).join('') + 
                        '</ul>';
                } else {
                    feedbackEl.innerHTML = '<p style="color: var(--success-color);">Perfect score! Excellent work!</p>';
                }
            }
            
            if (resultsEl) resultsEl.style.display = 'block';
            
            awardXP(score * 10, 'Final Quiz', 'final_quiz_complete');
            markSectionComplete('summary');
            
            if (score === 8) {
                checkAchievements();
            }
        }

        // Exam Practice
        function showMarkScheme(question) {
            const textarea = document.getElementById(`exam-${question}`);
            const marks = document.getElementById(`marks-${question}`);
            const scheme = document.getElementById(`mark-scheme-${question}`);
            
            if (!textarea || !marks || !scheme) return;
            
            const minLength = question === 'q1' ? 50 : 100;
            
            if (textarea.value.length < minLength || !marks.value) {
                alert(`Please write a more detailed answer (minimum ${minLength} characters) and enter predicted marks`);
                return;
            }
            
            scheme.classList.add('show');
            awardXP(10, 'Exam Practice', `exam_${question}`);
        }

        // Extension
        function submitExtension() {
            const textareas = document.querySelectorAll('#extension .input-field');
            let totalWords = 0;
            
            textareas.forEach(ta => {
                totalWords += ta.value.split(' ').filter(word => word.length > 0).length;
            });
            
            if (totalWords > 50) {
                awardXP(30, 'Extension Work', 'extension_complete');
                markSectionComplete('extension');
                alert('Excellent extension work! Your teacher will review your responses.');
            } else {
                alert('Please provide more detailed responses for the extension activities.');
            }
        }

        // Event Listeners Setup
        function setupEventListeners() {
            // Navigation with event delegation
            const navContainer = document.querySelector('.nav-pills');
            if (navContainer) {
                navContainer.addEventListener('click', function(e) {
                    if (e.target.classList.contains('nav-pill')) {
                        navigateToSection(e.target.dataset.section);
                    }
                });
            }

            // Quiz options with event delegation
            document.addEventListener('click', function(e) {
                if (e.target.classList.contains('quiz-option')) {
                    const question = e.target.dataset.q;
                    if (question) {
                        // Multi-answer quiz
                        const siblings = document.querySelectorAll(`.quiz-option[data-q="${question}"]`);
                        siblings.forEach(s => s.classList.remove('selected'));
                        e.target.classList.add('selected');
                    } else {
                        // Single answer
                        selectQuizOption(e.target);
                    }
                }
            });

            // Prevent paste
            document.addEventListener('paste', function(e) {
                if (e.target.tagName === 'INPUT' || e.target.tagName === 'TEXTAREA') {
                    e.preventDefault();
                    e.stopPropagation();
                    showShameMessage();
                    return false;
                }
            });

            // Keyboard navigation
            document.addEventListener('keydown', throttle(function(e) {
                if (e.key === 'ArrowLeft') navigateSection('prev');
                if (e.key === 'ArrowRight') navigateSection('next');
                if (e.ctrlKey && e.key === 'v') {
                    e.preventDefault();
                    showShameMessage();
                }
            }, 100));

            // Touch support
            let touchStartX = 0;
            let touchStartY = 0;
            
            document.addEventListener('touchstart', function(e) {
                touchStartX = e.touches[0].clientX;
                touchStartY = e.touches[0].clientY;
            }, { passive: true });

            document.addEventListener('touchend', function(e) {
                const touchEndX = e.changedTouches[0].clientX;
                const touchEndY = e.changedTouches[0].clientY;
                const diffX = touchStartX - touchEndX;
                const diffY = Math.abs(touchStartY - touchEndY);
                
                if (Math.abs(diffX) > 50 && diffY < 100) {
                    if (diffX > 0) navigateSection('next');
                    else navigateSection('prev');
                }
            }, { passive: true });

            // Scroll optimization
            window.addEventListener('scroll', debounce(function() {
                if (!DOM.sections) return;
                
                const scrollY = window.scrollY;
                const windowHeight = window.innerHeight;
                
                DOM.sections.forEach(section => {
                    if (section && section.classList.contains('active')) {
                        const rect = section.getBoundingClientRect();
                        section.style.visibility = 
                            (rect.bottom > 0 && rect.top < windowHeight) ? 'visible' : 'hidden';
                    }
                });
            }, 100));
        }

        // Navigation
        function navigateToSection(sectionId) {
            if (!DOM.sections || !DOM.navPills) return;
            
            DOM.sections.forEach(s => {
                if (s) {
                    s.classList.remove('active');
                    s.style.visibility = 'hidden';
                }
            });
            DOM.navPills.forEach(p => {
                if (p) p.classList.remove('active');
            });
            
            const targetSection = document.getElementById(sectionId);
            const targetPill = document.querySelector(`[data-section="${sectionId}"]`);
            
            if (targetSection) {
                targetSection.classList.add('active');
                targetSection.style.visibility = 'visible';
            }
            if (targetPill) {
                targetPill.classList.add('active');
            }
            
            gameState.currentSection = sectionId;
            updateFeedbackPage();
            
            if (!gameState.completedSections.has(sectionId)) {
                awardXP(5, 'Section Visit', `section_${sectionId}`);
            }
            
            window.scrollTo({ top: 0, behavior: 'smooth' });
        }

        function navigateSection(direction) {
            if (!DOM.navPills) return;
            
            const sections = Array.from(DOM.navPills).filter(p => p).map(p => p.dataset.section);
            const currentIndex = sections.indexOf(gameState.currentSection);
            
            if (direction === 'next' && currentIndex < sections.length - 1) {
                navigateToSection(sections[currentIndex + 1]);
            } else if (direction === 'prev' && currentIndex > 0) {
                navigateToSection(sections[currentIndex - 1]);
            }
        }

        // XP System
        function awardXP(amount, action, actionId = null) {
            if (actionId && gameState.actionsPerformed.has(actionId)) return;
            if (actionId) gameState.actionsPerformed.add(actionId);
            
            gameState.xp += amount;
            updateXPDisplay();
            checkLevelUp();
            checkAchievements();
            saveProgress();
            
            createFloatingXP(amount);
        }

        function createFloatingXP(amount) {
            try {
                const xpFloat = document.createElement('div');
                xpFloat.style.cssText = `
                    position: fixed;
                    top: 120px;
                    right: 100px;
                    color: var(--warning-color);
                    font-weight: bold;
                    font-size: 1.5rem;
                    pointer-events: none;
                    z-index: 3000;
                    animation: floatUp 2s ease-out forwards;
                `;
                xpFloat.textContent = `+${amount} XP`;
                document.body.appendChild(xpFloat);
                
                setTimeout(() => {
                    if (xpFloat && xpFloat.parentNode) {
                        xpFloat.remove();
                    }
                }, 2000);
            } catch (e) {
                console.warn('Could not create floating XP indicator:', e);
            }
        }

        function updateXPDisplay() {
            if (!DOM.xpFill || !DOM.xpText || !DOM.currentLevel) return;
            
            const xpForNextLevel = XP_PER_LEVEL[gameState.level] || XP_PER_LEVEL[XP_PER_LEVEL.length - 1];
            const xpProgress = Math.min((gameState.xp / xpForNextLevel) * 100, 100);
            
            DOM.xpFill.style.width = xpProgress + '%';
            DOM.xpText.textContent = `${gameState.xp} / ${xpForNextLevel} XP`;
            DOM.currentLevel.textContent = gameState.level;
        }

        function checkLevelUp() {
            if (gameState.level < 5 && gameState.xp >= XP_PER_LEVEL[gameState.level]) {
                gameState.level++;
                showAchievement('Level Up!', `You reached Level ${gameState.level}!`, '‚¨ÜÔ∏è');
                createParticleEffect();
            }
        }

        function createParticleEffect() {
            if (!DOM.particleContainer) return;
            
            const colors = ['#fbbf24', '#f59e0b', '#2563eb', '#7c3aed', '#10b981'];
            const particleCount = 30;
            
            for (let i = 0; i < particleCount; i++) {
                setTimeout(() => {
                    const particle = document.createElement('div');
                    particle.className = 'particle';
                    particle.style.cssText = `
                        left: ${Math.random() * window.innerWidth}px;
                        top: -10px;
                        background: ${colors[Math.floor(Math.random() * colors.length)]};
                        animation-duration: ${2 + Math.random() * 2}s;
                        animation-delay: ${Math.random() * 0.5}s;
                    `;
                    DOM.particleContainer.appendChild(particle);
                    
                    particle.addEventListener('animationend', () => particle.remove());
                }, i * 50);
            }
        }

        function checkAchievements() {
            // First graph created
            if (!gameState.achievements.has('first_graph') && gameState.actionsPerformed.has('add_edge_graph-canvas-1')) {
                gameState.achievements.add('first_graph');
                showAchievement('Graph Builder', 'Created your first graph!', 'üåê');
            }
            
            // Algorithm explorer
            if (!gameState.achievements.has('algorithm_explorer') && 
                gameState.actionsPerformed.has('dfs_complete') && 
                gameState.actionsPerformed.has('bfs_complete')) {
                gameState.achievements.add('algorithm_explorer');
                showAchievement('Algorithm Master', 'Explored both DFS and BFS!', 'üîç');
            }
            
            // Social networker
            if (!gameState.achievements.has('social_networker') && gameState.actionsPerformed.has('practice_complete')) {
                gameState.achievements.add('social_networker');
                showAchievement('Social Networker', 'Built a complete social network!', 'üë•');
            }
            
            // Perfect quiz
            if (!gameState.achievements.has('perfect_quiz') && gameState.sectionScores.finalQuiz === 8) {
                gameState.achievements.add('perfect_quiz');
                showAchievement('Perfect Score', 'Aced the final quiz!', 'üíØ');
            }
            
            // Completion
            if (!gameState.achievements.has('graph_master') && gameState.completedSections.size >= 10) {
                gameState.achievements.add('graph_master');
                showAchievement('Graph Master', 'Completed all main sections!', 'üéì');
            }
        }

        function showAchievement(title, desc, icon) {
            if (!DOM.achievementPopup) return;
            
            const titleEl = DOM.achievementPopup.querySelector('#achievement-title');
            const descEl = DOM.achievementPopup.querySelector('#achievement-desc');
            const iconEl = DOM.achievementPopup.querySelector('#achievement-icon');
            
            if (titleEl) titleEl.textContent = title;
            if (descEl) descEl.textContent = desc;
            if (iconEl) iconEl.textContent = icon;
            
            DOM.achievementPopup.classList.add('show');
            setTimeout(() => {
                if (DOM.achievementPopup) DOM.achievementPopup.classList.remove('show');
            }, 3000);
            
            awardXP(50, 'Achievement');
            
            if ('vibrate' in navigator) {
                navigator.vibrate([100, 50, 100]);
            }
        }

        // Quiz Functions
        function selectQuizOption(option) {
            const siblings = option.parentElement.querySelectorAll('.quiz-option');
            siblings.forEach(s => s.classList.remove('selected'));
            option.classList.add('selected');
        }

        // Utility Functions
        function markSectionComplete(section) {
            gameState.completedSections.add(section);
            const pill = document.querySelector(`[data-section="${section}"]`);
            if (pill) pill.classList.add('completed');
            saveProgress();
        }

        function showShameMessage() {
            if (!DOM.shameMessage) return;
            
            DOM.shameMessage.style.display = 'block';
            DOM.shameMessage.style.animation = 'shameAnimation 3s ease forwards';
            
            gameState.xp = Math.max(0, gameState.xp - 10);
            updateXPDisplay();
            
            setTimeout(() => {
                if (DOM.shameMessage) DOM.shameMessage.style.display = 'none';
            }, 3000);
        }

        function showHint(section) {
            const hint = document.getElementById(section + '-hint');
            if (!hint) return;
            
            hint.classList.add('show');
            const xpReduction = gameState.hintUsage[section] ? 0 : -5;
            gameState.hintUsage[section] = true;
            if (xpReduction < 0) {
                gameState.xp = Math.max(0, gameState.xp + xpReduction);
                updateXPDisplay();
            }
        }

        // Feedback System
        function openFeedback() {
            if (DOM.feedbackModal) {
                DOM.feedbackModal.style.display = 'flex';
                updateFeedbackPage();
            }
        }

        function closeFeedback() {
            if (DOM.feedbackModal) {
                DOM.feedbackModal.style.display = 'none';
            }
            if (DOM.feedbackText) {
                DOM.feedbackText.value = '';
            }
        }

        function updateFeedbackPage() {
            const sectionTitles = {
                'intro': 'Introduction',
                'starter': 'Starter Activity',
                'fundamentals': 'Graph Fundamentals',
                'types': 'Types of Graphs',
                'representations': 'Graph Representations',
                'applications': 'Real-World Applications',
                'ai': 'Graphs in AI',
                'algorithms': 'Graph Algorithms',
                'practice': 'Build a Graph',
                'summary': 'Summary & Quiz',
                'exam': 'Exam Practice',
                'extension': 'Extension Activities',
                'videos': 'Videos'
            };
            
            if (DOM.feedbackPage) {
                DOM.feedbackPage.textContent = sectionTitles[gameState.currentSection] || 'Unknown';
            }
        }

        function sendFeedback() {
            if (!DOM.feedbackText) return;
            
            const text = DOM.feedbackText.value.trim();
            if (!text) {
                alert('Please enter your feedback');
                return;
            }
            
            const subject = encodeURIComponent('Graph Lesson Feedback');
            const body = encodeURIComponent(
                `Page: ${DOM.feedbackPage ? DOM.feedbackPage.textContent : 'Unknown'}\n\n` +
                `Feedback: ${text}\n\n` +
                `Section ID: ${gameState.currentSection}\n` +
                `Level: ${gameState.level}, XP: ${gameState.xp}`
            );
            
            window.location.href = `mailto:millingtond@mgs.org?subject=${subject}&body=${body}`;
            closeFeedback();
            awardXP(5, 'Feedback Sent', 'feedback');
        }

        // Accessibility
        function toggleHighContrast() {
            document.body.classList.toggle('high-contrast');
            saveProgress();
        }

        function toggleDyslexiaFont() {
            document.body.classList.toggle('dyslexia-font');
            saveProgress();
        }

        function changeFontSize(size) {
            document.body.classList.remove('font-small', 'font-large', 'font-xlarge');
            if (size !== 'normal') {
                document.body.classList.add('font-' + size);
            }
            saveProgress();
        }

        // Save/Load Progress
        function saveProgress() {
            const data = {
                gameState: {
                    xp: gameState.xp,
                    level: gameState.level,
                    completedSections: Array.from(gameState.completedSections),
                    achievements: Array.from(gameState.achievements),
                    actionsPerformed: Array.from(gameState.actionsPerformed),
                    currentSection: gameState.currentSection,
                    sectionScores: gameState.sectionScores,
                    hintUsage: gameState.hintUsage
                },
                accessibility: {
                    highContrast: document.body.classList.contains('high-contrast'),
                    dyslexiaFont: document.body.classList.contains('dyslexia-font'),
                    fontSize: Array.from(document.body.classList).find(c => c.startsWith('font-')) || 'normal'
                }
            };
            
            try {
                sessionStorage.setItem('graphLessonProgress', JSON.stringify(data));
            } catch (e) {
                console.warn('Could not save progress:', e);
            }
        }

        function loadProgress() {
            try {
                const saved = sessionStorage.getItem('graphLessonProgress');
                if (saved) {
                    const data = JSON.parse(saved);
                    
                    // Restore game state
                    gameState.xp = data.gameState.xp || 0;
                    gameState.level = data.gameState.level || 1;
                    gameState.completedSections = new Set(data.gameState.completedSections || []);
                    gameState.achievements = new Set(data.gameState.achievements || []);
                    gameState.actionsPerformed = new Set(data.gameState.actionsPerformed || []);
                    gameState.currentSection = data.gameState.currentSection || 'intro';
                    gameState.sectionScores = data.gameState.sectionScores || {};
                    gameState.hintUsage = data.gameState.hintUsage || {};
                    
                    // Restore accessibility settings
                    if (data.accessibility) {
                        if (data.accessibility.highContrast) {
                            document.body.classList.add('high-contrast');
                        }
                        if (data.accessibility.dyslexiaFont) {
                            document.body.classList.add('dyslexia-font');
                        }
                        if (data.accessibility.fontSize && data.accessibility.fontSize !== 'normal') {
                            document.body.classList.add(data.accessibility.fontSize);
                        }
                    }
                    
                    // Restore completed sections visual state
                    gameState.completedSections.forEach(section => {
                        const pill = document.querySelector(`[data-section="${section}"]`);
                        if (pill) pill.classList.add('completed');
                    });
                }
            } catch (e) {
                console.error('Error loading progress:', e);
            }
        }

        // Canvas initialization
        function initializeCanvas() {
            const canvas = document.getElementById('drawing-canvas');
            if (!canvas) return;
            
            const ctx = canvas.getContext('2d');
            let isDrawing = false;
            let lastX = 0;
            let lastY = 0;
            
            canvas.width = 600;
            canvas.height = 300;
            
            function getCoordinates(e) {
                const rect = canvas.getBoundingClientRect();
                const scaleX = canvas.width / rect.width;
                const scaleY = canvas.height / rect.height;
                
                if (e.touches) {
                    return {
                        x: (e.touches[0].clientX - rect.left) * scaleX,
                        y: (e.touches[0].clientY - rect.top) * scaleY
                    };
                } else {
                    return {
                        x: (e.clientX - rect.left) * scaleX,
                        y: (e.clientY - rect.top) * scaleY
                    };
                }
            }
            
            function startDrawing(e) {
                isDrawing = true;
                const coords = getCoordinates(e);
                lastX = coords.x;
                lastY = coords.y;
                e.preventDefault();
            }
            
            function draw(e) {
                if (!isDrawing) return;
                
                const coords = getCoordinates(e);
                ctx.beginPath();
                ctx.moveTo(lastX, lastY);
                ctx.lineTo(coords.x, coords.y);
                ctx.strokeStyle = '#000';
                ctx.lineWidth = 2;
                ctx.lineCap = 'round';
                ctx.stroke();
                
                lastX = coords.x;
                lastY = coords.y;
                e.preventDefault();
            }
            
            function stopDrawing(e) {
                isDrawing = false;
                e.preventDefault();
            }
            
            // Mouse events
            canvas.addEventListener('mousedown', startDrawing);
            canvas.addEventListener('mousemove', draw);
            canvas.addEventListener('mouseup', stopDrawing);
            canvas.addEventListener('mouseout', stopDrawing);
            
            // Touch events
            canvas.addEventListener('touchstart', startDrawing, { passive: false });
            canvas.addEventListener('touchmove', draw, { passive: false });
            canvas.addEventListener('touchend', stopDrawing, { passive: false });
        }

        function clearCanvas() {
            const canvas = document.getElementById('drawing-canvas');
            if (!canvas) return;
            const ctx = canvas.getContext('2d');
            if (ctx) ctx.clearRect(0, 0, canvas.width, canvas.height);
        }

        // Auto-save every 30 seconds
        setInterval(saveProgress, 30000);

        // Easter egg: Konami code
        const konamiCode = ['ArrowUp', 'ArrowUp', 'ArrowDown', 'ArrowDown', 'ArrowLeft', 'ArrowRight', 'ArrowLeft', 'ArrowRight', 'b', 'a'];
        let konamiIndex = 0;
        
        document.addEventListener('keydown', function(e) {
            if (e.key === konamiCode[konamiIndex]) {
                konamiIndex++;
                if (konamiIndex === konamiCode.length) {
                    showAchievement('Secret Found!', 'You discovered the Konami code!', 'üéÆ');
                    awardXP(100, 'Easter Egg', 'konami_code');
                    konamiIndex = 0;
                    createParticleEffect();
                }
            } else {
                konamiIndex = 0;
            }
        });

        // Performance monitoring
        const startTime = Date.now();
        
        window.addEventListener('load', function() {
            console.log('Page load time:', Date.now() - startTime, 'ms');
            console.log('Graph Lesson Worksheet initialized successfully');
        });

        // Prevent right-click
        document.addEventListener('contextmenu', function(e) {
            e.preventDefault();
            return false;
        });

        // Add floating animation style
        try {
            const style = document.createElement('style');
            style.textContent = `
                @keyframes floatUp {
                    0% { transform: translateY(0); opacity: 1; }
                    100% { transform: translateY(-50px); opacity: 0; }
                }
            `;
            document.head.appendChild(style);
        } catch (e) {
            console.warn('Could not add floating animation style:', e);
        }
    </script>
</body>
</html>