<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>A-Level Addressing Modes Simulation</title>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600;700&display=swap" rel="stylesheet">
    <link href="https://fonts.googleapis.com/css2?family=Fira+Code:wght@500&display=swap" rel="stylesheet">
    <style>
        :root {
            --bg-color: #121828;
            --primary-color: #1C2333;
            --secondary-color: #2A3447;
            --accent-color: #8A42E9;
            --text-color: #E0E0E0;
            --highlight-color: #38BDF8;
            --success-color: #34D399;
            --error-color: #F87171;
            --font-family: 'Inter', sans-serif;
            --border-radius: 12px;
            --transition-speed: 0.4s;
            --ease-cubic: cubic-bezier(0.64, 0, 0.35, 1);
        }

        @media (prefers-reduced-motion: reduce) {
            *, *::before, *::after {
                animation-duration: 0.01ms !important;
                animation-iteration-count: 1 !important;
                transition-duration: 0.01ms !important;
                scroll-behavior: auto !important;
            }
        }

        body {
            font-family: var(--font-family);
            background-color: var(--bg-color);
            color: var(--text-color);
            margin: 0;
            padding: 20px;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            min-height: 100vh;
            overflow-x: hidden;
        }

        .simulation-container {
            width: 100%;
            max-width: 1200px;
            background: var(--primary-color);
            border-radius: var(--border-radius);
            box-shadow: 0 20px 40px rgba(0, 0, 0, 0.4);
            border: 1px solid rgba(255, 255, 255, 0.1);
            overflow: hidden;
            backdrop-filter: blur(10px);
        }

        header {
            padding: 25px 35px;
            background: linear-gradient(135deg, var(--secondary-color), var(--primary-color) 70%);
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
            position: relative;
        }
        
        header::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            height: 2px;
            background: linear-gradient(90deg, transparent, var(--highlight-color), transparent);
            animation: move-glow 5s linear infinite;
        }

        @keyframes move-glow {
            from { transform: translateX(-100%); }
            to { transform: translateX(100%); }
        }

        header h1 {
            margin: 0;
            font-size: 2.2em;
            color: white;
            text-shadow: 0 2px 8px rgba(0,0,0,0.5);
        }
        
        header p {
            margin: 5px 0 0;
            color: var(--text-color);
            opacity: 0.9;
            font-size: 1.1em;
        }
        
        main {
            padding: 35px;
        }

        .step { display: none; }
        .step.active { display: block; animation: fadeIn 0.6s var(--ease-cubic); }
        @keyframes fadeIn { from { opacity: 0; transform: translateY(15px); } to { opacity: 1; transform: translateY(0); } }

        h2 {
            color: var(--highlight-color);
            border-bottom: 2px solid var(--highlight-color);
            padding-bottom: 10px;
            margin-bottom: 25px;
            font-size: 1.8em;
        }
        
        .simulation-area { display: flex; gap: 30px; margin-top: 25px; flex-wrap: wrap; }
        .cpu, .memory { flex: 1; min-width: 320px; background: rgba(42, 52, 71, 0.6); padding: 20px; border-radius: var(--border-radius); border: 1px solid rgba(255, 255, 255, 0.1); }
        .component-title { font-weight: 700; color: white; margin-bottom: 20px; text-align: center; font-size: 1.3em; }
        .register, .memory-location {
            display: flex; justify-content: space-between; align-items: center; padding: 12px; margin-bottom: 10px; border-radius: 8px;
            background: var(--primary-color); transition: all var(--transition-speed) var(--ease-cubic); will-change: transform, background-color, box-shadow; transform: translateZ(0);
        }
        .register-name, .memory-address { font-weight: 600; color: var(--text-color); }
        .register-value, .memory-value {
            font-family: 'Fira Code', monospace; font-size: 1.1em; background-color: var(--bg-color); padding: 5px 10px;
            border-radius: 6px; color: white; min-width: 60px; text-align: center;
        }

        .explanation-panel {
            margin-top: 25px; padding: 20px; background: rgba(42, 52, 71, 0.6); border-radius: var(--border-radius);
            border-left: 5px solid var(--accent-color); line-height: 1.7; min-height: 100px; transition: all var(--transition-speed) ease;
        }
        
        .instruction-box {
            font-family: 'Fira Code', monospace; background: #0D1117; color: #58A6FF; padding: 15px 20px;
            border-radius: 8px; margin: 25px 0; text-align: center; font-size: 1.3em; border: 1px solid #30363D;
        }
        
        .highlight-fetch { background-color: #B45309 !important; transform: scale(1.03); }
        .highlight-execute { background-color: #BE185D !important; transform: scale(1.03); }
        .highlight-data { background-color: var(--highlight-color) !important; color: var(--bg-color); transform: scale(1.03); }
        .highlight-source { box-shadow: 0 0 15px 3px var(--highlight-color); }
        .highlight-dest { box-shadow: 0 0 15px 3px var(--accent-color); }

        .navigation {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-top: 35px;
            padding: 20px 35px;
            border-top: 1px solid rgba(255, 255, 255, 0.1);
            background: var(--primary-color);
            flex-wrap: wrap;
            gap: 15px;
        }
        
        .main-nav { display: flex; align-items: center; gap: 15px; }
        
        .playback-controls {
            display: flex;
            gap: 10px;
            align-items: center;
        }

        .nav-button, .control-button {
            background: linear-gradient(145deg, var(--secondary-color), var(--primary-color));
            color: var(--text-color);
            border: 1px solid var(--accent-color);
            padding: 12px 25px;
            border-radius: var(--border-radius);
            cursor: pointer;
            font-size: 1em;
            font-weight: 600;
            transition: all 0.3s ease;
            position: relative;
            overflow: hidden;
        }

        .control-button { padding: 10px 15px; font-size: 0.9em; }

        .nav-button:hover:not(:disabled), .control-button:hover:not(:disabled) {
            background: var(--accent-color); color: white; transform: translateY(-2px);
            box-shadow: 0 10px 20px rgba(138, 66, 233, 0.3);
        }
        
        .control-button.active {
             background: var(--highlight-color); color: var(--bg-color);
             border-color: var(--highlight-color); box-shadow: 0 0 15px var(--highlight-color);
        }

        .nav-button:disabled, .control-button:disabled {
            background: #2a3447; color: #6c757d; border-color: #495057; cursor: not-allowed; transform: none; box-shadow: none;
        }
        
        #step-indicator { font-weight: 600; color: var(--text-color); opacity: 0.8; margin: 0 15px; }

        .modal {
            display: none; position: fixed; z-index: 1000; left: 0; top: 0; width: 100%; height: 100%;
            overflow: auto; background-color: rgba(18, 24, 40, 0.8); backdrop-filter: blur(5px);
            align-items: center; justify-content: center; animation: fadeIn 0.3s ease;
        }
        .modal-content {
            background: var(--primary-color); margin: auto; padding: 35px; border: 1px solid var(--accent-color);
            width: 90%; max-width: 600px; border-radius: var(--border-radius);
            box-shadow: 0 10px 40px rgba(0,0,0,0.5); animation: slideIn 0.4s var(--ease-cubic); text-align: center;
        }
        .modal-content h3 { color: var(--highlight-color); margin-top: 0; font-size: 1.8em; }
        .modal-content p { line-height: 1.8; font-size: 1.1em; }
        @keyframes slideIn { from { transform: translateY(-30px) scale(0.98); opacity: 0; } to { transform: translateY(0) scale(1); opacity: 1; } }
        .modal-close {
            background: var(--accent-color); color: white; border: none; padding: 12px 25px;
            border-radius: var(--border-radius); cursor: pointer; font-size: 1em; margin-top: 25px;
            font-weight: 600; transition: all 0.3s ease;
        }
        .modal-close:hover { background: #7a32d9; transform: scale(1.05); }
        
        #quiz-section { display: flex; flex-direction: column; gap: 20px; }
        .question { background: var(--secondary-color); padding: 25px; border-radius: var(--border-radius); border-left: 5px solid var(--highlight-color); }
        .question-title { font-weight: bold; margin-bottom: 15px; font-size: 1.1em; }
        .options { display: flex; flex-direction: column; gap: 10px; }
        .option {
            background: var(--primary-color); padding: 14px; border-radius: 8px; cursor: pointer;
            transition: all 0.3s ease; border: 2px solid transparent; position: relative;
        }
        .option:hover { border-color: var(--highlight-color); }
        .option.selected { border-color: var(--accent-color); background: #2a3447; }
        .option.correct { background: var(--success-color); color: white; border-color: var(--success-color) !important; font-weight: bold; }
        .option.incorrect { background: var(--error-color); color: white; border-color: var(--error-color) !important; font-weight: bold; }
        .option.reveal-correct { border: 2px solid var(--success-color); }

        input[type="text"] {
            width: 100%; padding: 12px; border-radius: 8px; border: 2px solid var(--highlight-color);
            background: var(--primary-color); color: var(--text-color); font-size: 1.1em;
            margin-top: 10px; box-sizing: border-box; transition: all 0.3s ease;
        }
        input[type="text"]:focus { outline: none; box-shadow: 0 0 10px var(--highlight-color); border-color: var(--accent-color); }
        
        .feedback { margin-top: 15px; padding: 12px; border-radius: 8px; font-weight: 500; line-height: 1.5; display: none; }
        .feedback.show { display: block; animation: fadeIn 0.5s; }
        .feedback.correct { background-color: rgba(52, 211, 153, 0.1); color: var(--success-color); }
        .feedback.incorrect { background-color: rgba(248, 113, 113, 0.1); color: var(--error-color); }
        
        #quiz-results {
            margin-top: 30px; text-align: center; font-size: 1.3em; padding: 25px;
            background: linear-gradient(135deg, var(--secondary-color), var(--primary-color));
            border-radius: var(--border-radius);
        }
        #quiz-score { font-weight: bold; color: var(--highlight-color); font-size: 1.6em; }
        #submit-quiz, #reset-quiz { margin-top: 20px; }
        #reset-quiz { margin-left: 20px; }
        
        .code {
             font-family: 'Fira Code', monospace; background: rgba(0,0,0,0.3); padding: 3px 6px;
             border-radius: 5px; color: var(--highlight-color); font-weight: 600;
        }
    </style>
</head>
<body>

    <div class="simulation-container">
        <header>
            <h1>Addressing Modes Explained</h1>
            <p>An interactive guide for A-Level Computer Science (9618)</p>
        </header>

        <main>
            <!-- Step 0: Introduction -->
            <div class="step active" id="step-0">
                <h2>Welcome!</h2>
                <p>This simulation will guide you through the different ways a CPU can interpret the operand part of an instruction. These methods are called <strong>addressing modes</strong>.</p>
                <p>The addressing mode tells the CPU whether the operand is the data itself, a memory address containing the data, or an address that needs to be modified before use.</p>
                <p><strong>How to use this simulation:</strong></p>
                <ul style="line-height: 1.8;">
                    <li>Use the main <strong>"Previous Phase"</strong> and <strong>"Next Phase"</strong> buttons to move between major concepts (e.g., Immediate to Direct).</li>
                    <li>Use the <strong>"Autoplay"</strong> button to watch the animations for a phase unfold automatically.</li>
                    <li>Use the <strong>"Step"</strong> button to manually trigger each individual action within a phase for a detailed view.</li>
                </ul>
                <p>Click "Next Phase" to begin with Immediate Addressing.</p>
            </div>

            <!-- Step 1: Immediate Addressing -->
            <div class="step" id="step-1">
                <h2>1. Immediate Addressing</h2>
                <div class="simulation-area">
                    <div class="cpu"> <div class="component-title">CPU</div> <div class="register" id="imm_pc"><div class="register-name">PC</div><div class="register-value">100</div></div> <div class="register" id="imm_mar"><div class="register-name">MAR</div><div class="register-value">...</div></div> <div class="register" id="imm_mdr"><div class="register-name">MDR</div><div class="register-value">...</div></div> <div class="register" id="imm_cir"><div class="register-name">CIR</div><div class="register-value">...</div></div> <div class="register" id="imm_acc"><div class="register-name">ACC</div><div class="register-value">10</div></div> </div>
                    <div class="memory"> <div class="component-title">Memory</div> <div class="memory-location" id="imm_mem_100"><div class="memory-address">100</div><div class="memory-value">ADD 5</div></div> <div class="memory-location" id="imm_mem_101"><div class="memory-address">101</div><div class="memory-value">STO 200</div></div> </div>
                </div>
                <div class="instruction-box">Current Instruction: <span id="imm_instruction">ADD 5</span></div>
                <div class="explanation-panel" id="imm_explanation"> <strong>Initial State:</strong> The Accumulator (ACC) holds 10. The Program Counter (PC) points to address 100. </div>
            </div>

            <!-- Step 2: Direct Addressing -->
            <div class="step" id="step-2">
                <h2>2. Direct Addressing</h2>
                <div class="simulation-area">
                    <div class="cpu"> <div class="component-title">CPU</div> <div class="register" id="dir_pc"><div class="register-name">PC</div><div class="register-value">100</div></div> <div class="register" id="dir_mar"><div class="register-name">MAR</div><div class="register-value">...</div></div> <div class="register" id="dir_mdr"><div class="register-name">MDR</div><div class="register-value">...</div></div> <div class="register" id="dir_cir"><div class="register-name">CIR</div><div class="register-value">...</div></div> <div class="register" id="dir_acc"><div class="register-name">ACC</div><div class="register-value">0</div></div> </div>
                    <div class="memory"> <div class="component-title">Memory</div> <div class="memory-location" id="dir_mem_100"><div class="memory-address">100</div><div class="memory-value">LDD 250</div></div> <div class="memory-location" id="dir_mem_101"><div class="memory-address">101</div><div class="memory-value">...</div></div> <div class="memory-location" id="dir_mem_250"><div class="memory-address">250</div><div class="memory-value">42</div></div> </div>
                </div>
                <div class="instruction-box">Current Instruction: <span id="dir_instruction">LDD 250</span></div>
                <div class="explanation-panel" id="dir_explanation"> <strong>Initial State:</strong> The operand (250) is the <strong>address</strong> of the value we want. </div>
            </div>
            
            <!-- Step 3: Indirect Addressing -->
            <div class="step" id="step-3">
                <h2>3. Indirect Addressing</h2>
                <div class="simulation-area">
                    <div class="cpu"> <div class="component-title">CPU</div> <div class="register" id="ind_pc"><div class="register-name">PC</div><div class="register-value">100</div></div> <div class="register" id="ind_mar"><div class="register-name">MAR</div><div class="register-value">...</div></div> <div class="register" id="ind_mdr"><div class="register-name">MDR</div><div class="register-value">...</div></div> <div class="register" id="ind_cir"><div class="register-name">CIR</div><div class="register-value">...</div></div> <div class="register" id="ind_acc"><div class="register-name">ACC</div><div class="register-value">0</div></div> </div>
                    <div class="memory"> <div class="component-title">Memory</div> <div class="memory-location" id="ind_mem_100"><div class="memory-address">100</div><div class="memory-value">LDI 400</div></div> <div class="memory-location" id="ind_mem_400"><div class="memory-address">400</div><div class="memory-value">450</div></div> <div class="memory-location" id="ind_mem_450"><div class="memory-address">450</div><div class="memory-value">25</div></div> </div>
                </div>
                <div class="instruction-box">Current Instruction: <span id="ind_instruction">LDI 400</span></div>
                <div class="explanation-panel" id="ind_explanation"> <strong>Initial State:</strong> The operand (400) is the address of the <strong>address</strong> of the data. </div>
            </div>
            
             <!-- Step 4: Indexed Addressing -->
            <div class="step" id="step-4">
                <h2>4. Indexed Addressing</h2>
                <div class="simulation-area">
                    <div class="cpu"> <div class="component-title">CPU</div> <div class="register" id="idx_pc"><div class="register-name">PC</div><div class="register-value">100</div></div> <div class="register" id="idx_mar"><div class="register-name">MAR</div><div class="register-value">...</div></div> <div class="register" id="idx_mdr"><div class="register-name">MDR</div><div class="register-value">...</div></div> <div class="register" id="idx_cir"><div class="register-name">CIR</div><div class="register-value">...</div></div> <div class="register" id="idx_acc"><div class="register-name">ACC</div><div class="register-value">0</div></div> <div class="register" id="idx_ix"><div class="register-name">IX</div><div class="register-value">3</div></div> </div>
                    <div class="memory"> <div class="component-title">Memory (Array)</div> <div class="memory-location" id="idx_mem_100"><div class="memory-address">100</div><div class="memory-value">LDX 300</div></div> <div class="memory-location" id="idx_mem_300"><div class="memory-address">300 (Base)</div><div class="memory-value">Item 0</div></div> <div class="memory-location" id="idx_mem_301"><div class="memory-address">301</div><div class="memory-value">Item 1</div></div> <div class="memory-location" id="idx_mem_302"><div class="memory-address">302</div><div class="memory-value">Item 2</div></div> <div class="memory-location" id="idx_mem_303"><div class="memory-address">303</div><div class="memory-value">Item 3</div></div> </div>
                </div>
                <div class="instruction-box">Current Instruction: <span id="idx_instruction">LDX 300</span></div>
                <div class="explanation-panel" id="idx_explanation"> <strong>Initial State:</strong> Index Register (IX) is 3. Instruction base address is 300. </div>
            </div>
            
            <!-- Step 5: Relative Addressing -->
            <div class="step" id="step-5">
                <h2>5. Relative Addressing</h2>
                <div class="simulation-area">
                    <div class="cpu"> <div class="component-title">CPU</div> <div class="register" id="rel_pc"><div class="register-name">PC</div><div class="register-value">202</div></div> <div class="register" id="rel_mar"><div class="register-name">MAR</div><div class="register-value">...</div></div> <div class="register" id="rel_mdr"><div class="register-name">MDR</div><div class="register-value">...</div></div> <div class="register" id="rel_cir"><div class="register-name">CIR</div><div class="register-value">...</div></div> <div class="register" id="rel_acc"><div class="register-name">ACC</div><div class="register-value">0</div></div> </div>
                    <div class="memory"> <div class="component-title">Memory</div> <div class="memory-location" id="rel_mem_202"><div class="memory-address">202</div><div class="memory-value">BRA 5</div></div> <div class="memory-location" id="rel_mem_203"><div class="memory-address">203</div><div class="memory-value">...</div></div> <div class="memory-location" id="rel_mem_208"><div class="memory-address">208</div><div class="memory-value">TARGET</div></div> </div>
                </div>
                <div class="instruction-box">Current Instruction: <span id="rel_instruction">BRA 5</span></div>
                <div class="explanation-panel" id="rel_explanation"> <strong>Initial State:</strong> The operand (5) is an <strong>offset</strong> to be added to the Program Counter. </div>
            </div>

            <!-- Step 6: Quiz -->
            <div class="step" id="step-6">
                <h2>Quiz: Test Your Knowledge</h2>
                <div id="quiz-section">
                    <div class="question" id="q1"> <p class="question-title">1. An instruction is <span class="code">ADD #15</span>. The '#' signifies immediate addressing. What does the operand '15' represent?</p> <div class="options"> <div class="option" data-answer="a">The memory address where the value to be added is stored.</div> <div class="option" data-answer="b">The actual value '15' that will be added to the accumulator.</div> <div class="option" data-answer="c">A register number that contains the value to be added.</div> <div class="option" data-answer="d">The address of an address where the value is stored.</div> </div> <div class="feedback"></div> </div>
                    <div class="question" id="q2"> <p class="question-title">2. An instruction is <span class="code">LDD 500</span>. Memory address 500 contains the value 99. What value is loaded into the accumulator?</p> <div class="options"> <div class="option" data-answer="a">500</div> <div class="option" data-answer="b">99</div> <div class="option" data-answer="c">LDD</div> <div class="option" data-answer="d">An unknown value from a different memory location.</div> </div> <div class="feedback"></div> </div>
                    <div class="question" id="q3"> <p class="question-title">3. What is the primary benefit of Immediate addressing?</p> <div class="options"> <div class="option" data-answer="a">It allows for a very large range of numbers to be used.</div> <div class="option" data-answer="b">It can access any location in memory easily.</div> <div class="option" data-answer="c">It's fast because it does not require an additional memory access to fetch the data.</div> <div class="option" data-answer="d">It makes code easily re-locatable, so it can run anywhere in memory.</div> </div> <div class="feedback"></div> </div>
                    <div class="question" id="q4"> <p class="question-title">4. Which addressing mode is most suitable for efficiently accessing elements in a contiguous data structure like an array?</p> <div class="options"> <div class="option" data-answer="a">Immediate Addressing</div> <div class="option" data-answer="b">Direct Addressing</div> <div class="option" data-answer="c">Indexed Addressing</div> <div class="option" data-answer="d">Indirect Addressing</div> </div> <div class="feedback"></div> </div>
                    <div class="question" id="q5"> <p class="question-title">5. Why is excessive use of Direct Addressing often avoided in modern software?</p> <div class="options"> <div class="option" data-answer="a">It is the slowest of all addressing modes.</div> <div class="option" data-answer="b">It can only reference a very small range of memory addresses.</div> <div class="option" data-answer="c">It creates code that is not 're-locatable', as it depends on fixed memory addresses.</div> <div class="option" data-answer="d">It requires a special Index Register to function correctly.</div> </div> <div class="feedback"></div> </div>
                    <div class="question" id="q6"> <p class="question-title">6. Consider an instruction <span class="code">LDI 400</span> (Load Indirect). Memory address 400 contains the value 450. Memory address 450 contains the value 25. What value is loaded into the accumulator?</p> <div class="options"> <div class="option" data-answer="a">400</div> <div class="option" data-answer="b">450</div> <div class="option" data-answer="c">25</div> <div class="option" data-answer="d">LDI</div> </div> <div class="feedback"></div> </div>
                    <div class="question" id="q7"> <p class="question-title">7. Relative addressing calculates the target address by adding an offset to the Program Counter (PC). What is this type of addressing most commonly used for?</p> <div class="options"> <div class="option" data-answer="a">Accessing a large constant value stored in the instruction itself.</div> <div class="option" data-answer="b">Performing conditional and unconditional jumps to a nearby instruction.</div> <div class="option" data-answer="c">Accessing items sequentially within an array.</div> <div class="option" data-answer="d">Loading a value from a fixed, hardcoded memory location.</div> </div> <div class="feedback"></div> </div>
                    <div class="question" id="q8"> <p class="question-title">8. An instruction is <span class="code">LDX 2000</span>. The Index Register (IX) contains the value 5. What is the <strong>effective address</strong> of the data to be loaded?</p> <input type="text" id="q8-input" placeholder="Enter the calculated address" autocomplete="off"> <div class="feedback"></div> </div>
                    <div class="question" id="q9"> <p class="question-title">9. What is the primary drawback of Immediate Addressing?</p> <div class="options"> <div class="option" data-answer="a">It requires two memory accesses to get the data.</div> <div class="option" data-answer="b">The size of the operand value is limited by the size of the address field in the instruction.</div> <div class="option" data-answer="c">It makes program loops difficult to implement.</div> <div class="option" data-answer="d">It is incompatible with most modern CPU architectures.</div> </div> <div class="feedback"></div> </div>
                </div>
                <button class="nav-button" id="submit-quiz">Submit Answers</button>
                <div id="quiz-results" style="display: none;">
                    <h3>Quiz Complete!</h3>
                    <p>Your score: <span id="quiz-score"></span></p>
                    <button class="nav-button" id="reset-quiz">Try Again</button>
                </div>
            </div>

            <!-- Step 7: Summary -->
            <div class="step" id="step-7">
                <h2>Summary of Addressing Modes</h2>
                <p>You have now explored the key addressing modes for your A-Level course.</p>
                <ul style="line-height: 2;">
                    <li><strong>Immediate Addressing:</strong> The operand <em>is</em> the value. <br><em>Benefit:</em> Fast (no extra memory fetch for data). <em>Drawback:</em> Limited value size.</li>
                    <li><strong>Direct Addressing:</strong> The operand is the <em>address</em> of the value. <br><em>Benefit:</em> Simple. <em>Drawback:</em> Inflexible, makes code hard to relocate.</li>
                    <li><strong>Indirect Addressing:</strong> The operand is the address of a pointer to the value. <br><em>Benefit:</em> Allows for dynamic pointers and more complex data structures.</li>
                    <li><strong>Indexed Addressing:</strong> Effective Address = Base Address (operand) + value in Index Register (IX). <br><em>Benefit:</em> Ideal for accessing arrays and other sequential data.</li>
                    <li><strong>Relative Addressing:</strong> Effective Address = Program Counter (PC) + offset (operand). <br><em>Benefit:</em> Used for position-independent code and conditional jumps.</li>
                </ul>
                <p>Understanding these modes is crucial for comprehending how low-level code executes and interacts with the CPU and memory.</p>
                <p>Click the "Start Over" button to run the simulation again from the beginning.</p>
            </div>
        </main>

        <footer class="navigation">
            <div class="main-nav">
                 <button class="nav-button" id="prev-btn" disabled>← Previous Phase</button>
                 <span id="step-indicator">Step 1 / 7</span>
                 <button class="nav-button" id="next-btn">Next Phase →</button>
            </div>
            <div class="playback-controls">
                <button class="control-button" id="autoplay-btn">Autoplay</button>
                <button class="control-button" id="step-action-btn">Step</button>
            </div>
        </footer>
    </div>
    
    <div id="info-modal" class="modal">
        <div class="modal-content">
            <h3 id="modal-title"></h3>
            <p id="modal-text"></p>
            <button id="modal-close-btn" class="modal-close">Got it, let's start!</button>
        </div>
    </div>

<script>
document.addEventListener('DOMContentLoaded', () => {
    // --- DOM Caching ---
    const getEl = id => document.getElementById(id);
    const queryAllEl = sel => document.querySelectorAll(sel);
    const prevBtn = getEl('prev-btn');
    const nextBtn = getEl('next-btn');
    const stepIndicator = getEl('step-indicator');
    const steps = queryAllEl('.step');
    const infoModal = getEl('info-modal');
    const modalTitle = getEl('modal-title');
    const modalText = getEl('modal-text');
    const modalCloseBtn = getEl('modal-close-btn');
    const quizSection = getEl('quiz-section');
    const submitQuizBtn = getEl('submit-quiz');
    const resetQuizBtn = getEl('reset-quiz');
    const quizResults = getEl('quiz-results');
    const autoplayBtn = getEl('autoplay-btn');
    const stepActionBtn = getEl('step-action-btn');

    // --- State Management ---
    let currentStepIndex = 0;
    let quizSubmitted = false;
    let isAutoplaying = false;
    let autoplayTimer = null;
    let isAnimating = false;
    let actionQueue = [];

    const stepDefinitions = new Map([
        [0, { name: "Introduction", init: () => {} }],
        [1, { name: "Immediate Addressing", init: resetImmState }],
        [2, { name: "Direct Addressing", init: resetDirState }],
        [3, { name: "Indirect Addressing", init: resetIndState }],
        [4, { name: "Indexed Addressing", init: resetIdxState }],
        [5, { name: "Relative Addressing", init: resetRelState }],
        [6, { name: "Comprehensive Quiz", init: resetQuiz }],
        [7, { name: "Summary", init: () => { nextBtn.textContent = 'Start Over →'; } }]
    ]);

    const quizSolutions = { q1: 'b', q2: 'b', q3: 'c', q4: 'c', q5: 'c', q6: 'c', q7: 'b', q8: '2005', q9: 'b' };
    
    // --- Animation Action Definitions ---
    const getAnimationActions = (stepIndex) => {
        const setExplanation = (id, text) => () => getEl(id).innerHTML = text;
        const animate = (elId, className, duration = 500) => () => animateElement(getEl(elId), className, duration);
        const update = (elId, value, duration = 400) => () => updateRegister(getEl(elId), value, duration);
        const pause = (duration = 600) => () => new Promise(res => setTimeout(res, duration));

        switch (stepIndex) {
            case 1: return [
                setExplanation('imm_explanation', "<strong>Fetch 1:</strong> PC value (100) is copied to MAR."),
                animate('imm_pc', 'highlight-source'), update('imm_mar', '100'),
                setExplanation('imm_explanation', "<strong>Fetch 2:</strong> Instruction <span class='code'>ADD 5</span> is fetched to CIR. PC increments."),
                animate('imm_mem_100', 'highlight-fetch', 600), update('imm_mdr', 'ADD 5'), update('imm_cir', 'ADD 5'), update('imm_pc', '101'),
                setExplanation('imm_explanation', "<strong>Execute 1:</strong> The instruction is decoded. The CU identifies an ADD operation with an immediate value (5)."),
                animate('imm_cir', 'highlight-execute', 600),
                setExplanation('imm_explanation', "<strong>Execute 2:</strong> The value (5) is taken from CIR and added to ACC. Result (15) is stored back in ACC."),
                animate('imm_cir', 'highlight-source'), update('imm_acc', '15'), animate('imm_acc', 'highlight-dest')
            ];
            case 2: return [
                setExplanation('dir_explanation', "<strong>Fetch 1:</strong> PC (100) copied to MAR."),
                animate('dir_pc', 'highlight-source'), update('dir_mar', '100'),
                setExplanation('dir_explanation', "<strong>Fetch 2:</strong> Instruction <span class='code'>LDD 250</span> fetched to CIR. PC increments."),
                animate('dir_mem_100', 'highlight-fetch', 600), update('dir_mdr', 'LDD 250'), update('dir_cir', 'LDD 250'), update('dir_pc', '101'),
                setExplanation('dir_explanation', "<strong>Execute 1:</strong> The address part of the instruction (250) is copied to the MAR."),
                animate('dir_cir', 'highlight-source'), update('dir_mar', '250'),
                setExplanation('dir_explanation', "<strong>Execute 2:</strong> The data at location 250 (value 42) is fetched to the MDR."),
                animate('dir_mem_250', 'highlight-data', 600), update('dir_mdr', '42'),
                setExplanation('dir_explanation', "<strong>Execute 3:</strong> The value from MDR (42) is loaded into the ACC."),
                animate('dir_mdr', 'highlight-source'), update('dir_acc', '42'), animate('dir_acc', 'highlight-dest')
            ];
            case 3: return [ // Indirect Addressing
                setExplanation('ind_explanation', "<strong>Fetch:</strong> Instruction <span class='code'>LDI 400</span> is fetched and PC increments."),
                update('ind_cir', 'LDI 400'), update('ind_pc', '101'),
                setExplanation('ind_explanation', "<strong>Execute 1:</strong> The operand (400) is moved to the MAR to find the effective address."),
                animate('ind_cir', 'highlight-source'), update('ind_mar', '400'),
                setExplanation('ind_explanation', "<strong>Execute 2:</strong> The value at address 400 (which is 450) is fetched into the MDR. This is the <strong>effective address</strong>."),
                animate('ind_mem_400', 'highlight-data', 600), update('ind_mdr', '450'),
                setExplanation('ind_explanation', "<strong>Execute 3:</strong> The effective address (450) is copied from the MDR to the MAR."),
                animate('ind_mdr', 'highlight-source'), update('ind_mar', '450'),
                setExplanation('ind_explanation', "<strong>Execute 4:</strong> The final data at address 450 (which is 25) is fetched to the MDR."),
                animate('ind_mem_450', 'highlight-data', 600), update('ind_mdr', '25'),
                setExplanation('ind_explanation', "<strong>Execute 5:</strong> The data (25) is copied from the MDR to the Accumulator."),
                animate('ind_mdr', 'highlight-source'), update('ind_acc', '25'), animate('ind_acc', 'highlight-dest')
            ];
            case 4: return [ // Indexed Addressing
                setExplanation('idx_explanation', "<strong>Fetch:</strong> Instruction <span class='code'>LDX 300</span> is fetched into CIR; PC increments."),
                update('idx_cir', 'LDX 300'), update('idx_pc', '101'),
                setExplanation('idx_explanation', "<strong>Execute 1:</strong> The ALU calculates the effective address: Base (300) + Index (3) = <strong>303</strong>."),
                animate('idx_cir', 'highlight-source', 600), animate('idx_ix', 'highlight-source', 600), pause(),
                setExplanation('idx_explanation', "<strong>Execute 2:</strong> Calculated address (303) is placed in MAR."),
                update('idx_mar', '303'), animate('idx_mar', 'highlight-dest'),
                setExplanation('idx_explanation', "<strong>Execute 3:</strong> Data at address 303 (<span class='code'>Item 3</span>) is fetched and loaded into ACC."),
                animate('idx_mem_303', 'highlight-data', 600), update('idx_mdr', 'Item 3'), update('idx_acc', 'Item 3'), animate('idx_acc', 'highlight-dest')
            ];
            case 5: return [ // Relative Addressing
                setExplanation('rel_explanation', "<strong>Fetch:</strong> Instruction <span class='code'>BRA 5</span> is fetched; PC increments to 203."),
                update('rel_cir', 'BRA 5'), update('rel_pc', '203'),
                setExplanation('rel_explanation', "<strong>Execute 1:</strong> The ALU calculates the target address: PC (203) + offset (5) = <strong>208</strong>."),
                animate('rel_cir', 'highlight-source', 600), animate('rel_pc', 'highlight-source', 600), pause(),
                setExplanation('rel_explanation', "<strong>Execute 2:</strong> The target address (208) is loaded into the Program Counter, causing a 'jump'."),
                update('rel_pc', '208'), animate('rel_pc', 'highlight-dest', 600)
            ];
            default: return [];
        }
    };
    
    // --- Core Logic ---
    function updateUI() {
        steps.forEach((step, index) => step.classList.toggle('active', index === currentStepIndex));
        const isFirst = currentStepIndex === 0, isLast = currentStepIndex === steps.length - 1, isQuiz = currentStepIndex === 6;
        
        prevBtn.disabled = isFirst;
        nextBtn.disabled = isLast;
        
        const stepInfo = stepDefinitions.get(currentStepIndex);
        stepIndicator.textContent = `Step ${currentStepIndex + 1} / ${steps.length}: ${stepInfo.name}`;
        nextBtn.textContent = isLast ? 'Start Over →' : 'Next Phase →';

        const showPlayback = !isFirst && !isQuiz && !isLast;
        stepActionBtn.style.display = autoplayBtn.style.display = showPlayback ? 'block' : 'none';

        submitQuizBtn.style.display = isQuiz && !quizSubmitted ? 'block' : 'none';
        nextBtn.style.visibility = isQuiz && !quizSubmitted ? 'hidden' : 'visible';
    }

    function changeStep(direction) {
        stopAutoplay();
        let newIndex = currentStepIndex + direction;
        
        if (newIndex >= steps.length) { // Start over
            newIndex = 0;
            quizSubmitted = false;
        }
        
        if (newIndex >= 0 && newIndex < steps.length) {
            stepDefinitions.get(currentStepIndex)?.init(); // Reset old step
            currentStepIndex = newIndex;
            stepDefinitions.get(currentStepIndex)?.init(); // Init new step
            actionQueue = getAnimationActions(currentStepIndex);
            updateUI();
            
            if (currentStepIndex === 0) {
                 showModal("Welcome to Addressing Modes!", "This simulation will walk you through how the CPU handles instructions based on different <strong>addressing modes</strong>. Pay close attention to the flow of data.", () => {});
            }
        }
    }

    async function executeNextAction() {
        if (isAnimating || actionQueue.length === 0) {
            if(actionQueue.length === 0) stopAutoplay();
            return;
        }
        isAnimating = true;
        stepActionBtn.disabled = true;

        const action = actionQueue.shift();
        await action();
        
        stepActionBtn.disabled = false;
        isAnimating = false;

        if (isAutoplaying && actionQueue.length > 0) {
            autoplayTimer = setTimeout(executeNextAction, 1800);
        } else if (actionQueue.length === 0) {
            stopAutoplay();
        }
    }

    function toggleAutoplay() {
        isAutoplaying = !isAutoplaying;
        autoplayBtn.classList.toggle('active', isAutoplaying);
        autoplayBtn.textContent = isAutoplaying ? 'Autoplaying...' : 'Autoplay';
        if (isAutoplaying) {
            executeNextAction();
        } else {
            stopAutoplay();
        }
    }
    
    function stopAutoplay() {
        isAutoplaying = false;
        autoplayBtn.classList.remove('active');
        autoplayBtn.textContent = 'Autoplay';
        if (autoplayTimer) clearTimeout(autoplayTimer);
    }
    
    // --- State Reset Functions ---
    const resetHighlights = () => queryAllEl('.highlight-fetch, .highlight-execute, .highlight-data, .highlight-source, .highlight-dest').forEach(el => el.className = el.className.replace(/highlight-\w+/g, '').trim());
    const setElementText = (id, text) => { getEl(id).lastElementChild.textContent = text; };

    function resetImmState() {
        setElementText('imm_pc', "100"); setElementText('imm_mar', "..."); setElementText('imm_mdr', "..."); setElementText('imm_cir', "..."); setElementText('imm_acc', "10");
        getEl('imm_explanation').innerHTML = "<strong>Initial State:</strong> The Accumulator (ACC) holds 10. The PC points to address 100.";
        resetHighlights();
    }
    function resetDirState() {
        setElementText('dir_pc', "100"); setElementText('dir_mar', "..."); setElementText('dir_mdr', "..."); setElementText('dir_cir', "..."); setElementText('dir_acc', "0");
        getEl('dir_explanation').innerHTML = "<strong>Initial State:</strong> The operand (250) is the <strong>address</strong> of the value we want.";
        resetHighlights();
    }
    function resetIndState() {
        setElementText('ind_pc', "100"); setElementText('ind_mar', "..."); setElementText('ind_mdr', "..."); setElementText('ind_cir', "..."); setElementText('ind_acc', "0");
        getEl('ind_explanation').innerHTML = "<strong>Initial State:</strong> The operand (400) is the address of the <strong>address</strong> of the data.";
        resetHighlights();
    }
    function resetIdxState() {
        setElementText('idx_pc', "100"); setElementText('idx_mar', "..."); setElementText('idx_mdr', "..."); setElementText('idx_cir', "..."); setElementText('idx_acc', "0"); setElementText('idx_ix', "3");
        getEl('idx_explanation').innerHTML = "<strong>Initial State:</strong> Index Register (IX) is 3. Instruction base address is 300.";
        resetHighlights();
    }
     function resetRelState() {
        setElementText('rel_pc', "202"); setElementText('rel_mar', "..."); setElementText('rel_mdr', "..."); setElementText('rel_cir', "..."); setElementText('rel_acc', "0");
        getEl('rel_explanation').innerHTML = "<strong>Initial State:</strong> The operand (5) is an <strong>offset</strong> to be added to the Program Counter.";
        resetHighlights();
    }


    function showModal(title, text, onClosed) {
        modalTitle.textContent = title;
        modalText.innerHTML = text;
        infoModal.style.display = 'flex';
        const closeHandler = () => {
            infoModal.style.display = 'none';
            modalCloseBtn.removeEventListener('click', closeHandler);
            if (onClosed) requestAnimationFrame(onClosed);
        };
        modalCloseBtn.addEventListener('click', closeHandler);
    }
    
    const animateElement = (element, className, duration = 500) => new Promise(resolve => { if(element) { element.classList.add(className); setTimeout(() => { element.classList.remove(className); resolve(); }, duration); } else { resolve(); } });
    const updateRegister = (element, value, duration = 400) => new Promise(resolve => { if (element && element.lastElementChild) { element.classList.add('highlight-execute'); setTimeout(() => { element.lastElementChild.textContent = value; element.classList.remove('highlight-execute'); resolve(); }, duration); } else { resolve(); } });
    
    // --- Quiz Logic ---
    function handleSubmitQuiz() {
        if (quizSubmitted) return;
        let score = 0;
        quizSubmitted = true;
        
        Object.keys(quizSolutions).forEach(qId => {
            const questionDiv = getEl(qId);
            const feedbackDiv = questionDiv.querySelector('.feedback');
            const isTextInput = qId === 'q8';
            
            if (isTextInput) {
                const input = getEl('q8-input'); input.disabled = true;
                if (input.value.trim() === quizSolutions.q8) { score++; feedbackDiv.textContent = `Correct! The effective address is 2000 + 5 = ${quizSolutions.q8}.`; feedbackDiv.className = 'feedback correct show';
                } else { feedbackDiv.textContent = `Incorrect. The effective address is Base Address (2000) + Index Register (5), which equals ${quizSolutions.q8}.`; feedbackDiv.className = 'feedback incorrect show'; }
            } else {
                const selectedOption = questionDiv.querySelector('.option.selected');
                questionDiv.querySelectorAll('.option').forEach(opt => opt.style.pointerEvents = 'none');
                if (selectedOption) {
                    if (selectedOption.dataset.answer === quizSolutions[qId]) { score++; selectedOption.classList.add('correct'); feedbackDiv.textContent = 'Correct! Well done.'; feedbackDiv.className = 'feedback correct show';
                    } else { selectedOption.classList.add('incorrect'); const correctOption = questionDiv.querySelector(`[data-answer="${quizSolutions[qId]}"]`); correctOption.classList.add('reveal-correct'); feedbackDiv.innerHTML = `Not quite. The correct answer was: <strong>"${correctOption.textContent}"</strong>`; feedbackDiv.className = 'feedback incorrect show'; }
                } else { feedbackDiv.textContent = 'You did not select an answer for this question.'; feedbackDiv.className = 'feedback incorrect show'; }
            }
        });
        
        quizResults.style.display = 'block';
        getEl('quiz-score').textContent = `${score} / ${Object.keys(quizSolutions).length}`;
        submitQuizBtn.style.display = 'none';
        nextBtn.style.visibility = 'visible';
        nextBtn.disabled = false;
        updateUI();
    }
    
    function resetQuiz() {
        quizSubmitted = false;
        queryAllEl('.option').forEach(opt => { opt.classList.remove('selected', 'correct', 'incorrect', 'reveal-correct'); opt.style.pointerEvents = 'auto'; });
        queryAllEl('.feedback').forEach(fb => { fb.className = 'feedback'; });
        const q8Input = getEl('q8-input'); q8Input.value = ''; q8Input.disabled = false;
        quizResults.style.display = 'none';
        submitQuizBtn.style.display = 'block';
        nextBtn.style.visibility = 'hidden';
    }

    // --- Event Listeners ---
    nextBtn.addEventListener('click', () => changeStep(1));
    prevBtn.addEventListener('click', () => changeStep(-1));
    stepActionBtn.addEventListener('click', executeNextAction);
    autoplayBtn.addEventListener('click', toggleAutoplay);
    
    quizSection.addEventListener('click', (e) => {
        if (quizSubmitted || !e.target.classList.contains('option')) return;
        const questionContainer = e.target.closest('.question');
        questionContainer.querySelectorAll('.option').forEach(opt => opt.classList.remove('selected'));
        e.target.classList.add('selected');
    });

    submitQuizBtn.addEventListener('click', handleSubmitQuiz);
    resetQuizBtn.addEventListener('click', resetQuiz);

    let keyTimeout;
    document.addEventListener('keydown', (e) => {
        if (e.target.tagName === 'INPUT' || isAnimating) return;
        clearTimeout(keyTimeout);
        keyTimeout = setTimeout(() => {
            if (e.key === 'ArrowRight') nextBtn.click();
            else if (e.key === 'ArrowLeft') prevBtn.click();
        }, 50);
    });

    // --- Initialisation ---
    changeStep(0); // Go to the first step
});
</script>

</body>
</html>
