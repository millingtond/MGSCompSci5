<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>1NF Interactive Simulation</title>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600;700&display=swap" rel="stylesheet">
    <style>
        :root {
            --bg-color: #1a1a2e;
            --primary-color: #16213e;
            --secondary-color: #0f3460;
            --accent-color: #e94560;
            --accent-glow: rgba(233, 69, 96, 0.5);
            --text-color: #e0e0e0;
            --text-muted: #a0a0c0;
            --success-color: #4CAF50;
            --error-color: #F44336;
            --border-radius: 12px;
            --glass-bg: rgba(22, 33, 62, 0.75);
            --glass-border: rgba(255, 255, 255, 0.1);
        }

        *, *::before, *::after {
            box-sizing: border-box;
            margin: 0;
            padding: 0;
        }

        @media (prefers-reduced-motion: reduce) {
            *, *::before, *::after {
                animation-duration: 0.01ms !important;
                animation-iteration-count: 1 !important;
                transition-duration: 0.01ms !important;
                scroll-behavior: auto !important;
            }
            #bg-canvas {
                display: none;
            }
        }

        body {
            font-family: 'Inter', sans-serif;
            background-color: var(--bg-color);
            color: var(--text-color);
            line-height: 1.6;
            overflow: hidden;
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100vh;
        }
        
        #bg-canvas {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: -1;
        }

        #simulation-container {
            width: 95%;
            max-width: 1200px;
            height: 95vh;
            max-height: 800px;
            background: var(--glass-bg);
            border-radius: var(--border-radius);
            backdrop-filter: blur(12px) saturate(150%);
            -webkit-backdrop-filter: blur(12px) saturate(150%);
            border: 1px solid var(--glass-border);
            box-shadow: 0 8px 32px 0 rgba(0, 0, 0, 0.37);
            display: flex;
            flex-direction: column;
            overflow: hidden;
            position: relative;
            transform: translateZ(0); /* Promotes to a new layer for performance */
        }

        header {
            padding: 1rem 2rem;
            background: rgba(0,0,0,0.2);
            border-bottom: 1px solid var(--glass-border);
            text-align: center;
        }

        header h1 {
            font-size: 1.5rem;
            color: white;
            text-shadow: 0 0 8px var(--accent-glow);
        }

        #simulation-viewport {
            flex-grow: 1;
            perspective: 1200px;
            position: relative;
            overflow: hidden;
        }

        .step {
            position: absolute;
            width: 100%;
            height: 100%;
            padding: 2rem;
            overflow-y: auto;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            transition: transform 0.7s cubic-bezier(0.4, 0, 0.2, 1), opacity 0.7s cubic-bezier(0.4, 0, 0.2, 1);
            transform-style: preserve-3d;
            backface-visibility: hidden;
            opacity: 0;
            visibility: hidden;
        }
        
        .step.active {
            opacity: 1;
            visibility: visible;
            z-index: 10;
            transform: rotateY(0deg) translateZ(0);
        }

        .step.previous {
            transform: rotateY(45deg) scale(0.8) translateX(-100%);
            opacity: 0;
        }
        
        .step.next {
            transform: rotateY(-45deg) scale(0.8) translateX(100%);
            opacity: 0;
        }

        .step-content {
            width: 100%;
            max-width: 900px;
            text-align: center;
        }

        h2 {
            font-size: 2rem;
            color: var(--accent-color);
            margin-bottom: 1rem;
        }

        p, li {
            font-size: 1.1rem;
            color: var(--text-muted);
            margin-bottom: 1rem;
            max-width: 700px;
            margin-left: auto;
            margin-right: auto;
        }

        .highlight {
            color: var(--accent-color);
            font-weight: 600;
        }

        table {
            width: 100%;
            max-width: 800px;
            margin: 1.5rem auto;
            border-collapse: collapse;
            background: var(--glass-bg);
            border-radius: var(--border-radius);
            overflow: hidden;
            border: 1px solid var(--glass-border);
            will-change: transform, opacity;
            transform: translateZ(0);
            box-shadow: 0 4px 20px rgba(0,0,0,0.2);
        }

        tbody tr {
            transition: background-color 0.3s ease;
        }
        tbody tr:hover {
            background-color: rgba(15, 52, 96, 0.3);
        }
        
        th, td {
            padding: 0.85rem 1.1rem;
            text-align: left;
            border-bottom: 1px solid var(--glass-border);
        }
        
        th {
            background-color: rgba(15, 52, 96, 0.5);
            font-weight: 600;
            color: var(--text-color);
        }

        tbody tr:last-child td {
            border-bottom: none;
        }

        .problem-cell {
            background-color: rgba(233, 69, 96, 0.2);
            outline: 2px solid var(--accent-color);
            outline-offset: -2px;
            transition: all 0.3s ease;
            position: relative;
        }
        
        .problem-cell::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: radial-gradient(circle, var(--accent-glow) 0%, transparent 70%);
            opacity: 0.5;
            animation: pulse 2s infinite;
        }
        
        @keyframes pulse {
            0% { transform: scale(0.9); opacity: 0.5; }
            70% { transform: scale(1.2); opacity: 0; }
            100% { transform: scale(0.9); opacity: 0.5; }
        }

        .solution-cell {
             background-color: rgba(76, 175, 80, 0.2);
             outline: 2px solid var(--success-color);
             outline-offset: -2px;
             border-radius: 4px;
             padding: 2px 4px;
        }

        .interactive-cell {
            cursor: pointer;
            transition: background-color 0.3s ease;
        }

        .interactive-cell:hover {
            background-color: rgba(233, 69, 96, 0.4);
        }

        .btn {
            background: linear-gradient(45deg, var(--accent-color), #ff7e5f);
            color: white;
            border: none;
            padding: 12px 24px;
            border-radius: 8px;
            font-size: 1rem;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s cubic-bezier(0.25, 0.8, 0.25, 1);
            text-transform: uppercase;
            letter-spacing: 1px;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.2);
            position: relative;
            overflow: hidden;
            will-change: transform;
            transform: translateZ(0);
        }

        .btn:hover {
            transform: translateY(-3px) scale(1.02);
            box-shadow: 0 8px 25px var(--accent-glow);
        }
        
        .btn:active {
            transform: translateY(-1px) scale(1);
        }

        .btn .ripple {
            position: absolute;
            border-radius: 50%;
            transform: scale(0);
            animation: ripple 0.6s linear;
            background-color: rgba(255, 255, 255, 0.7);
        }

        @keyframes ripple {
            to {
                transform: scale(4);
                opacity: 0;
            }
        }
        
        .navigation {
            position: absolute;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            display: flex;
            gap: 1rem;
            z-index: 100;
        }

        .nav-arrow {
            background: var(--secondary-color);
            color: white;
            border: 1px solid var(--glass-border);
            width: 50px;
            height: 50px;
            border-radius: 50%;
            font-size: 1.5rem;
            cursor: pointer;
            transition: all 0.3s ease;
            display: flex;
            justify-content: center;
            align-items: center;
            box-shadow: 0 2px 10px rgba(0,0,0,0.2);
        }

        .nav-arrow:hover {
            background: var(--accent-color);
            transform: scale(1.1);
            box-shadow: 0 4px 15px var(--accent-glow);
        }
        
        .nav-arrow:disabled {
            opacity: 0.5;
            cursor: not-allowed;
            transform: scale(1);
            background: var(--secondary-color);
            box-shadow: 0 2px 10px rgba(0,0,0,0.2);
        }
        
        .modal {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.7);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 1000;
            opacity: 0;
            visibility: hidden;
            transition: opacity 0.3s ease, visibility 0.3s ease;
            backdrop-filter: blur(5px);
        }

        .modal.visible {
            opacity: 1;
            visibility: visible;
        }

        .modal-content {
            background: var(--primary-color);
            padding: 2rem 2.5rem;
            border-radius: var(--border-radius);
            box-shadow: 0 8px 32px 0 rgba(0, 0, 0, 0.5);
            width: 90%;
            max-width: 500px;
            border: 1px solid var(--glass-border);
            transform: scale(0.9) translateY(20px);
            opacity: 0;
            transition: transform 0.4s cubic-bezier(0.2, 0.9, 0.3, 1), opacity 0.4s ease;
            text-align: center;
        }
        
        .modal.visible .modal-content {
            transform: scale(1) translateY(0);
            opacity: 1;
        }
        
        .modal-content h3 {
            color: var(--accent-color);
            margin-bottom: 1rem;
        }
        
        .modal-content p {
            margin-bottom: 1.5rem;
        }
        
        .quiz-option {
            background: var(--secondary-color);
            border: 2px solid var(--glass-border);
            color: var(--text-color);
            padding: 1rem;
            border-radius: 8px;
            text-align: left;
            cursor: pointer;
            transition: all 0.2s ease-in-out;
            position: relative;
            overflow: hidden;
        }
        
        .quiz-option:hover {
            border-color: var(--accent-color);
            transform: translateX(5px);
            box-shadow: 0 0 15px var(--accent-glow);
        }
        
        .quiz-option.selected {
            background-color: var(--accent-color);
            border-color: var(--accent-color);
            color: white;
        }

        .quiz-option.correct, .quiz-option.incorrect {
            transform: translateX(0);
        }

        .quiz-option.correct {
            background-color: var(--success-color);
            border-color: var(--success-color);
            color: white;
        }

        .quiz-option.incorrect {
            background-color: var(--error-color);
            border-color: var(--error-color);
            color: white;
        }
        
        input[type="text"] {
            background: var(--secondary-color);
            border: 2px solid var(--glass-border);
            color: var(--text-color);
            padding: 1rem;
            border-radius: 8px;
            font-size: 1rem;
            width: 100%;
            max-width: 400px;
            text-align: center;
            margin-top: 1rem;
            transition: border-color 0.3s ease;
        }

        input[type="text"]:focus {
            outline: none;
            border-color: var(--accent-color);
            box-shadow: 0 0 15px var(--accent-glow);
        }
        
        .feedback {
            margin-top: 1.5rem;
            padding: 1rem;
            border-radius: 8px;
            opacity: 0;
            transform: translateY(10px);
            transition: opacity 0.4s ease, transform 0.4s ease;
        }
        
        .feedback.show {
            opacity: 1;
            transform: translateY(0);
        }
        
        .feedback.correct {
            background: rgba(76, 175, 80, 0.2);
            color: var(--success-color);
        }
        
        .feedback.incorrect {
            background: rgba(244, 67, 54, 0.2);
            color: var(--error-color);
        }
        
        #final-score {
            font-size: 4rem;
            font-weight: bold;
            color: var(--accent-color);
            margin: 1rem 0;
        }
        
        .progress-bar {
            width: 100%;
            height: 6px;
            background-color: rgba(255, 255, 255, 0.1);
            position: absolute;
            top: 0;
            left: 0;
            z-index: 101;
        }

        #progress-indicator {
            height: 100%;
            width: 0%;
            background: linear-gradient(90deg, var(--accent-color), #ff7e5f);
            transition: width 0.5s cubic-bezier(0.25, 0.8, 0.25, 1);
            box-shadow: 0 0 10px var(--accent-glow);
        }

    </style>
</head>
<body>
    <canvas id="bg-canvas"></canvas>
    <div id="simulation-container">
        <div class="progress-bar"><div id="progress-indicator"></div></div>
        <header>
            <h1>Interactive Guide to First Normal Form (1NF)</h1>
        </header>

        <main id="simulation-viewport">
            <!-- Step 1: Introduction -->
            <div id="step-1" class="step active">
                <div class="step-content">
                    <h2>Welcome to the 1NF Simulation!</h2>
                    <p>This interactive guide will walk you through the process of converting a database table to First Normal Form (1NF). Normalization is a key database design technique to reduce data redundancy and improve data integrity.</p>
                    <p><b>How to use this simulation:</b></p>
                    <ul style="text-align: left; max-width: 500px; margin: 1rem auto;">
                        <li>Use the <b class="highlight">&larr;</b> and <b class="highlight">&rarr;</b> arrow buttons or your keyboard arrow keys to navigate between steps.</li>
                        <li>Follow the instructions on each screen to complete interactive tasks.</li>
                        <li>Contextual pop-ups will explain key concepts.</li>
                    </ul>
                    <button class="btn" onclick="nextStep()">Start Learning</button>
                </div>
            </div>

            <!-- Step 2: Un-normalized Table -->
            <div id="step-2" class="step">
                <div class="step-content">
                    <h2>The Problem: An Un-Normalized Table</h2>
                    <p>Below is a simple `Members` table. Notice how the `BooksBorrowed` column stores multiple values in a single field. This is called a <b class="highlight">repeating group of attributes.</b></p>
                    <table id="table-unnormalized">
                        <thead>
                            <tr><th>MemberID</th><th>MemberName</th><th>BooksBorrowed</th></tr>
                        </thead>
                        <tbody>
                            <tr><td>101</td><td>Alice</td><td class="problem-cell">The Hobbit, Dune</td></tr>
                            <tr><td>102</td><td>Bob</td><td class="problem-cell">1984</td></tr>
                            <tr><td>103</td><td>Charlie</td><td class="problem-cell">Foundation, Neuromancer, Hyperion</td></tr>
                        </tbody>
                    </table>
                    <p>This design has problems: How would you search for everyone who borrowed 'Dune'? It's inefficient and hard to manage.</p>
                </div>
            </div>
            
            <!-- Step 3: Rule 1 - No Repeating Groups -->
            <div id="step-3" class="step">
                <div class="step-content">
                    <h2>Rule 1: Eliminate Repeating Groups</h2>
                    <p>The first rule of 1NF is that a table must not contain repeating groups. Each cell should hold a single, or <b class="highlight">atomic</b>, value.</p>
                    <p>To fix this, we need to ensure each member-book combination gets its own row. Click the button below to see the transformation.</p>
                    <button class="btn" onclick="showRule1Fix()">Fix The Table</button>
                    <div id="table-rule1-container">
                        <table id="table-rule1-unfixed">
                           <thead><tr><th>MemberID</th><th>MemberName</th><th>BooksBorrowed</th></tr></thead>
                           <tbody>
                               <tr><td>101</td><td>Alice</td><td class="problem-cell">The Hobbit, Dune</td></tr>
                               <tr><td>102</td><td>Bob</td><td>1984</td></tr>
                               <tr><td>103</td><td>Charlie</td><td class="problem-cell">Foundation, Neuromancer, Hyperion</td></tr>
                           </tbody>
                       </table>
                    </div>
                </div>
            </div>
            
            <!-- Step 4: Rule 1 Applied -->
            <div id="step-4" class="step">
                <div class="step-content">
                    <h2>Rule 1 Applied: No More Repeating Groups</h2>
                    <p>Now, every row represents a single borrowing event. The repeating groups have been eliminated. This is much better!</p>
                     <table id="table-rule1-fixed">
                        <thead><tr><th>MemberID</th><th>MemberName</th><th>BookBorrowed</th></tr></thead>
                        <tbody>
                            <tr><td>101</td><td>Alice</td><td>The Hobbit</td></tr>
                            <tr><td>101</td><td>Alice</td><td>Dune</td></tr>
                            <tr><td>102</td><td>Bob</td><td>1984</td></tr>
                            <tr><td>103</td><td>Charlie</td><td>Foundation</td></tr>
                            <tr><td>103</td><td>Charlie</td><td>Neuromancer</td></tr>
                            <tr><td>103</td><td>Charlie</td><td>Hyperion</td></tr>
                        </tbody>
                    </table>
                    <p>However, this table isn't perfect yet. Storing 'Alice' twice is redundant. We will address this in later normal forms (2NF, 3NF). For 1NF, our main goal is to eliminate repeating groups and ensure atomicity.</p>
                </div>
            </div>

            <!-- Step 5: Rule 2 - Atomicity -->
            <div id="step-5" class="step">
                <div class="step-content">
                    <h2>Rule 2: Attributes Must Be Atomic</h2>
                    <p>Another key rule of 1NF is that all attributes must be <b class="highlight">atomic</b>. This means each cell should hold a single, indivisible piece of data.</p>
                    <p>Look at the `MemberName` column. It contains both a first name and a last name. This is not atomic.
                    <br><b>Task:</b> Click on the non-atomic cells to split them.</p>
                    <table id="table-atomic-task">
                         <thead><tr><th>MemberID</th><th>MemberName</th><th>Postcode</th></tr></thead>
                         <tbody>
                            <tr><td>201</td><td class="interactive-cell" onclick="splitName(this)">John Smith</td><td>SK10 1AA</td></tr>
                            <tr><td>202</td><td>Jane Doe</td><td>M1 2BC</td></tr>
                            <tr><td>203</td><td class="interactive-cell" onclick="splitName(this)">Peter Jones</td><td>WA1 3DE</td></tr>
                         </tbody>
                    </table>
                </div>
            </div>
            
            <!-- Step 6: Rule 2 Applied -->
            <div id="step-6" class="step">
                 <div class="step-content">
                    <h2>Rule 2 Applied: Atomic Attributes</h2>
                    <p>Great! By splitting `MemberName` into `FirstName` and `LastName`, the attributes are now atomic. This makes it much easier to sort or search by last name, for example.</p>
                    <table id="table-atomic-fixed">
                         <thead><tr><th>MemberID</th><th>FirstName</th><th>LastName</th><th>Postcode</th></tr></thead>
                         <tbody>
                             <tr><td>201</td><td>John</td><td>Smith</td><td>SK10 1AA</td></tr>
                             <tr><td>202</td><td>Jane</td><td>Doe</td><td>M1 2BC</td></tr>
                             <tr><td>203</td><td>Peter</td><td>Jones</td><td>WA1 3DE</td></tr>
                         </tbody>
                    </table>
                    <p>The table now satisfies the atomicity requirement of 1NF.</p>
                </div>
            </div>
            
            <!-- Step 7: Rule 3 - Primary Key -->
            <div id="step-7" class="step">
                <div class="step-content">
                    <h2>Rule 3: Identify a Primary Key</h2>
                    <p>A table in 1NF must have a <b class="highlight">primary key</b>. A primary key is a column (or set of columns) that uniquely identifies each row in the table.</p>
                    <p>Look at the table below. The <b class="highlight">OrderID</b> column serves as the primary key because every value in it is unique. This ensures no duplicate rows exist, fulfilling the final requirement for 1NF.</p>
                     <table id="table-pk-task">
                        <thead><tr><th style="background-color: var(--accent-color);">OrderID</th><th>CustomerName</th><th>OrderDate</th><th>ProductID</th></tr></thead>
                        <tbody>
                            <tr><td style="background-color: rgba(233, 69, 96, 0.2);">1001</td><td>Tech Corp</td><td>2025-06-28</td><td>A500</td></tr>
                            <tr><td style="background-color: rgba(233, 69, 96, 0.2);">1002</td><td>Gadgets Inc</td><td>2025-06-28</td><td>B250</td></tr>
                            <tr><td style="background-color: rgba(233, 69, 96, 0.2);">1003</td><td>Tech Corp</td><td>2025-06-29</td><td>C100</td></tr>
                        </tbody>
                    </table>
                </div>
            </div>
            
            <!-- Step 8: Quiz Intro -->
            <div id="step-8" class="step">
                <div class="step-content">
                    <h2>Ready to Test Your Knowledge?</h2>
                    <p>You've learned the three core rules of First Normal Form:</p>
                    <ol style="text-align: left; max-width: 500px; margin: 1.5rem auto; list-style-position: inside;">
                        <li>No repeating groups of attributes.</li>
                        <li>All attributes must be atomic.</li>
                        <li>There must be a primary key (no duplicate rows).</li>
                    </ol>
                    <p>Let's see what you've learned. The following quiz will test your understanding of 1NF.</p>
                     <button class="btn" onclick="nextStep()">Start Quiz</button>
                </div>
            </div>

            <!-- Step 9: Quiz Question 1 -->
            <div id="step-9" class="step">
                <div class="step-content">
                    <h2>Quiz 1/3: Identifying the Problem</h2>
                    <p>Which of the following table designs most clearly violates the "no repeating groups" rule of 1NF?</p>
                    <div class="quiz-options" id="quiz1-options" onclick="handleQuiz1(event)">
                        <div class="quiz-option" data-answer="a"><b>Table A:</b> (<u>StudentID</u>, Name, DOB)</div>
                        <div class="quiz-option" data-answer="b"><b>Table B:</b> (<u>CarID</u>, Make, Model, Color)</div>
                        <div class="quiz-option" data-answer="c"><b>Table C:</b> (<u>EmployeeID</u>, Name, Phone1, Phone2)</div>
                        <div class="quiz-option" data-answer="d"><b>Table D:</b> (<u>ProductID</u>, Name, Price)</div>
                    </div>
                    <div id="quiz1-feedback" class="feedback"></div>
                </div>
            </div>
            
            <!-- Step 10: Quiz Question 2 -->
            <div id="step-10" class="step">
                <div class="step-content">
                    <h2>Quiz 2/3: Atomicity</h2>
                    <p>A university stores student details. A `Student` table includes the attribute `Address` which stores the full street, city, and postcode (e.g., "123 Oak Lane, Anytown, AT1 2BC").</p>
                    <p>Why does this `Address` attribute violate 1NF?</p>
                     <div class="quiz-options" id="quiz2-options" onclick="handleQuiz2(event)">
                        <div class="quiz-option" data-answer="a">It is not a unique identifier.</div>
                        <div class="quiz-option" data-answer="b">It is not atomic because it can be broken down further.</div>
                        <div class="quiz-option" data-answer="c">It contains too much text, which is inefficient.</div>
                        <div class="quiz-option" data-answer="d">The table is missing a foreign key to a Postcodes table.</div>
                    </div>
                    <div id="quiz2-feedback" class="feedback"></div>
                </div>
            </div>
            
             <!-- Step 11: Quiz Question 3 -->
            <div id="step-11" class="step">
                <div class="step-content">
                    <h2>Quiz 3/3: Finding the Primary Key</h2>
                    <p>In the table from Step 4 (reproduced below), what would be the best <b class="highlight">composite primary key</b>? A composite key is a primary key made of two or more attributes.</p>
                    <table>
                        <thead><tr><th>MemberID</th><th>MemberName</th><th>BookBorrowed</th></tr></thead>
                        <tbody>
                            <tr><td>101</td><td>Alice</td><td>The Hobbit</td></tr>
                            <tr><td>101</td><td>Alice</td><td>Dune</td></tr>
                            <tr><td>102</td><td>Bob</td><td>1984</td></tr>
                        </tbody>
                    </table>
                    <p>Type the names of the two columns that form the key, separated by a comma (e.g., ColumnA, ColumnB).</p>
                    <input type="text" id="quiz3-input" placeholder="Enter column names here">
                    <button class="btn" style="margin-top: 1rem;" onclick="checkQuiz3()">Submit Answer</button>
                    <div id="quiz3-feedback" class="feedback"></div>
                </div>
            </div>

            <!-- Step 12: Final Score -->
            <div id="step-12" class="step">
                <div class="step-content final-score-container">
                    <h2>Quiz Complete!</h2>
                    <p>Here is your final score:</p>
                    <div id="final-score">0/3</div>
                    <p>You can review the simulation or try again to improve your score.</p>
                    <button class="btn" onclick="resetSimulation()">Restart Simulation</button>
                </div>
            </div>
        </main>
        
        <div class="navigation">
            <button id="prev-btn" class="nav-arrow" onclick="prevStep()">&#8592;</button>
            <button id="next-btn" class="nav-arrow" onclick="nextStep()">&#8594;</button>
        </div>
    </div>

    <!-- Modal for Explanations -->
    <div id="explanation-modal" class="modal">
        <div class="modal-content">
            <h3 id="modal-title">Concept Explained</h3>
            <p id="modal-text">This is where the explanation will go.</p>
            <button id="modal-close-btn" class="btn">Got it!</button>
        </div>
    </div>

    <script>
        // --- Particle Background ---
        const canvas = document.getElementById('bg-canvas');
        const ctx = canvas.getContext('2d');
        canvas.width = window.innerWidth;
        canvas.height = window.innerHeight;

        let particlesArray;

        const particleConfig = {
            count: 50,
            mouseRadius: 60,
            color: 'rgba(233, 69, 96, 0.7)',
        };

        class Particle {
            constructor(x, y, directionX, directionY, size, color) {
                this.x = x;
                this.y = y;
                this.directionX = directionX;
                this.directionY = directionY;
                this.size = size;
                this.color = color;
            }
            draw() {
                ctx.beginPath();
                ctx.arc(this.x, this.y, this.size, 0, Math.PI * 2, false);
                ctx.fillStyle = this.color;
                ctx.fill();
            }
            update() {
                if (this.x > canvas.width || this.x < 0) this.directionX = -this.directionX;
                if (this.y > canvas.height || this.y < 0) this.directionY = -this.directionY;
                this.x += this.directionX;
                this.y += this.directionY;
                this.draw();
            }
        }

        function initParticles() {
            particlesArray = [];
            let numberOfParticles = particleConfig.count;
            for (let i = 0; i < numberOfParticles; i++) {
                let size = (Math.random() * 2) + 1;
                let x = (Math.random() * ((innerWidth - size * 2) - (size * 2)) + size * 2);
                let y = (Math.random() * ((innerHeight - size * 2) - (size * 2)) + size * 2);
                let directionX = (Math.random() * .4) - .2;
                let directionY = (Math.random() * .4) - .2;
                particlesArray.push(new Particle(x, y, directionX, directionY, size, particleConfig.color));
            }
        }

        function animateParticles() {
            requestAnimationFrame(animateParticles);
            ctx.clearRect(0, 0, innerWidth, innerHeight);
            for (let i = 0; i < particlesArray.length; i++) {
                particlesArray[i].update();
            }
        }
        
        window.addEventListener('resize', () => {
            canvas.width = innerWidth;
            canvas.height = innerHeight;
            initParticles();
        });

        // --- DOM Caching ---
        const dom = {
            viewport: document.getElementById('simulation-viewport'),
            steps: document.querySelectorAll('.step'),
            prevBtn: document.getElementById('prev-btn'),
            nextBtn: document.getElementById('next-btn'),
            progressIndicator: document.getElementById('progress-indicator'),
            modal: document.getElementById('explanation-modal'),
            modalTitle: document.getElementById('modal-title'),
            modalText: document.getElementById('modal-text'),
            modalCloseBtn: document.getElementById('modal-close-btn'),
        };

        // --- State Management ---
        let state = {
            currentStep: 1,
            totalSteps: dom.steps.length,
            isModalOpen: false,
            isNavigating: false, // For debouncing
            quizScore: 0,
            quizAnswers: [null, null, null]
        };
        
        // --- Initialization ---
        document.addEventListener('DOMContentLoaded', initialize);

        function initialize() {
            // Event Listeners
            document.addEventListener('keydown', handleKeyPress);
            dom.modalCloseBtn.addEventListener('click', closeModal);
            dom.modal.addEventListener('click', (e) => { if (e.target === dom.modal) closeModal(); });
            
            // Add ripple effect to all buttons
            const buttons = document.querySelectorAll('.btn');
            buttons.forEach(button => {
                button.addEventListener('click', createRipple);
            });

            updateNavigation();
            updateProgress();
            
            // Start particle animation
            initParticles();
            animateParticles();
        }
        
        // --- UI Effects ---
        function createRipple(event) {
            const button = event.currentTarget;
            const circle = document.createElement("span");
            const diameter = Math.max(button.clientWidth, button.clientHeight);
            const radius = diameter / 2;
            
            circle.style.width = circle.style.height = `${diameter}px`;
            circle.style.left = `${event.clientX - button.offsetLeft - radius}px`;
            circle.style.top = `${event.clientY - button.offsetTop - radius}px`;
            circle.classList.add("ripple");
            
            const ripple = button.getElementsByClassName("ripple")[0];
            if (ripple) {
                ripple.remove();
            }
            button.appendChild(circle);
        }
        
        // --- Navigation ---
        function handleKeyPress(e) {
            if (state.isModalOpen || state.isNavigating) return;
            if (e.key === 'ArrowRight') nextStep();
            else if (e.key === 'ArrowLeft') prevStep();
        }
        
        function goToStep(stepNumber) {
            if (stepNumber < 1 || stepNumber > state.totalSteps || state.isNavigating) return;
            
            state.isNavigating = true;
            state.currentStep = stepNumber;
            
            dom.steps.forEach((step, index) => {
                const stepIdx = index + 1;
                step.classList.remove('active', 'previous', 'next');

                if (stepIdx === state.currentStep) {
                    step.classList.add('active');
                } else if (stepIdx < state.currentStep) {
                    step.classList.add('previous');
                } else {
                     step.classList.add('next');
                }
            });

            updateNavigation();
            updateProgress();
            
            if (state.currentStep === state.totalSteps) {
                animateFinalScore();
            }

            // Debounce navigation to prevent animation spam/overlap
            setTimeout(() => { state.isNavigating = false; }, 700);
        }

        function nextStep() {
            if (state.currentStep < state.totalSteps) goToStep(state.currentStep + 1);
        }

        function prevStep() {
            if (state.currentStep > 1) goToStep(state.currentStep - 1);
        }

        function updateNavigation() {
            dom.prevBtn.disabled = state.currentStep === 1;
            dom.nextBtn.disabled = state.currentStep === state.totalSteps;

            if (state.currentStep === 1 || state.currentStep === state.totalSteps) {
                dom.prevBtn.style.display = 'none';
                dom.nextBtn.style.display = 'none';
            } else {
                 dom.prevBtn.style.display = 'flex';
                 dom.nextBtn.style.display = 'flex';
            }
        }
        
        function updateProgress() {
            const progress = ((state.currentStep - 1) / (state.totalSteps - 1)) * 100;
            dom.progressIndicator.style.width = `${progress}%`;
        }

        // --- Modals ---
        function showModal(title, text, onClosed) {
            if (state.isModalOpen) return;
            state.isModalOpen = true;
            dom.modalTitle.textContent = title;
            dom.modalText.innerHTML = text;
            dom.modal.classList.add('visible');
            
            dom.modalCloseBtn.onclick = () => {
                closeModal();
                if (onClosed) onClosed();
            };
        }

        function closeModal() {
            state.isModalOpen = false;
            dom.modal.classList.remove('visible');
        }

        // --- Simulation Logic ---
        function showRule1Fix() {
            const container = document.getElementById('table-rule1-container');
            const unfixedTable = document.getElementById('table-rule1-unfixed');
            
            // Create the new table but keep it hidden initially
            const fixedTableHTML = `
                <table id="table-rule1-fixed-new" style="opacity:0; transform: scale(0.9);">
                    <thead><tr><th>MemberID</th><th>MemberName</th><th>BookBorrowed</th></tr></thead>
                    <tbody>
                        <tr><td>101</td><td>Alice</td><td class="solution-cell">The Hobbit</td></tr>
                        <tr><td>101</td><td>Alice</td><td class="solution-cell">Dune</td></tr>
                        <tr><td>102</td><td>Bob</td><td>1984</td></tr>
                        <tr><td>103</td><td>Charlie</td><td class="solution-cell">Foundation</td></tr>
                        <tr><td>103</td><td>Charlie</td><td class="solution-cell">Neuromancer</td></tr>
                        <tr><td>103</td><td>Charlie</td><td class="solution-cell">Hyperion</td></tr>
                    </tbody>
                </table>`;
            
            // Fade out the old table
            unfixedTable.style.transition = 'opacity 0.5s ease, transform 0.5s ease';
            unfixedTable.style.opacity = '0';
            unfixedTable.style.transform = 'scale(0.9)';
            
            const onModalClosed = () => {
                // Replace HTML after old table is faded out
                setTimeout(() => {
                    container.innerHTML = fixedTableHTML;
                    const fixedTable = document.getElementById('table-rule1-fixed-new');
                    // Force reflow before adding transition class
                    fixedTable.getBoundingClientRect(); 
                    
                    fixedTable.style.transition = 'opacity 0.5s ease, transform 0.5s ease';
                    fixedTable.style.opacity = '1';
                    fixedTable.style.transform = 'scale(1)';
                }, 500);
            };

            showModal(
                'Rule 1: Eliminate Repeating Groups',
                'We solve the problem by giving each `BookBorrowed` its own row. This makes the data <b class="highlight">atomic</b> at the row level. This is the first and most important step towards 1NF.',
                onModalClosed
            );
            
            document.querySelector('#step-3 .btn').style.display = 'none';
        }

        function splitName(cell) {
            if (cell.classList.contains('split')) return;
            
            const table = document.getElementById('table-atomic-task');
            cell.classList.add('split');
            
            const fullName = cell.textContent;
            const names = fullName.split(' ');
            const firstName = names[0];
            const lastName = names.slice(1).join(' ');

            cell.innerHTML = `<span class="solution-cell">${firstName}</span>, <span class="solution-cell">${lastName}</span>`;
            cell.style.cursor = 'default';
            cell.style.backgroundColor = 'transparent';

            showModal(
                'Rule 2: Atomic Attributes',
                `You've split <b class="highlight">'${fullName}'</b> into its atomic parts: '${firstName}' and '${lastName}'. This is essential for 1NF as it allows data to be sorted and searched more effectively.`
            );
            
            const allCells = table.querySelectorAll('.interactive-cell');
            const allSplit = Array.from(allCells).every(c => c.classList.contains('split'));
            if(allSplit) {
                 setTimeout(() => showModal('Task Complete!', 'You have made all names atomic. You can now proceed to the next step to see the final, corrected table structure.'), 1000);
            }
        }
        
        // --- Quiz Logic ---
        function showFeedback(el, isCorrect, text) {
            el.innerHTML = text;
            el.className = `feedback ${isCorrect ? 'correct' : 'incorrect'} show`;
        }

        function handleQuiz1(event) {
            const selectedOption = event.target.closest('.quiz-option');
            if (!selectedOption || state.quizAnswers[0] !== null) return;

            const answer = selectedOption.dataset.answer;
            const feedbackEl = document.getElementById('quiz1-feedback');
            
            if (answer === 'c') {
                selectedOption.classList.add('correct');
                showFeedback(feedbackEl, true, '<b>Correct!</b> Table C has repeating attributes (Phone1, Phone2). This is a classic violation of 1NF, as it forces a limit on phone numbers and makes querying difficult.');
                if(state.quizAnswers[0] === null) state.quizScore++;
            } else {
                selectedOption.classList.add('incorrect');
                showFeedback(feedbackEl, false, '<b>Incorrect.</b> Table C is the best answer. Having columns like `Phone1` and `Phone2` is a repeating group. The proper 1NF solution is a separate `PhoneNumbers` table linked to the employee.');
            }
            state.quizAnswers[0] = answer;
            setTimeout(nextStep, 3000);
        }
        
        function handleQuiz2(event) {
            const selectedOption = event.target.closest('.quiz-option');
            if (!selectedOption || state.quizAnswers[1] !== null) return;
            
            const answer = selectedOption.dataset.answer;
            const feedbackEl = document.getElementById('quiz2-feedback');

            if (answer === 'b') {
                 selectedOption.classList.add('correct');
                 showFeedback(feedbackEl, true, '<b>Correct!</b> The `Address` attribute is not atomic because it contains multiple distinct pieces of information (street, city, postcode) that can and should be broken down into separate columns for proper database design.');
                 if(state.quizAnswers[1] === null) state.quizScore++;
            } else {
                 selectedOption.classList.add('incorrect');
                 showFeedback(feedbackEl, false, '<b>Not quite.</b> The core principle of atomicity means a field cannot be broken down into smaller, meaningful parts. An address is a perfect example of a non-atomic attribute.');
            }
            state.quizAnswers[1] = answer;
            setTimeout(nextStep, 3000);
        }

        function checkQuiz3() {
            if (state.quizAnswers[2] !== null) return;
            
            const input = document.getElementById('quiz3-input');
            const feedbackEl = document.getElementById('quiz3-feedback');
            const userAnswer = input.value.toLowerCase().replace(/\s/g, '');
            const correctAnswers = ['memberid,bookborrowed', 'bookborrowed,memberid'];
            
            if (!userAnswer.includes(',')) {
                 showFeedback(feedbackEl, false, 'Please ensure you provide two column names, separated by a comma.');
                 return;
            }

            if (correctAnswers.includes(userAnswer)) {
                showFeedback(feedbackEl, true, '<b>Excellent!</b> The combination of `MemberID` and `BookBorrowed` uniquely identifies each row. Neither column could do this on its own, making them a perfect composite primary key.');
                 if(state.quizAnswers[2] === null) state.quizScore++;
            } else {
                showFeedback(feedbackEl, false, '<b>Not quite.</b> The correct composite key is `MemberID` and `BookBorrowed`. Together, they create a unique identifier for each specific book loan.');
            }
            state.quizAnswers[2] = userAnswer;
            document.getElementById('final-score').textContent = `${state.quizScore}/3`;
            setTimeout(nextStep, 3000);
        }
        
        function animateFinalScore() {
            const finalScoreEl = document.getElementById('final-score');
            let currentScore = 0;
            const targetScore = state.quizScore;
            
            if (targetScore === 0) {
                 finalScoreEl.textContent = "0/3";
                 return;
            }

            const interval = setInterval(() => {
                currentScore++;
                finalScoreEl.textContent = `${currentScore}/3`;
                if (currentScore >= targetScore) {
                    clearInterval(interval);
                }
            }, 200);
        }

        // --- Reset ---
        function resetSimulation() {
            location.reload();
        }
    </script>
</body>
</html>
