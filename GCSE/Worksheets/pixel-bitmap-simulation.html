<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Pixels and Bitmap Images - GCSE Computer Science</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #1e3c72 0%, #2a5298 100%);
            min-height: 100vh;
            padding: 20px;
            color: #333;
        }

        .container {
            max-width: 1200px;
            margin: 0 auto;
            background: rgba(255, 255, 255, 0.95);
            border-radius: 20px;
            padding: 30px;
            box-shadow: 0 20px 40px rgba(0, 0, 0, 0.2);
        }

        h1 {
            color: #2a5298;
            text-align: center;
            margin-bottom: 30px;
            font-size: 2.5em;
        }

        .section {
            margin-bottom: 30px;
            padding: 20px;
            background: #f8f9fa;
            border-radius: 10px;
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.1);
        }

        h2 {
            color: #1e3c72;
            margin-bottom: 15px;
        }

        .pixel-grid {
            display: inline-block;
            border: 2px solid #333;
            background: white;
            margin: 20px;
        }

        .pixel {
            display: inline-block;
            width: 40px;
            height: 40px;
            border: 1px solid #ccc;
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .pixel:hover {
            transform: scale(1.1);
            border: 2px solid #2a5298;
        }

        .color-palette {
            display: flex;
            gap: 10px;
            margin: 15px 0;
            flex-wrap: wrap;
        }

        .color-option {
            width: 50px;
            height: 50px;
            border: 3px solid transparent;
            cursor: pointer;
            border-radius: 5px;
            position: relative;
            transition: all 0.3s ease;
        }

        .color-option:hover {
            transform: scale(1.1);
        }

        .color-option.selected {
            border-color: #2a5298;
            box-shadow: 0 0 10px rgba(42, 82, 152, 0.5);
        }

        .color-label {
            position: absolute;
            bottom: -25px;
            left: 50%;
            transform: translateX(-50%);
            font-size: 12px;
            white-space: nowrap;
        }

        button {
            background: #2a5298;
            color: white;
            border: none;
            padding: 12px 24px;
            border-radius: 25px;
            cursor: pointer;
            font-size: 16px;
            transition: all 0.3s ease;
            margin: 5px;
        }

        button:hover {
            background: #1e3c72;
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.2);
        }

        .quiz-section {
            background: #e8f4f8;
            padding: 25px;
            border-radius: 10px;
            margin-top: 20px;
        }

        .question {
            margin-bottom: 20px;
            padding: 15px;
            background: white;
            border-radius: 8px;
            box-shadow: 0 2px 5px rgba(0, 0, 0, 0.1);
        }

        .question h3 {
            color: #1e3c72;
            margin-bottom: 10px;
        }

        .answer-option {
            display: block;
            margin: 10px 0;
            cursor: pointer;
        }

        .answer-option input {
            margin-right: 10px;
        }

        .feedback {
            margin-top: 10px;
            padding: 10px;
            border-radius: 5px;
            font-weight: bold;
        }

        .feedback.correct {
            background: #d4edda;
            color: #155724;
            border: 1px solid #c3e6cb;
        }

        .feedback.incorrect {
            background: #f8d7da;
            color: #721c24;
            border: 1px solid #f5c6cb;
        }

        .score {
            text-align: center;
            font-size: 1.5em;
            color: #2a5298;
            margin: 20px 0;
        }

        .binary-display {
            font-family: 'Courier New', monospace;
            font-size: 18px;
            background: #333;
            color: #0f0;
            padding: 10px;
            border-radius: 5px;
            margin: 10px 0;
        }

        .scale-demo {
            display: flex;
            gap: 20px;
            align-items: center;
            justify-content: center;
            margin: 20px 0;
        }

        @keyframes pulse {
            0% { transform: scale(1); }
            50% { transform: scale(1.05); }
            100% { transform: scale(1); }
        }

        .highlight {
            animation: pulse 1s ease-in-out infinite;
        }

        /* Slider styling */
        input[type="range"] {
            -webkit-appearance: none;
            width: 100%;
            height: 8px;
            border-radius: 5px;
            background: #d3d3d3;
            outline: none;
            opacity: 0.9;
            transition: opacity 0.2s;
        }

        input[type="range"]:hover {
            opacity: 1;
        }

        input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 25px;
            height: 25px;
            border-radius: 50%;
            background: #2a5298;
            cursor: pointer;
            transition: all 0.3s ease;
        }

        input[type="range"]::-webkit-slider-thumb:hover {
            background: #1e3c72;
            transform: scale(1.2);
        }

        input[type="range"]::-moz-range-thumb {
            width: 25px;
            height: 25px;
            border-radius: 50%;
            background: #2a5298;
            cursor: pointer;
            transition: all 0.3s ease;
        }

        input[type="range"]::-moz-range-thumb:hover {
            background: #1e3c72;
            transform: scale(1.2);
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>üñºÔ∏è Pixels and Bitmap Images</h1>

        <div class="section">
            <h2>What is a Pixel?</h2>
            <p><strong>Pixel</strong> stands for <strong>"Picture Element"</strong> - the smallest unit of a digital image.</p>
            <p>Each pixel has a single color, encoded in binary. Bitmap images are made up of a grid of these pixels.</p>
        </div>

        <div class="section">
            <h2>Interactive Pixel Grid</h2>
            <p>Click on any pixel to see its binary code. Select a color from the palette and paint your own bitmap!</p>
            
            <div class="color-palette">
                <div class="color-option selected" style="background: white;" data-color="white" data-binary="000">
                    <span class="color-label">White (000)</span>
                </div>
                <div class="color-option" style="background: black;" data-color="black" data-binary="001">
                    <span class="color-label">Black (001)</span>
                </div>
                <div class="color-option" style="background: red;" data-color="red" data-binary="010">
                    <span class="color-label">Red (010)</span>
                </div>
                <div class="color-option" style="background: green;" data-color="green" data-binary="011">
                    <span class="color-label">Green (011)</span>
                </div>
                <div class="color-option" style="background: blue;" data-color="blue" data-binary="100">
                    <span class="color-label">Blue (100)</span>
                </div>
                <div class="color-option" style="background: yellow;" data-color="yellow" data-binary="101">
                    <span class="color-label">Yellow (101)</span>
                </div>
                <div class="color-option" style="background: cyan;" data-color="cyan" data-binary="110">
                    <span class="color-label">Cyan (110)</span>
                </div>
                <div class="color-option" style="background: magenta;" data-color="magenta" data-binary="111">
                    <span class="color-label">Magenta (111)</span>
                </div>
            </div>

            <div style="display: flex; align-items: flex-start; gap: 20px;">
                <div>
                    <div class="pixel-grid" id="pixelGrid"></div>
                    <button onclick="clearGrid()">Clear Grid</button>
                    <button onclick="createSmiley()">Create Smiley</button>
                </div>
                
                <div style="flex: 1;">
                    <h3>Binary Representation:</h3>
                    <div class="binary-display" id="binaryDisplay">Click a pixel to see its binary code</div>
                    <h3>File Storage:</h3>
                    <div class="binary-display" id="fileDisplay" style="word-wrap: break-word;">The complete bitmap data will appear here</div>
                </div>
            </div>
        </div>

        <div class="section">
            <h2>Bitmap Scaling Demonstration - See Pixels Appear!</h2>
            <div style="background: #e3f2fd; padding: 15px; border-radius: 8px; margin-bottom: 20px;">
                <h4 style="margin: 0 0 10px 0; color: #1565c0;">üîç What to observe:</h4>
                <ul style="margin: 0; padding-left: 20px;">
                    <li>At 1x zoom: The image looks smooth and normal</li>
                    <li>At 5-10x zoom: Edges start to look less smooth</li>
                    <li>At 15-25x zoom: Individual pixels become clearly visible as squares</li>
                    <li>At 30-50x zoom: You can see each pixel is just a single color block!</li>
                </ul>
            </div>
            
            <div style="text-align: center; margin: 20px 0;">
                <label for="zoomSlider" style="font-weight: bold;">Zoom Level: <span id="zoomLevel">1x</span></label><br>
                <input type="range" id="zoomSlider" min="1" max="50" value="1" step="0.5" style="width: 500px; margin: 10px;">
            </div>
            
            <div style="display: flex; gap: 30px; justify-content: center; align-items: flex-start;">
                <div>
                    <h3>High Quality Image (64x64 pixels)</h3>
                    <canvas id="originalImage" width="256" height="256" style="border: 2px solid #333; image-rendering: auto;"></canvas>
                    <p style="text-align: center; margin-top: 10px; color: #666;">
                        <em>This looks smooth at normal size...</em>
                    </p>
                </div>
                <div>
                    <h3>Zoomed View <span id="pixelInfo" style="font-size: 14px; color: #666;"></span></h3>
                    <div style="width: 400px; height: 400px; overflow: hidden; border: 2px solid #333; position: relative; background: #f0f0f0;">
                        <canvas id="zoomedImage" width="400" height="400" style="position: absolute; top: 0; left: 0; cursor: crosshair;"></canvas>
                    </div>
                    <p style="text-align: center; margin-top: 10px; color: #666;">
                        <em id="zoomMessage">Use the slider to zoom in and see the pixels!</em>
                    </p>
                </div>
            </div>
            
            <div style="text-align: center; margin-top: 20px;">
                <button onclick="loadHighQualityImage('photo')">Load Photo</button>
                <button onclick="loadHighQualityImage('logo')">Load Logo</button>
                <button onclick="loadHighQualityImage('gradient')">Load Gradient</button>
                <button onclick="loadHighQualityImage('text')">Load Text</button>
            </div>
        </div>

        <div class="quiz-section">
            <h2>üìù Test Your Knowledge - OCR J277 Quiz</h2>
            <div id="quizContainer"></div>
            <button onclick="checkAnswers()" id="checkButton">Check Answers</button>
            <button onclick="resetQuiz()">Reset Quiz</button>
            <div class="score" id="scoreDisplay"></div>
        </div>
    </div>

    <script>
        const gridSize = 8;
        let selectedColor = 'white';
        let selectedBinary = '000';
        let pixelGrid = [];
        
        const colorMap = {
            'white': { hex: '#FFFFFF', binary: '000' },
            'black': { hex: '#000000', binary: '001' },
            'red': { hex: '#FF0000', binary: '010' },
            'green': { hex: '#00FF00', binary: '011' },
            'blue': { hex: '#0000FF', binary: '100' },
            'yellow': { hex: '#FFFF00', binary: '101' },
            'cyan': { hex: '#00FFFF', binary: '110' },
            'magenta': { hex: '#FF00FF', binary: '111' }
        };

        // Initialize pixel grid
        function initGrid() {
            const gridElement = document.getElementById('pixelGrid');
            gridElement.innerHTML = '';
            pixelGrid = [];
            
            for (let row = 0; row < gridSize; row++) {
                pixelGrid[row] = [];
                for (let col = 0; col < gridSize; col++) {
                    const pixel = document.createElement('div');
                    pixel.className = 'pixel';
                    pixel.style.backgroundColor = 'white';
                    pixel.dataset.row = row;
                    pixel.dataset.col = col;
                    pixel.dataset.color = 'white';
                    pixel.dataset.binary = '000';
                    
                    pixel.onclick = function() {
                        paintPixel(this);
                    };
                    
                    gridElement.appendChild(pixel);
                    pixelGrid[row][col] = { color: 'white', binary: '000' };
                }
                gridElement.appendChild(document.createElement('br'));
            }
            updateFileDisplay();
        }

        // Color palette selection
        document.querySelectorAll('.color-option').forEach(option => {
            option.onclick = function() {
                document.querySelectorAll('.color-option').forEach(opt => opt.classList.remove('selected'));
                this.classList.add('selected');
                selectedColor = this.dataset.color;
                selectedBinary = this.dataset.binary;
            };
        });

        function paintPixel(pixel) {
            pixel.style.backgroundColor = colorMap[selectedColor].hex;
            pixel.dataset.color = selectedColor;
            pixel.dataset.binary = selectedBinary;
            
            const row = parseInt(pixel.dataset.row);
            const col = parseInt(pixel.dataset.col);
            pixelGrid[row][col] = { color: selectedColor, binary: selectedBinary };
            
            // Show binary value
            document.getElementById('binaryDisplay').textContent = 
                `Pixel at (${row}, ${col}): Color = ${selectedColor}, Binary = ${selectedBinary}`;
            
            pixel.classList.add('highlight');
            setTimeout(() => pixel.classList.remove('highlight'), 500);
            
            updateFileDisplay();
        }

        function updateFileDisplay() {
            let binaryString = '';
            for (let row = 0; row < gridSize; row++) {
                for (let col = 0; col < gridSize; col++) {
                    binaryString += pixelGrid[row][col].binary;
                }
                if (row < gridSize - 1) binaryString += ' ';
            }
            document.getElementById('fileDisplay').textContent = binaryString;
        }

        function clearGrid() {
            initGrid();
            document.getElementById('binaryDisplay').textContent = 'Click a pixel to see its binary code';
        }

        function createSmiley() {
            clearGrid();
            const pattern = [
                '00000000',
                '01111110',
                '10000001',
                '10100101',
                '10000001',
                '10111101',
                '10000001',
                '01111110'
            ];
            
            const pixels = document.querySelectorAll('.pixel');
            let index = 0;
            
            for (let row = 0; row < gridSize; row++) {
                for (let col = 0; col < gridSize; col++) {
                    if (pattern[row][col] === '1') {
                        pixels[index].style.backgroundColor = 'black';
                        pixels[index].dataset.color = 'black';
                        pixels[index].dataset.binary = '001';
                        pixelGrid[row][col] = { color: 'black', binary: '001' };
                    }
                    index++;
                }
            }
            updateFileDisplay();
        }

        // High quality image generation
        let currentImage = 'photo';
        let imageData = [];
        const imageSize = 64;

        function generateHighQualityImage(type) {
            imageData = [];
            
            for (let y = 0; y < imageSize; y++) {
                imageData[y] = [];
                for (let x = 0; x < imageSize; x++) {
                    let color;
                    
                    switch(type) {
                        case 'photo':
                            // Create a sunset/sunrise scene
                            const skyGradient = Math.min(255, 100 + y * 3);
                            const sunDistance = Math.sqrt(Math.pow(x - 32, 2) + Math.pow(y - 20, 2));
                            
                            if (sunDistance < 8) {
                                // Sun
                                color = `rgb(255, ${Math.floor(220 + sunDistance * 2)}, ${Math.floor(100 + sunDistance * 10)})`;
                            } else if (y < 40) {
                                // Sky with gradient
                                const r = Math.min(255, skyGradient + 50);
                                const g = Math.min(255, skyGradient);
                                const b = Math.min(255, 150 - y * 2);
                                color = `rgb(${r}, ${g}, ${b})`;
                            } else if (y < 45) {
                                // Horizon mountains
                                const mountainHeight = 42 + Math.sin(x * 0.3) * 3;
                                if (y > mountainHeight) {
                                    color = 'rgb(60, 80, 100)';
                                } else {
                                    const r = Math.min(255, skyGradient + 50);
                                    const g = Math.min(255, skyGradient);
                                    const b = Math.min(255, 150 - y * 2);
                                    color = `rgb(${r}, ${g}, ${b})`;
                                }
                            } else {
                                // Water with reflection
                                const waveOffset = Math.sin(x * 0.2 + y * 0.1) * 10;
                                const reflectionY = 80 - y;
                                const reflectionDistance = Math.sqrt(Math.pow(x - 32, 2) + Math.pow(reflectionY - 20, 2));
                                
                                if (reflectionDistance < 8 && Math.random() > 0.3) {
                                    // Sun reflection
                                    color = `rgb(255, ${Math.floor(180 + waveOffset)}, ${Math.floor(100 + waveOffset)})`;
                                } else {
                                    // Water
                                    const waterR = Math.floor(50 + waveOffset);
                                    const waterG = Math.floor(100 + waveOffset);
                                    const waterB = Math.floor(150 + waveOffset);
                                    color = `rgb(${waterR}, ${waterG}, ${waterB})`;
                                }
                            }
                            break;
                            
                        case 'logo':
                            // Create a circular logo with gradients
                            const centerX = 32;
                            const centerY = 32;
                            const distance = Math.sqrt(Math.pow(x - centerX, 2) + Math.pow(y - centerY, 2));
                            
                            if (distance < 20) {
                                // Inside circle - gradient effect
                                const angle = Math.atan2(y - centerY, x - centerX);
                                const r = Math.floor(100 + Math.cos(angle) * 100);
                                const g = Math.floor(100 + Math.sin(angle) * 100);
                                const b = Math.floor(200 - distance * 5);
                                color = `rgb(${r}, ${g}, ${b})`;
                            } else if (distance < 24) {
                                // Border
                                color = 'rgb(50, 50, 150)';
                            } else {
                                // Background
                                color = 'rgb(240, 240, 240)';
                            }
                            break;
                            
                        case 'gradient':
                            // Smooth color gradient
                            const r = Math.floor((x / imageSize) * 255);
                            const g = Math.floor((y / imageSize) * 255);
                            const b = Math.floor(((x + y) / (imageSize * 2)) * 255);
                            color = `rgb(${r}, ${g}, ${b})`;
                            break;
                            
                        case 'text':
                            // Create "GCSE" text
                            color = 'rgb(255, 255, 255)'; // Default white background
                            
                            // Simple bitmap font for GCSE
                            const letters = {
                                'G': [
                                    '01111110',
                                    '11111111',
                                    '11000000',
                                    '11001111',
                                    '11000011',
                                    '11111111',
                                    '01111110'
                                ],
                                'C': [
                                    '01111110',
                                    '11111111',
                                    '11000000',
                                    '11000000',
                                    '11000000',
                                    '11111111',
                                    '01111110'
                                ],
                                'S': [
                                    '01111110',
                                    '11111111',
                                    '11000000',
                                    '01111110',
                                    '00000011',
                                    '11111111',
                                    '01111110'
                                ],
                                'E': [
                                    '11111111',
                                    '11111111',
                                    '11000000',
                                    '11111100',
                                    '11000000',
                                    '11111111',
                                    '11111111'
                                ]
                            };
                            
                            // Position letters
                            const letterWidth = 8;
                            const letterHeight = 7;
                            const startY = 28;
                            const spacing = 2;
                            
                            // Check G
                            if (x >= 10 && x < 10 + letterWidth && y >= startY && y < startY + letterHeight) {
                                const lx = x - 10;
                                const ly = y - startY;
                                if (letters.G[ly] && letters.G[ly][lx] === '1') {
                                    color = 'rgb(30, 60, 114)';
                                }
                            }
                            // Check C
                            else if (x >= 20 && x < 20 + letterWidth && y >= startY && y < startY + letterHeight) {
                                const lx = x - 20;
                                const ly = y - startY;
                                if (letters.C[ly] && letters.C[ly][lx] === '1') {
                                    color = 'rgb(30, 60, 114)';
                                }
                            }
                            // Check S
                            else if (x >= 30 && x < 30 + letterWidth && y >= startY && y < startY + letterHeight) {
                                const lx = x - 30;
                                const ly = y - startY;
                                if (letters.S[ly] && letters.S[ly][lx] === '1') {
                                    color = 'rgb(30, 60, 114)';
                                }
                            }
                            // Check E
                            else if (x >= 40 && x < 40 + letterWidth && y >= startY && y < startY + letterHeight) {
                                const lx = x - 40;
                                const ly = y - startY;
                                if (letters.E[ly] && letters.E[ly][lx] === '1') {
                                    color = 'rgb(30, 60, 114)';
                                }
                            }
                            break;
                    }
                    
                    imageData[y][x] = color;
                }
            }
        }

        function loadHighQualityImage(imageName) {
            currentImage = imageName;
            generateHighQualityImage(imageName);
            drawOriginalImage();
            updateZoom();
        }

        function drawOriginalImage() {
            const canvas = document.getElementById('originalImage');
            const ctx = canvas.getContext('2d');
            const scale = canvas.width / imageSize;
            
            // Disable image smoothing for pixelated effect at high zoom
            ctx.imageSmoothingEnabled = true;
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            for (let y = 0; y < imageSize; y++) {
                for (let x = 0; x < imageSize; x++) {
                    ctx.fillStyle = imageData[y][x];
                    ctx.fillRect(x * scale, y * scale, scale, scale);
                }
            }
        }

        function drawOriginalImage() {
            const canvas = document.getElementById('originalImage');
            const ctx = canvas.getContext('2d');
            const pixelSize = 8;
            
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            for (let row = 0; row < 16; row++) {
                for (let col = 0; col < 16; col++) {
                    ctx.fillStyle = imageData[row][col];
                    ctx.fillRect(col * pixelSize, row * pixelSize, pixelSize, pixelSize);
                    
                    // Draw grid lines
                    ctx.strokeStyle = '#ccc';
                    ctx.lineWidth = 0.5;
                    ctx.strokeRect(col * pixelSize, row * pixelSize, pixelSize, pixelSize);
                }
            }
        }

        function updateZoom() {
            const slider = document.getElementById('zoomSlider');
            const zoomLevel = parseFloat(slider.value);
            document.getElementById('zoomLevel').textContent = zoomLevel + 'x';
            
            const canvas = document.getElementById('zoomedImage');
            const ctx = canvas.getContext('2d');
            
            // Clear canvas
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            // Calculate pixel size based on zoom
            const basePixelSize = 400 / imageSize; // Base size to fit the image
            const pixelSize = basePixelSize * zoomLevel;
            
            // Calculate how many pixels we can show
            const visiblePixels = Math.ceil(400 / pixelSize);
            
            // Center the zoom on the middle of the image
            const startPixel = Math.max(0, Math.floor((imageSize - visiblePixels) / 2));
            
            // Set image rendering based on zoom level
            if (zoomLevel > 3) {
                ctx.imageSmoothingEnabled = false;
                canvas.style.imageRendering = 'pixelated';
            } else {
                ctx.imageSmoothingEnabled = true;
                canvas.style.imageRendering = 'auto';
            }
            
            // Draw the zoomed portion
            for (let y = 0; y < visiblePixels && (startPixel + y) < imageSize; y++) {
                for (let x = 0; x < visiblePixels && (startPixel + x) < imageSize; x++) {
                    const actualY = startPixel + y;
                    const actualX = startPixel + x;
                    
                    ctx.fillStyle = imageData[actualY][actualX];
                    
                    // Calculate position to center the zoomed area
                    const drawX = (x * pixelSize) + (200 - (visiblePixels * pixelSize) / 2);
                    const drawY = (y * pixelSize) + (200 - (visiblePixels * pixelSize) / 2);
                    
                    ctx.fillRect(drawX, drawY, pixelSize, pixelSize);
                    
                    // Draw pixel grid when zoomed in enough
                    if (zoomLevel >= 8) {
                        ctx.strokeStyle = 'rgba(0, 0, 0, 0.2)';
                        ctx.lineWidth = Math.min(2, zoomLevel / 10);
                        ctx.strokeRect(drawX, drawY, pixelSize, pixelSize);
                    }
                }
            }
            
            // Update message based on zoom level
            const message = document.getElementById('zoomMessage');
            if (zoomLevel >= 15) {
                message.textContent = 'Now you can clearly see each individual pixel!';
                message.style.color = '#d32f2f';
            } else if (zoomLevel >= 8) {
                message.textContent = 'The pixels are starting to become visible...';
                message.style.color = '#f57c00';
            } else if (zoomLevel >= 3) {
                message.textContent = 'Notice how the image is getting less smooth?';
                message.style.color = '#388e3c';
            } else {
                message.textContent = 'Use the slider to zoom in and see the pixels!';
                message.style.color = '#666';
            }
        }

        // Initialize scaling demo
        function initScalingDemo() {
            loadHighQualityImage('photo');
            
            const slider = document.getElementById('zoomSlider');
            slider.addEventListener('input', updateZoom);
            
            // Add mouse hover functionality
            const zoomedCanvas = document.getElementById('zoomedImage');
            zoomedCanvas.addEventListener('mousemove', handleMouseHover);
            zoomedCanvas.addEventListener('mouseleave', () => {
                document.getElementById('pixelInfo').innerHTML = '';
            });
        }

        function handleMouseHover(e) {
            const canvas = e.target;
            const rect = canvas.getBoundingClientRect();
            const x = e.clientX - rect.left;
            const y = e.clientY - rect.top;
            const zoomLevel = parseFloat(document.getElementById('zoomSlider').value);
            
            const basePixelSize = 400 / imageSize;
            const pixelSize = basePixelSize * zoomLevel;
            const visiblePixels = Math.ceil(400 / pixelSize);
            const startPixel = Math.max(0, Math.floor((imageSize - visiblePixels) / 2));
            
            const offsetX = 200 - (visiblePixels * pixelSize) / 2;
            const offsetY = 200 - (visiblePixels * pixelSize) / 2;
            
            const pixelX = Math.floor((x - offsetX) / pixelSize) + startPixel;
            const pixelY = Math.floor((y - offsetY) / pixelSize) + startPixel;
            
            if (pixelX >= 0 && pixelX < imageSize && pixelY >= 0 && pixelY < imageSize && 
                pixelX >= startPixel && pixelX < startPixel + visiblePixels &&
                pixelY >= startPixel && pixelY < startPixel + visiblePixels) {
                const color = imageData[pixelY][pixelX];
                // Extract RGB values from the color string
                const rgbMatch = color.match(/rgb\((\d+),\s*(\d+),\s*(\d+)\)/);
                if (rgbMatch) {
                    const r = rgbMatch[1];
                    const g = rgbMatch[2];
                    const b = rgbMatch[3];
                    document.getElementById('pixelInfo').innerHTML = 
                        `- Pixel (${pixelX}, ${pixelY}): <span style="display: inline-block; width: 20px; height: 20px; background: ${color}; border: 1px solid #333; vertical-align: middle;"></span> RGB(${r}, ${g}, ${b})`;
                } else {
                    document.getElementById('pixelInfo').textContent = `- Pixel (${pixelX}, ${pixelY}): ${color}`;
                }
            } else {
                document.getElementById('pixelInfo').textContent = '';
            }
        }

        // Quiz questions
        const quizQuestions = [
            {
                question: "What does 'pixel' stand for?",
                options: [
                    "Picture element",
                    "Pixel element", 
                    "Picture electronic",
                    "Pixel electronic"
                ],
                correct: 0,
                explanation: "Pixel is short for 'picture element' - the smallest unit of a digital image."
            },
            {
                question: "How many colors can each pixel in a bitmap image have?",
                options: [
                    "Multiple colors at once",
                    "Two colors only",
                    "One single color",
                    "Unlimited colors"
                ],
                correct: 2,
                explanation: "Each pixel can only have one single color at a time, which is encoded in binary."
            },
            {
                question: "If white = 000, red = 010, and blue = 100, what would the binary be for a row of pixels: white, white, red, blue?",
                options: [
                    "000000010100",
                    "000010100",
                    "111111010100",
                    "000000010110"
                ],
                correct: 0,
                explanation: "Each color's binary is concatenated: 000 + 000 + 010 + 100 = 000000010100"
            },
            {
                question: "What happens when you scale up a bitmap image?",
                options: [
                    "It becomes clearer",
                    "It stays the same quality",
                    "It becomes blurry/pixelated",
                    "It becomes smaller"
                ],
                correct: 2,
                explanation: "Bitmap images become blurry or pixelated when scaled up because the pixels are simply made larger."
            },
            {
                question: "How are the binary values stored in a bitmap file?",
                options: [
                    "Randomly throughout the file",
                    "In order, row by row",
                    "Only the unique colors are stored",
                    "Compressed into smaller values"
                ],
                correct: 1,
                explanation: "Binary values are stored in order in the file, typically row by row from top to bottom."
            },
            {
                question: "With 3 bits per pixel, how many different colors can be represented?",
                options: [
                    "3 colors",
                    "6 colors",
                    "8 colors",
                    "9 colors"
                ],
                correct: 2,
                explanation: "With 3 bits, you can represent 2¬≥ = 8 different colors (000 to 111 in binary)."
            },
            {
                question: "What type of images are bitmap formats best suited for?",
                options: [
                    "Simple logos",
                    "Text documents",
                    "Photographs",
                    "Line drawings"
                ],
                correct: 2,
                explanation: "Bitmap formats are best for photographs as they can represent complex color variations pixel by pixel."
            },
            {
                question: "If a bitmap image is 4x4 pixels and uses 3 bits per pixel, how many bits in total are needed?",
                options: [
                    "12 bits",
                    "16 bits",
                    "48 bits",
                    "64 bits"
                ],
                correct: 2,
                explanation: "4 √ó 4 = 16 pixels, and 16 √ó 3 bits = 48 bits total."
            }
        ];

        function displayQuiz() {
            const container = document.getElementById('quizContainer');
            container.innerHTML = '';
            
            quizQuestions.forEach((q, index) => {
                const questionDiv = document.createElement('div');
                questionDiv.className = 'question';
                questionDiv.innerHTML = `
                    <h3>Question ${index + 1}: ${q.question}</h3>
                    ${q.options.map((option, i) => `
                        <label class="answer-option">
                            <input type="radio" name="q${index}" value="${i}">
                            ${option}
                        </label>
                    `).join('')}
                    <div id="feedback${index}" class="feedback" style="display: none;"></div>
                `;
                container.appendChild(questionDiv);
            });
        }

        function checkAnswers() {
            let score = 0;
            const button = document.getElementById('checkButton');
            button.disabled = true;
            
            quizQuestions.forEach((q, index) => {
                const selected = document.querySelector(`input[name="q${index}"]:checked`);
                const feedback = document.getElementById(`feedback${index}`);
                
                if (selected) {
                    if (parseInt(selected.value) === q.correct) {
                        score++;
                        feedback.className = 'feedback correct';
                        feedback.textContent = '‚úì Correct! ' + q.explanation;
                    } else {
                        feedback.className = 'feedback incorrect';
                        feedback.textContent = '‚úó Incorrect. ' + q.explanation;
                    }
                } else {
                    feedback.className = 'feedback incorrect';
                    feedback.textContent = '‚úó No answer selected. ' + q.explanation;
                }
                feedback.style.display = 'block';
            });
            
            document.getElementById('scoreDisplay').textContent = 
                `Your Score: ${score}/${quizQuestions.length} (${Math.round(score/quizQuestions.length*100)}%)`;
        }

        function resetQuiz() {
            displayQuiz();
            document.getElementById('scoreDisplay').textContent = '';
            document.getElementById('checkButton').disabled = false;
        }

        // Initialize everything
        initGrid();
        displayQuiz();
        createSmiley();
        initScalingDemo();
    </script>
</body>
</html>