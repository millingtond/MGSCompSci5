<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>GCSE CS Networking Worksheet</title>
    <style>
        /* FONT IMPORTS */
        @import url('https://fonts.googleapis.com/css2?family=Inter:wght@400;600;700&family=Open+Sans&display=swap');
        /* OpenDyslexic can be loaded locally or from a CDN if available. For this example, we'll use Open Sans as a fallback. */
        
        /* CSS VARIABLES FOR THEMES */
        :root {
            --font-main: 'Inter', sans-serif;
            --font-dyslexic: 'Open Sans', sans-serif; /* Fallback for OpenDyslexic */
            --primary-bg: #f0f4f8;
            --secondary-bg: #ffffff;
            --text-color: #1e293b;
            --primary-accent: #3b82f6;
            --primary-accent-hover: #2563eb;
            --secondary-accent: #10b981;
            --secondary-accent-hover: #059669;
            --error-color: #ef4444;
            --warning-color: #f59e0b;
            --success-color: #22c55e;
            --border-color: #cbd5e1;
            --shadow-color: rgba(0, 0, 0, 0.1);
            --font-size: 16px;
        }

        /* HIGH CONTRAST THEME */
        body.high-contrast {
            --primary-bg: #000000;
            --secondary-bg: #1a1a1a;
            --text-color: #ffffff;
            --primary-accent: #38bdf8;
            --primary-accent-hover: #0ea5e9;
            --border-color: #666666;
            --shadow-color: rgba(255, 255, 255, 0.2);
        }
        
        /* DYSLEXIA-FRIENDLY FONT */
        body.dyslexia-friendly {
            --font-main: var(--font-dyslexic);
        }

        /* GENERAL STYLES */
        *, *::before, *::after {
            box-sizing: border-box;
            margin: 0;
            padding: 0;
        }

        body {
            font-family: var(--font-main);
            background-color: var(--primary-bg);
            color: var(--text-color);
            line-height: 1.6;
            font-size: var(--font-size);
            transition: background-color 0.3s, color 0.3s;
            overflow-x: hidden;
        }

        h1, h2, h3, h4 {
            font-weight: 700;
            margin-bottom: 0.75rem;
            color: var(--primary-accent);
        }
        h1 { font-size: 2.2rem; }
        h2 { font-size: 1.8rem; }
        h3 { font-size: 1.5rem; }
        h4 { font-size: 1.2rem; }

        p { margin-bottom: 1rem; }

        button, .btn {
            background-color: var(--primary-accent);
            color: white;
            border: none;
            padding: 12px 24px;
            border-radius: 8px;
            cursor: pointer;
            font-family: var(--font-main);
            font-size: 1rem;
            font-weight: 600;
            transition: background-color 0.2s, transform 0.1s;
            box-shadow: 0 2px 4px var(--shadow-color);
        }
        button:hover, .btn:hover {
            background-color: var(--primary-accent-hover);
            transform: translateY(-2px);
        }
        button:disabled {
            background-color: #94a3b8;
            cursor: not-allowed;
            transform: none;
        }
        button.secondary {
            background-color: var(--secondary-accent);
        }
        button.secondary:hover {
             background-color: var(--secondary-accent-hover);
        }
        button.reset-btn {
            background-color: #64748b;
            margin-top: 1rem;
        }
        button.reset-btn:hover {
            background-color: #475569;
        }

        .container {
            max-width: 1100px;
            margin: 0 auto;
            padding: 20px;
        }

        .worksheet-section {
            display: none;
            background-color: var(--secondary-bg);
            padding: 2rem;
            margin-top: 1rem;
            border-radius: 12px;
            box-shadow: 0 4px 12px var(--shadow-color);
            border: 1px solid var(--border-color);
            min-height: 70vh;
        }

        .worksheet-section.active {
            display: block;
            animation: fadeIn 0.5s ease-in-out;
        }
        
        @keyframes fadeIn {
            from { opacity: 0; transform: translateY(10px); }
            to { opacity: 1; transform: translateY(0); }
        }

        /* HEADER AND NAVIGATION */
        .main-header {
            background-color: var(--secondary-bg);
            padding: 1rem 2rem;
            border-bottom: 1px solid var(--border-color);
            box-shadow: 0 2px 5px var(--shadow-color);
            position: sticky;
            top: 0;
            z-index: 999;
        }
        
        .top-bar {
            display: flex;
            justify-content: space-between;
            align-items: center;
            flex-wrap: wrap;
        }

        .accessibility-controls {
            display: flex;
            gap: 10px;
            align-items: center;
        }

        #quick-nav {
            list-style: none;
            display: flex;
            flex-wrap: wrap;
            gap: 5px;
            padding: 10px 0;
            justify-content: center;
        }
        #quick-nav li button {
            padding: 8px 12px;
            font-size: 0.85rem;
            background-color: transparent;
            color: var(--text-color);
            border: 1px solid var(--border-color);
        }
        #quick-nav li button.active-nav, #quick-nav li button:hover {
            background-color: var(--primary-accent);
            color: white;
            border-color: var(--primary-accent);
        }

        /* GAMIFICATION UI */
        .gamification-hud {
            display: flex;
            align-items: center;
            gap: 20px;
            flex-wrap: wrap;
        }
        .xp-display, .level-display {
            font-weight: 600;
        }
        #xp-bar-container {
            width: 150px;
            height: 20px;
            background-color: #e2e8f0;
            border-radius: 10px;
            overflow: hidden;
            border: 1px solid var(--border-color);
        }
        #xp-bar {
            width: 0%;
            height: 100%;
            background-color: var(--secondary-accent);
            transition: width 0.5s ease-out;
            text-align: center;
            color: white;
            font-size: 0.8rem;
            line-height: 20px;
        }

        /* INTERACTIVE ELEMENTS */
        .interactive-task {
            border: 1px dashed var(--border-color);
            padding: 1.5rem;
            margin-top: 1.5rem;
            border-radius: 8px;
        }
        
        .drop-zone, .drag-item {
            padding: 10px;
            margin: 5px;
            border-radius: 6px;
            border: 2px dashed var(--border-color);
            min-height: 40px;
            cursor: grab;
        }
        .drag-item {
            background-color: #e0e7ff;
        }
        .drop-zone {
            background-color: #f1f5f9;
            transition: background-color 0.2s;
        }
        .drop-zone.over {
            background-color: #c7d2fe;
        }
        .drag-container, .drop-container {
            margin-top: 1rem;
        }
        .drop-container {
            display: flex;
            gap: 1rem;
            justify-content: space-around;
        }
        .drop-column {
            flex: 1;
            padding: 1rem;
            border: 1px solid var(--border-color);
            border-radius: 8px;
        }
        
        .fill-in-blank-options {
            display: flex;
            flex-wrap: wrap;
            gap: 10px;
            margin-bottom: 1rem;
        }
        .fill-in-blank-options button {
            background-color: #d1d5db;
            color: #1f2937;
        }
        .fill-in-blank-options button.selected-option {
            background-color: var(--primary-accent);
            color: white;
        }
        .blank {
            display: inline-block;
            border-bottom: 2px solid var(--primary-accent);
            min-width: 100px;
            text-align: center;
            font-weight: 600;
            padding: 2px 8px;
            color: var(--primary-accent);
            cursor: pointer;
        }
        .blank.active-blank {
            background-color: #e0e7ff;
        }
        
        .quiz-option {
            display: block;
            width: 100%;
            margin-bottom: 0.5rem;
            text-align: left;
            padding: 15px;
            background-color: #f1f5f9;
            color: var(--text-color);
        }
        body.high-contrast .quiz-option {
            background-color: #2a2a2a;
        }
        .quiz-option.selected {
            background-color: var(--primary-accent);
            color: white;
        }
        .quiz-option.correct {
            background-color: var(--success-color);
            color: white;
        }
        .quiz-option.incorrect {
            background-color: var(--error-color);
            color: white;
        }

        /* SIMULATION & CANVAS */
        .simulation-container {
            display: flex;
            align-items: flex-start;
            gap: 2rem;
            flex-wrap: wrap;
        }
        .simulation-canvas {
            border: 2px solid var(--border-color);
            border-radius: 8px;
            background-color: #f8fafc;
        }
        .simulation-controls {
            flex: 1;
        }
        .simulation-controls button {
            margin-right: 10px;
            margin-bottom: 10px;
        }
        #sim-log, #mesh-sim-log {
            background: #e2e8f0;
            padding: 1rem;
            border-radius: 8px;
            min-height: 100px;
            font-family: monospace;
            margin-top: 1rem;
            max-height: 200px;
            overflow-y: auto;
        }
        body.high-contrast #sim-log, body.high-contrast #mesh-sim-log {
            background: #2a2a2a;
        }

        #drawing-canvas {
            border: 2px solid var(--border-color);
            touch-action: none; /* Important for stylus */
            cursor: crosshair;
        }
        
        /* NETWORK DESIGN CHALLENGE */
        #network-design-container {
            display: flex;
            gap: 20px;
        }
        #design-workspace {
            position: relative;
            width: 800px;
            height: 550px; /* Adjust based on image aspect ratio */
            border: 2px solid var(--border-color);
        }
        #design-bg-img {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 1;
        }
        #design-canvas {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 3;
            pointer-events: none; /* Draw through it */
        }
        #design-icons-container {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 2;
        }
        .design-icon {
            position: absolute;
            width: 30px;
            height: 30px;
            border-radius: 5px;
            background-size: contain;
            cursor: grab;
            z-index: 4;
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: bold;
            color: white;
            text-shadow: 1px 1px 2px black;
        }
        .design-icon.computer { background-image: url('data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="%233b82f6"><path d="M20 16H4V6h16v10zm-2-8H6v6h12V8zM2 18h20v2H2v-2z"/></svg>'); }
        .design-icon.switch { background-image: url('data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="%23f59e0b"><path d="M20 13H4v-2h16v2zm-4-6l-4 4-4-4h8zM8 17l4-4 4 4H8z"/></svg>'); }
        #design-palette {
            border-left: 1px solid var(--border-color);
            padding-left: 20px;
            text-align: center;
        }
        #design-palette .design-icon {
            position: static;
            display: inline-block;
            margin: 10px;
        }


        /* WRITING SCORER */
        #writingScorer {
            border: 1px solid var(--border-color);
            padding: 1rem;
            border-radius: 8px;
        }
        #studentAnswer {
            width: 100%;
            padding: 0.5rem;
            border-radius: 8px;
            border: 1px solid var(--border-color);
            font-family: var(--font-main);
            font-size: 1rem;
        }
        #resultsDashboard {
            margin-top: 1rem;
            border-top: 1px solid var(--border-color);
            padding-top: 1rem;
            transition: opacity 0.5s;
        }
        #scoreCircle {
            width: 100px;
            height: 100px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 2rem;
            font-weight: bold;
            margin: 1rem auto;
            color: white;
        }
        #feedbackLists {
            display: flex;
            gap: 2rem;
            margin-top: 1rem;
        }
        #feedbackLists > div { flex: 1; }
        #successList li, #improvementList li {
            padding-left: 1.5rem;
            position: relative;
        }
        #successList li::before {
            content: '✔️';
            position: absolute;
            left: 0;
            color: var(--success-color);
        }
        #improvementList li::before {
            content: '❌';
            position: absolute;
            left: 0;
            color: var(--error-color);
        }

        /* UTILITIES & FEEDBACK */
        .paste-shame {
            color: var(--error-color);
            font-weight: bold;
            display: none;
        }
        
        .section-nav-arrows {
            display: flex;
            justify-content: space-between;
            margin-top: 2rem;
            padding-top: 1rem;
            border-top: 1px solid var(--border-color);
        }
        
        .feedback-button {
            position: fixed;
            bottom: 20px;
            right: 20px;
            background-color: var(--warning-color);
            border-radius: 50%;
            width: 50px;
            height: 50px;
            display: flex;
            align-items: center;
            justify-content: center;
            box-shadow: 0 4px 8px var(--shadow-color);
            z-index: 1000;
        }
        .feedback-button:hover {
            background-color: #d97706;
        }
        
        #feedback-modal {
            display: none;
            position: fixed;
            z-index: 1001;
            left: 0;
            top: 0;
            width: 100%;
            height: 100%;
            overflow: auto;
            background-color: rgba(0,0,0,0.5);
            
        }
        .feedback-modal-content {
            background-color: var(--secondary-bg);
            margin: 15% auto;
            padding: 20px;
            border: 1px solid var(--border-color);
            width: 80%;
            max-width: 500px;
            border-radius: 12px;
            animation: fadeIn 0.3s;
        }
        
        /* ACHIEVEMENT POPUP */
        #achievement-popup {
            position: fixed;
            bottom: -100px;
            left: 50%;
            transform: translateX(-50%);
            background-color: var(--secondary-accent);
            color: white;
            padding: 15px 30px;
            border-radius: 50px;
            box-shadow: 0 5px 15px rgba(0,0,0,0.2);
            z-index: 2000;
            transition: bottom 0.5s ease-in-out;
            font-weight: bold;
            pointer-events: none;
        }
        #achievement-popup.show {
            bottom: 30px;
        }
        .particle {
            position: fixed;
            width: 10px;
            height: 10px;
            border-radius: 50%;
            z-index: 2001;
            background-color: #ffcc00;
            pointer-events: none;
        }

        /* Final Summary */
        .video-placeholder {
            width: 100%;
            aspect-ratio: 16 / 9;
            background-color: #ccc;
            border-radius: 8px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: bold;
            color: #666;
            margin-bottom: 1rem;
        }
        #achievements-list {
            list-style: none;
            padding-left: 0;
        }
        #achievements-list li {
            background: #eef2ff;
            padding: 10px;
            border-radius: 6px;
            margin-bottom: 5px;
        }

    </style>
</head>
<body>

    <header class="main-header">
        <div class="top-bar">
            <h1>GCSE Networking</h1>
            <div class="accessibility-controls">
                <button id="font-size-decrease">-A</button>
                <button id="font-size-increase">+A</button>
                <button id="contrast-toggle">Contrast</button>
                <button id="dyslexia-toggle">Font</button>
            </div>
        </div>
        <div class="gamification-hud">
            <div class="level-display">Level: <span id="level-value">1</span></div>
            <div class="xp-display">XP: <span id="xp-value">0</span></div>
            <div id="xp-bar-container">
                <div id="xp-bar"></div>
            </div>
            <div class="achievements-display">🏆 <span id="achievements-count">0</span></div>
        </div>
        <nav>
            <ul id="quick-nav">
                <!-- Quick nav buttons will be generated by JS -->
            </ul>
        </nav>
    </header>

    <main class="container">
        <!-- Section 1: Starter -->
        <section id="sec-starter" class="worksheet-section">
            <h2>Section 1: Starter Activity</h2>
            <h3>Learning Outcomes</h3>
            <ul>
                <li>Define bandwidth and its units.</li>
                <li>Explain star, mesh, and hybrid network topologies.</li>
                <li>Compare the benefits of different network topologies.</li>
                <li>Apply knowledge to practical and exam-style questions.</li>
            </ul>
            <div class="interactive-task" id="task-starter">
                <h4>Jargon Buster!</h4>
                <p>Let's recap some key terms. Drag the terms on the left to their correct definitions on the right.</p>
                <div class="drop-container">
                    <div id="starter-drag-container" class="drag-container">
                        <!-- Draggable items will be generated by JS -->
                    </div>
                    <div id="starter-drop-container" class="drop-column">
                        <!-- Drop zones will be generated by JS -->
                    </div>
                </div>
                <button onclick="checkStarter()">Check Answers</button>
                <button class="reset-btn" onclick="resetStarter()">Reset</button>
            </div>
        </section>

        <!-- Section 2: Bandwidth & Internet -->
        <section id="sec-bandwidth" class="worksheet-section">
            <h2>Section 2: Bandwidth & The Internet</h2>
            <h3>What is Bandwidth?</h3>
            <p>In networking, <strong>bandwidth</strong> is a measure of the maximum capacity of a communication channel. Think of it like the width of a motorway - a wider motorway can handle more cars at once. Similarly, higher bandwidth allows more data to be transferred at the same time.</p>
            <p>Bandwidth is usually expressed in bits per second (bps), megabits per second (Mbps), or gigabits per second (Gbps).</p>
            <h3>What is the Internet?</h3>
            <p>The <strong>Internet</strong> is a massive, global network of interconnected networks. It connects millions of computers, servers, and other devices across the world, allowing them to exchange information. It is the largest and most well-known example of a Wide Area Network (WAN).</p>
            
            <div class="interactive-task" id="task-bandwidth-fill">
                <h4>Task 2.1: Fill in the Blanks</h4>
                <p>Click a blank space, then click a word from the options below to fill it in.</p>
                <div class="fill-in-blank-options" id="bandwidth-options">
                    <!-- Options generated by JS -->
                </div>
                <p>
                    Bandwidth is the <span class="blank" id="blank-1" data-answer="capacity">...</span> of a communications channel. The Internet is a global network of <span class="blank" id="blank-2" data-answer="networks">...</span>, making it a prime example of a <span class="blank" id="blank-3" data-answer="WAN">...</span>. Higher bandwidth allows more <span class="blank" id="blank-4" data-answer="data">...</span> to be transferred simultaneously.
                </p>
                <button onclick="checkFillInTheBlanks()">Check Answers</button>
                <button class="reset-btn" onclick="resetFillInTheBlanks()">Reset</button>
            </div>
        </section>
        
        <!-- Section 3: Star Topology -->
        <section id="sec-star" class="worksheet-section">
            <h2>Section 3: Star Topology</h2>
            <p>A <strong>star topology</strong> is a common setup for Local Area Networks (LANs). All devices (nodes) on the network are connected to a central device, like a <strong>switch</strong> or a hub. This central node controls all message traffic.</p>
            
            <div class="simulation-container">
                <canvas id="star-sim-canvas" class="simulation-canvas" width="400" height="300"></canvas>
                <div class="simulation-controls">
                    <h4>Simulation: Sending Data</h4>
                    <p>Watch how data travels in a star network.</p>
                    <button id="star-sim-start">Start Simulation</button>
                    <div id="sim-log">Simulation log will appear here...</div>
                    <h4>Reflection Questions</h4>
                    <p>What is the role of the switch in this simulation?</p>
                    <textarea class="reflection-input" data-keywords="central,directs,forwards,address"></textarea>
                    <p>What would happen if the central switch failed?</p>
                    <textarea class="reflection-input" data-keywords="network,fail,down,communicate"></textarea>
                </div>
            </div>

            <div class="interactive-task" id="task-star-benefits">
                <h4>Task 3.1: Star Topology - Benefits & Drawbacks</h4>
                <p>Drag each statement into the correct category.</p>
                <div id="star-drag-items" class="drag-container"></div>
                <div class="drop-container">
                    <div class="drop-column">
                        <h4>Benefits</h4>
                        <div class="drop-zone" id="star-benefits-drop"></div>
                    </div>
                    <div class="drop-column">
                        <h4>Drawbacks</h4>
                        <div class="drop-zone" id="star-drawbacks-drop"></div>
                    </div>
                </div>
                <button onclick="checkStarBenefits()">Check Answers</button>
                <button class="reset-btn" onclick="resetStarBenefits()">Reset</button>
            </div>
        </section>

        <!-- Section 4: Mesh Topology -->
        <section id="sec-mesh" class="worksheet-section">
            <h2>Section 4: Mesh Topology</h2>
            <p>In a <strong>mesh network</strong>, nodes communicate directly with each other, rather than through a central switch. This means there is no central point of control or failure. If one path fails, the network can automatically find another.</p>

            <div class="simulation-container">
                <canvas id="mesh-sim-canvas" class="simulation-canvas" width="400" height="400"></canvas>
                <div class="simulation-controls">
                    <h4>Interactive Simulation: Resilience</h4>
                    <p>Use the buttons to step through the simulation and see how a mesh network adapts to failure.</p>
                    <button id="mesh-sim-step1">1. Send Packet</button>
                    <button id="mesh-sim-step2" disabled>2. Break a Node</button>
                    <button id="mesh-sim-step3" disabled>3. Find New Path</button>
                    <button id="mesh-sim-reset" class="reset-btn">Reset Sim</button>
                    <div id="mesh-sim-log">Simulation log will appear here...</div>
                </div>
            </div>
            
            <h3 style="margin-top: 2rem;">Full vs. Partial Mesh</h3>
            <p>Not all mesh networks are the same. There are two main types:</p>
            <ul>
                <li><strong>Full Mesh:</strong> Every single node is connected to every other node in the network. This offers the highest level of redundancy but is very expensive and complex to set up due to the sheer number of connections required.</li>
                <li><strong>Partial Mesh:</strong> Most nodes are connected to several other nodes, but not necessarily all of them. Critical nodes might have more connections than peripheral ones. This is a more practical and cost-effective approach, providing a good balance of resilience and cost. Most "real-world" mesh networks are partial meshes.</li>
            </ul>

        </section>
        
        <!-- NEW SECTION 5: Network Design Challenge -->
        <section id="sec-design" class="worksheet-section">
            <h2>Section 5: Network Design Challenge</h2>
            <p>Time to put your knowledge into practice! You are the IT technician for this office. Use the components from the palette to build a network based on the requirements.</p>
            <div class="interactive-task" id="task-design-challenge">
                <div id="network-design-container">
                    <div id="design-instructions">
                        <h4>Task Requirements:</h4>
                        <ol>
                            <li>Assume every named member of staff has a computer. Reception has two, and the conference room has one.</li>
                            <li>Connect Reception, Kelly, and Toby's computers to a switch placed outside Toby's office in a star topology.</li>
                            <li>Connect Michael, Liz, and the conference room computer to a second switch outside the conference room, also in a star topology.</li>
                            <li>Connect the two switches together.</li>
                            <li>There is a Server in the small room next to Michael's office. Connect it to the network.</li>
                        </ol>
                        <p><strong>How to use:</strong></p>
                        <ul>
                            <li>Drag icons from the palette on the right onto the floor plan.</li>
                            <li>Click the "Connect" button, then click on two items to draw a cable between them.</li>
                        </ul>
                        <button id="design-connect-btn">Connect</button>
                        <button id="design-show-solution-btn">Show Solution</button>
                        <button class="reset-btn" id="design-reset-btn">Reset Design</button>
                    </div>
                    <div id="design-workspace">
                        <img id="design-bg-img" src="https://i.imgur.com/2YyTqX8.png" alt="Office Floor Plan" />
                        <div id="design-icons-container"></div>
                        <canvas id="design-canvas"></canvas>
                    </div>
                    <div id="design-palette">
                        <h4>Palette</h4>
                        <p>Drag these onto the plan.</p>
                        <div class="design-icon computer" draggable="true" data-type="computer">PC</div>
                        <div class="design-icon switch" draggable="true" data-type="switch">SW</div>
                    </div>
                </div>
            </div>
        </section>

        <!-- Section 6: Compare & Contrast -->
        <section id="sec-compare" class="worksheet-section">
            <h2>Section 6: Compare and Contrast</h2>
            <div class="interactive-task" id="task-venn">
                 <h4>Task 6.1: Topology Venn Diagram</h4>
                <p>Drag the properties into the correct part of the Venn diagram for Star and Mesh topologies.</p>
                <div id="compare-drag-items" class="drag-container"></div>
                <div class="drop-container">
                    <div class="drop-column">
                        <h4>Star Only</h4>
                        <div class="drop-zone" id="venn-star-drop"></div>
                    </div>
                    <div class="drop-column">
                        <h4>Both</h4>
                        <div class="drop-zone" id="venn-both-drop"></div>
                    </div>
                     <div class="drop-column">
                        <h4>Mesh Only</h4>
                        <div class="drop-zone" id="venn-mesh-drop"></div>
                    </div>
                </div>
                <button onclick="checkVenn()">Check Answers</button>
                <button class="reset-btn" onclick="resetVenn()">Reset</button>
            </div>
        </section>

        <!-- Section 7: Quiz -->
        <section id="sec-quiz" class="worksheet-section">
            <h2>Section 7: Check Your Understanding</h2>
            <div class="interactive-task" id="task-final-quiz">
                <div id="final-quiz-container">
                    <!-- Quiz questions generated by JS -->
                </div>
                <button onclick="submitFinalQuiz()">Submit Quiz</button>
                <button class="reset-btn" onclick="resetFinalQuiz()">Reset Quiz</button>
                <div id="final-quiz-results"></div>
            </div>
        </section>

        <!-- Section 8: Exam Practice -->
        <section id="sec-exam" class="worksheet-section">
            <h2>Section 8: Exam Practice</h2>
            <div class="interactive-task" id="task-exam-q1">
                <h4>Question 1 (4 marks)</h4>
                <p>Compare the star and mesh network topologies. In your answer, you should refer to their structure, resilience, and the hardware required.</p>
                <div id="writingScorer">
                    <div>
                        <label for="studentAnswer">Enter your answer:</label>
                        <textarea id="studentAnswer" rows="8"></textarea>
                        <input type="hidden" id="keywords" value="star,mesh,switch,central,node,resilience,reroute,cost,cable">
                        <span class="paste-shame" id="paste-shame-msg">Pasting is disabled. Please type your own answer.</span>
                        <br><br>
                        <button id="analyzeBtn">Check My Writing</button>
                    </div>
                    <div id="resultsDashboard" style="display: none;">
                        <h3>Your Writing Feedback</h3>
                        <div style="display: flex; align-items: center; gap: 2rem;">
                             <div>
                                <p>Overall Score:</p>
                                <div id="scoreCircle">
                                    <span id="scoreValue">0</span>
                                </div>
                            </div>
                            <div id="feedbackLists" style="flex: 1; display: block;">
                                <div>
                                    <h4>Successes:</h4>
                                    <ul id="successList"></ul>
                                </div>
                                <div>
                                    <h4>Areas for Improvement:</h4>
                                    <ul id="improvementList"></ul>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
                <div class="mark-scheme-container" style="margin-top: 2rem;">
                    <label for="predicted-marks">Predict your mark (out of 4):</label>
                    <input type="number" id="predicted-marks" min="0" max="4" style="width: 60px; padding: 5px;">
                    <button id="show-mark-scheme" disabled>Show Mark Scheme</button>
                    <div id="mark-scheme" style="display:none; margin-top: 1rem; background: #f0f4f8; padding: 1rem; border-radius: 8px;">
                        <h4>Mark Scheme</h4>
                        <p>Award one mark for each of the following points, up to a maximum of 4.</p>
                        <ul>
                            <li><strong>Structure:</strong> A star network connects all nodes to a central switch/hub (1), whereas a mesh network connects nodes directly to each other (1).</li>
                            <li><strong>Resilience:</strong> Mesh is more resilient as data can be rerouted if a node fails (1). In a star network, if the central switch fails, the whole network goes down (1).</li>
                            <li><strong>Hardware/Cost:</strong> Star requires a central switch and lots of cabling which can be expensive (1). Mesh can be more cost-effective as it requires less specialized central hardware (1).</li>
                        </ul>
                    </div>
                </div>
            </div>
        </section>
        
        <!-- Section 9: Extension -->
        <section id="sec-extension" class="worksheet-section">
            <h2>Section 9: Extension & Real World</h2>
            
            <h4>Common Mistakes</h4>
            <p>A common mistake is confusing the <strong>Internet</strong> (the physical infrastructure of networks) with the <strong>World Wide Web</strong> (the collection of websites and pages that you access using a browser). The Web runs *on* the Internet, but they are not the same thing!</p>

            <div class="interactive-task" id="task-extension">
                <h4>Extension Activity: Hybrid Topologies</h4>
                <p>Not all networks use a single topology. Some use a 'hybrid' approach. Research what a <strong>'Star-Bus'</strong> topology is. Explain it in the box below and use the canvas to draw a diagram illustrating its structure.</p>
                
                <textarea id="extension-answer" rows="5" placeholder="A Star-Bus topology is..."></textarea>
                <p>Draw your diagram below:</p>
                <canvas id="drawing-canvas" width="500" height="300"></canvas>
                <br>
                <button id="clear-canvas-btn">Clear Canvas</button>
            </div>
        </section>

        <!-- Section 10: Summary -->
        <section id="sec-summary" class="worksheet-section">
            <h2>Section 10: Lesson Summary</h2>
            
            <h4>Key Takeaways</h4>
            <ul>
                <li><strong>Bandwidth:</strong> The maximum data transfer capacity of a network.</li>
                <li><strong>Internet:</strong> A global WAN connecting millions of networks.</li>
                <li><strong>Star Topology:</strong> All devices connect to a central switch. Easy to manage but has a single point of failure.</li>
                <li><strong>Mesh Topology:</strong> Devices connect directly to each other (full or partial). Highly resilient and scalable.</li>
            </ul>

            <h4>Your Progress</h4>
             <div class="gamification-hud" style="flex-direction: column; align-items: flex-start;">
                <p>Final Level: <strong id="summary-level">1</strong></p>
                <p>Final XP: <strong id="summary-xp">0</strong></p>
                <h4>Achievements Unlocked:</h4>
                <ul id="achievements-list">
                    <li>No achievements yet. Keep working!</li>
                </ul>
            </div>

            <h4>Further Learning (Videos)</h4>
            <div style="display: flex; gap: 1rem; flex-wrap: wrap;">
                 <div class="video-placeholder" style="flex:1;">Video Placeholder 1</div>
                 <div class="video-placeholder" style="flex:1;">Video Placeholder 2</div>
            </div>
        </section>

        <!-- Navigation Arrows -->
        <div class="section-nav-arrows">
            <button id="prev-section-btn">⬅️ Previous</button>
            <button id="next-section-btn">Next ➡️</button>
        </div>
    </main>

    <!-- Feedback Button & Modal -->
    <button class="feedback-button" id="feedback-btn" title="Send Feedback">✉️</button>
    <div id="feedback-modal">
        <div class="feedback-modal-content">
            <span id="close-modal" style="float: right; cursor: pointer; font-size: 1.5rem;">&times;</span>
            <h3>Send Feedback</h3>
            <p>Found a bug or have a suggestion? Let us know!</p>
            <textarea id="feedback-text" rows="5" style="width: 100%;" placeholder="Your feedback..."></textarea>
            <button id="send-feedback-btn">Send</button>
        </div>
    </div>
    
    <!-- Achievement Popup -->
    <div id="achievement-popup">
        <span id="achievement-text">Achievement Unlocked!</span>
    </div>

    <script>
        // --- STATE MANAGEMENT ---
        const state = {
            currentSectionIndex: 0,
            xp: 0,
            level: 1,
            xpForNextLevel: 100,
            unlockedAchievements: new Set(),
            tasksCompleted: new Set(),
            fontSize: 16,
            isContrast: false,
            isDyslexia: false,
            sections: [
                { id: 'sec-starter', name: 'Starter' },
                { id: 'sec-bandwidth', name: 'Bandwidth' },
                { id: 'sec-star', name: 'Star' },
                { id: 'sec-mesh', name: 'Mesh' },
                { id: 'sec-design', name: 'Design' },
                { id: 'sec-compare', name: 'Compare' },
                { id: 'sec-quiz', name: 'Quiz' },
                { id: 'sec-exam', name: 'Exam' },
                { id: 'sec-extension', name: 'Extension' },
                { id: 'sec-summary', name: 'Summary' },
            ],
        };

        const achievements = {
            FIRST_CORRECT: { name: 'First Steps!', xp: 10 },
            LEVEL_UP: { name: 'Level Up!', xp: 50 },
            STAR_MASTER: { name: 'Star Gazer!', xp: 30 },
            MESH_MASTER: { name: 'Network Weaver!', xp: 30 },
            NET_DESIGNER: { name: 'IT Technician!', xp: 75},
            TOPOLOGY_EXPERT: { name: 'Topology Expert!', xp: 40 },
            QUIZ_WHIZ: { name: 'Quiz Whiz!', xp: 50 },
            PERFECT_SCORE: { name: 'Flawless Victory!', xp: 100 },
            WRITING_PRO: { name: 'Word Smith!', xp: 40 },
            COMPLETED_ALL: { name: 'Lesson Complete!', xp: 150 },
        };

        // --- DOM ELEMENT SELECTORS ---
        const dom = {
            sections: document.querySelectorAll('.worksheet-section'),
            quickNav: document.getElementById('quick-nav'),
            prevBtn: document.getElementById('prev-section-btn'),
            nextBtn: document.getElementById('next-section-btn'),
            xpValue: document.getElementById('xp-value'),
            levelValue: document.getElementById('level-value'),
            xpBar: document.getElementById('xp-bar'),
            achievementPopup: document.getElementById('achievement-popup'),
            achievementText: document.getElementById('achievement-text'),
            achievementsCount: document.getElementById('achievements-count'),
            studentAnswer: document.getElementById('studentAnswer'),
            predictedMarks: document.getElementById('predicted-marks'),
            showMarkSchemeBtn: document.getElementById('show-mark-scheme'),
        };

        // --- UTILITY & HELPER FUNCTIONS ---
        
        function shuffle(array) {
            for (let i = array.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [array[i], array[j]] = [array[j], array[i]];
            }
            return array;
        }

        function levenshtein(a, b) {
            if (a.length === 0) return b.length;
            if (b.length === 0) return a.length;
            const matrix = [];
            for (let i = 0; i <= b.length; i++) { matrix[i] = [i]; }
            for (let j = 0; j <= a.length; j++) { matrix[0][j] = j; }
            for (let i = 1; i <= b.length; i++) {
                for (let j = 1; j <= a.length; j++) {
                    if (b.charAt(i - 1) == a.charAt(j - 1)) {
                        matrix[i][j] = matrix[i - 1][j - 1];
                    } else {
                        matrix[i][j] = Math.min(matrix[i - 1][j - 1] + 1, Math.min(matrix[i][j - 1] + 1, matrix[i - 1][j] + 1));
                    }
                }
            }
            return matrix[b.length][a.length];
        }

        function checkAnswerSimilarity(userAnswer, correctAnswers) {
            const normalizedUserAnswer = userAnswer.trim().toLowerCase();
            for (const ans of correctAnswers) {
                const normalizedCorrect = ans.toLowerCase();
                if (normalizedUserAnswer === normalizedCorrect) return true;
                if (levenshtein(normalizedUserAnswer, normalizedCorrect) <= 2) return true;
            }
            return false;
        }

        // --- PARTICLE EFFECT ---
        function createParticles(x, y) {
            for (let i = 0; i < 30; i++) {
                const p = document.createElement('div');
                p.classList.add('particle');
                document.body.appendChild(p);
                p.style.left = x + 'px';
                p.style.top = y + 'px';
                const angle = Math.random() * 360;
                const speed = Math.random() * 8 + 4;
                const vx = Math.cos(angle * Math.PI / 180) * speed;
                const vy = Math.sin(angle * Math.PI / 180) * speed;
                p.style.backgroundColor = ['#ffcc00', '#ff6699', '#66ffcc', '#cc66ff'][Math.floor(Math.random() * 4)];

                let t = 0;
                const anim = () => {
                    if (t > 100) {
                        p.remove();
                        return;
                    }
                    p.style.left = (parseFloat(p.style.left) + vx) + 'px';
                    p.style.top = (parseFloat(p.style.top) + vy + t * 0.1) + 'px'; // Add gravity
                    p.style.opacity = 1 - (t / 100);
                    t++;
                    requestAnimationFrame(anim);
                };
                anim();
            }
        }

        // --- GAMIFICATION ---
        function addXp(amount, taskId) {
            if (state.tasksCompleted.has(taskId)) return; 
            state.xp += amount;
            state.tasksCompleted.add(taskId);
            
            if (state.unlockedAchievements.size === 0 && amount > 0) {
                 unlockAchievement('FIRST_CORRECT');
            }

            updateGamificationUI();
            checkLevelUp();
        }

        function unlockAchievement(id) {
            if (!state.unlockedAchievements.has(id)) {
                state.unlockedAchievements.add(id);
                state.xp += achievements[id].xp;
                
                dom.achievementText.textContent = `🏆 ${achievements[id].name}`;
                dom.achievementPopup.classList.add('show');
                const rect = dom.achievementPopup.getBoundingClientRect();
                createParticles(rect.left + rect.width / 2, rect.top + rect.height / 2);
                if (navigator.vibrate) navigator.vibrate([100, 50, 100]);
                
                setTimeout(() => {
                    dom.achievementPopup.classList.remove('show');
                }, 3000);
                updateGamificationUI();
            }
        }
        
        function checkLevelUp() {
            let leveledUp = false;
            while (state.xp >= state.xpForNextLevel && state.level < 5) {
                state.level++;
                state.xp -= state.xpForNextLevel;
                state.xpForNextLevel = Math.floor(state.xpForNextLevel * 1.5);
                leveledUp = true;
            }
            if (leveledUp) {
                unlockAchievement('LEVEL_UP');
            }
            if(state.level >= 5) {
                state.xp = state.xpForNextLevel; // Cap at max level
            }
            updateGamificationUI();
        }

        function updateGamificationUI() {
            dom.xpValue.textContent = state.xp;
            dom.levelValue.textContent = state.level;
            const progress = (state.xp / state.xpForNextLevel) * 100;
            dom.xpBar.style.width = `${Math.min(progress, 100)}%`;
            dom.xpBar.textContent = state.level >= 5 ? 'MAX' : `${state.xp}/${state.xpForNextLevel}`;
            dom.achievementsCount.textContent = state.unlockedAchievements.size;
        }

        // --- NAVIGATION ---
        function showSection(index) {
            if (index < 0 || index >= state.sections.length) return;
            
            state.currentSectionIndex = index;
            dom.sections.forEach((sec, i) => {
                sec.classList.toggle('active', i === index);
            });
            
            dom.prevBtn.disabled = index === 0;
            dom.nextBtn.disabled = index === state.sections.length - 1;

            const navButtons = dom.quickNav.querySelectorAll('button');
            navButtons.forEach((btn, i) => {
                btn.classList.toggle('active-nav', i === index);
            });
            
            if(state.sections[index].id === 'sec-summary') {
                updateSummary();
            }
            if(state.sections[index].id === 'sec-design') {
                initNetworkDesignChallenge(); // Re-init canvas size on show
            }
        }

        function setupNavigation() {
            dom.quickNav.innerHTML = state.sections.map((sec, i) => 
                `<li><button onclick="showSection(${i})">${sec.name}</button></li>`
            ).join('');
            
            dom.prevBtn.addEventListener('click', () => showSection(state.currentSectionIndex - 1));
            dom.nextBtn.addEventListener('click', () => showSection(state.currentSectionIndex + 1));

            let touchstartX = 0;
            let touchendX = 0;
            document.body.addEventListener('touchstart', e => { touchstartX = e.changedTouches[0].screenX }, { passive: true });
            document.body.addEventListener('touchend', e => {
                touchendX = e.changedTouches[0].screenX;
                if (touchendX < touchstartX - 50) { showSection(state.currentSectionIndex + 1); }
                if (touchendX > touchstartX + 50) { showSection(state.currentSectionIndex - 1); }
            }, { passive: true });
        }
        
        // --- ACCESSIBILITY ---
        function setupAccessibility() {
            document.getElementById('contrast-toggle').addEventListener('click', () => {
                document.body.classList.toggle('high-contrast');
            });
            document.getElementById('dyslexia-toggle').addEventListener('click', () => {
                document.body.classList.toggle('dyslexia-friendly');
            });
            document.getElementById('font-size-increase').addEventListener('click', () => {
                state.fontSize = Math.min(24, state.fontSize + 1);
                document.body.style.fontSize = `${state.fontSize}px`;
            });
            document.getElementById('font-size-decrease').addEventListener('click', () => {
                state.fontSize = Math.max(12, state.fontSize - 1);
                document.body.style.fontSize = `${state.fontSize}px`;
            });
        }
        
        // --- PASTE PREVENTION ---
        function preventPasting() {
            const inputs = document.querySelectorAll('textarea, input[type="text"]');
            inputs.forEach(input => {
                input.addEventListener('paste', e => {
                    e.preventDefault();
                    const shameMsg = document.getElementById('paste-shame-msg');
                    if(shameMsg) {
                        shameMsg.style.display = 'inline';
                        setTimeout(() => { shameMsg.style.display = 'none'; }, 3000);
                    }
                });
            });
        }
        
        // --- DRAG AND DROP LOGIC ---
        function setupDragAndDrop(dragContainerId, dropZoneSelector) {
            const dragItems = document.querySelectorAll(`#${dragContainerId} .drag-item`);
            dragItems.forEach(item => {
                item.addEventListener('dragstart', e => {
                    e.dataTransfer.setData('text/plain', e.target.id);
                    setTimeout(() => item.style.visibility = 'hidden', 0);
                });
                item.addEventListener('dragend', e => {
                    setTimeout(() => item.style.visibility = 'visible', 0);
                });
            });

            const dropZones = document.querySelectorAll(dropZoneSelector);
            dropZones.forEach(zone => {
                zone.addEventListener('dragover', e => { e.preventDefault(); zone.classList.add('over'); });
                zone.addEventListener('dragleave', () => zone.classList.remove('over'));
                zone.addEventListener('drop', e => {
                    e.preventDefault();
                    zone.classList.remove('over');
                    const id = e.dataTransfer.getData('text/plain');
                    const draggable = document.getElementById(id);
                    if (draggable && e.target.classList.contains('drop-zone')) {
                        e.target.appendChild(draggable);
                    }
                });
            });
        }

        // --- ACTIVITY 1: STARTER ---
        const starterData = {
            terms: [ { id: 'term-bandwidth', text: 'Bandwidth' }, { id: 'term-internet', text: 'Internet' }, { id: 'term-star', text: 'Star Topology' }, { id: 'term-mesh', text: 'Mesh Topology' } ],
            defs: [ { id: 'def-star', answer: 'term-star', text: 'Uses a central switch or hub.' }, { id: 'def-mesh', answer: 'term-mesh', text: 'Highly resilient, no central point of failure.' }, { id: 'def-bandwidth', answer: 'term-bandwidth', text: 'The maximum capacity of a channel.' }, { id: 'def-internet', answer: 'term-internet', text: 'A global network of networks (WAN).' } ]
        };
        function initStarter() {
            const dragContainer = document.getElementById('starter-drag-container');
            const dropContainer = document.getElementById('starter-drop-container');
            dragContainer.innerHTML = shuffle([...starterData.terms]).map(t => `<div class="drag-item" id="${t.id}" draggable="true">${t.text}</div>`).join('');
            dropContainer.innerHTML = shuffle([...starterData.defs]).map(d => `<div style="display: flex; align-items: center; margin-bottom: 10px;">
                <div class="drop-zone" style="flex-grow: 1; min-height: 42px;" data-answer="${d.answer}"></div>
                <p style="margin-left: 10px; margin-bottom: 0;">${d.text}</p>
            </div>`).join('');
            setupDragAndDrop('starter-drag-container', '#starter-drop-container .drop-zone');
        }
        function checkStarter() {
            let correctCount = 0;
            document.querySelectorAll('#starter-drop-container .drop-zone').forEach(zone => {
                const droppedItem = zone.querySelector('.drag-item');
                zone.style.border = `2px solid var(--error-color)`;
                if (droppedItem && droppedItem.id === zone.dataset.answer) {
                    correctCount++;
                    zone.style.border = `2px solid var(--success-color)`;
                }
            });
            if (correctCount === starterData.terms.length) addXp(40, 'task-starter');
        }
        function resetStarter() { initStarter(); }

        // --- ACTIVITY 2: BANDWIDTH FILL-IN-THE-BLANKS ---
        const bandwidthFillData = {
            options: ['capacity', 'speed', 'networks', 'websites', 'LAN', 'WAN', 'data', 'power', 'protocols', 'servers'],
            blanks: [ { id: 'blank-1', answer: 'capacity' }, { id: 'blank-2', answer: 'networks' }, { id: 'blank-3', answer: 'WAN' }, { id: 'blank-4', answer: 'data' } ]
        };
        function initFillInTheBlanks() {
            document.getElementById('bandwidth-options').innerHTML = shuffle([...bandwidthFillData.options]).map(opt => `<button onclick="selectFillOption(this, '${opt}')">${opt}</button>`).join('');
            document.querySelectorAll('.blank').forEach(blank => {
                 blank.addEventListener('click', () => {
                     document.querySelector('.blank.active-blank')?.classList.remove('active-blank');
                     blank.classList.add('active-blank');
                 });
            });
        }
        window.selectFillOption = function(btn, option) {
            const activeBlank = document.querySelector('.blank.active-blank');
            if(activeBlank){
                activeBlank.textContent = option;
                activeBlank.dataset.selected = option;
                btn.parentElement.querySelectorAll('button').forEach(b => b.classList.remove('selected-option'));
                btn.classList.add('selected-option');
                activeBlank.classList.remove('active-blank');
                const allBlanks = Array.from(document.querySelectorAll('.blank'));
                const currentIndex = allBlanks.indexOf(activeBlank);
                if(currentIndex + 1 < allBlanks.length) allBlanks[currentIndex+1].classList.add('active-blank');
            } else { alert("Please click on a blank space first."); }
        }
        function checkFillInTheBlanks() {
            let correctCount = 0;
            bandwidthFillData.blanks.forEach(data => {
                const el = document.getElementById(data.id);
                const isCorrect = el.dataset.selected === data.answer;
                el.style.color = `var(--${isCorrect ? 'success' : 'error'}-color)`;
                el.style.borderBottomColor = `var(--${isCorrect ? 'success' : 'error'}-color)`;
                if (isCorrect) correctCount++;
            });
            if (correctCount === bandwidthFillData.blanks.length) addXp(40, 'task-bandwidth-fill');
        }
        function resetFillInTheBlanks() {
            bandwidthFillData.blanks.forEach(data => {
                const el = document.getElementById(data.id);
                el.textContent = '...';
                el.dataset.selected = '';
                el.style.color = '';
                el.style.borderBottomColor = '';
            });
        }
        
        // --- ACTIVITY 3: SIMULATIONS (STAR) ---
        // Simplified Star sim, as Mesh is the focus of the update.
        function initStarSimulation() {
            const canvas = document.getElementById('star-sim-canvas');
            const ctx = canvas.getContext('2d');
            const logEl = document.getElementById('sim-log');
            const nodes = [];
            const center = { x: canvas.width / 2, y: canvas.height / 2, isSwitch: true };
            nodes.push(center);
            for (let i = 0; i < 5; i++) {
                const angle = (i / 5) * 2 * Math.PI;
                nodes.push({ x: center.x + 100 * Math.cos(angle), y: center.y + 100 * Math.sin(angle) });
            }
            function draw(packet) {
                ctx.clearRect(0, 0, canvas.width, canvas.height);
                for (let i = 1; i < nodes.length; i++) {
                    ctx.beginPath(); ctx.moveTo(nodes[0].x, nodes[0].y); ctx.lineTo(nodes[i].x, nodes[i].y); ctx.strokeStyle = '#94a3b8'; ctx.stroke();
                }
                nodes.forEach((node, i) => {
                    ctx.beginPath(); ctx.arc(node.x, node.y, node.isSwitch ? 15 : 10, 0, 2 * Math.PI); ctx.fillStyle = node.isSwitch ? '#f59e0b' : '#3b82f6'; ctx.fill();
                });
                if(packet) { ctx.beginPath(); ctx.arc(packet.x, packet.y, 5, 0, 2 * Math.PI); ctx.fillStyle = '#10b981'; ctx.fill(); }
            }
            draw();
            document.getElementById('star-sim-start').onclick = async () => {
                logEl.innerHTML = '';
                const log = msg => logEl.innerHTML += `<p>${msg}</p>`;
                const animate = (from, to) => new Promise(res => {
                    let p = 0;
                    const animLoop = () => {
                        p += 0.05;
                        const packet = { x: from.x + (to.x - from.x) * p, y: from.y + (to.y - from.y) * p };
                        draw(packet);
                        if (p < 1) requestAnimationFrame(animLoop); else { draw(); res(); }
                    };
                    animLoop();
                });
                log('1. C1 wants to send to C4.'); await animate(nodes[1], nodes[0]);
                log('2. Packet arrives at central switch.'); await new Promise(r => setTimeout(r, 500));
                log('3. Switch forwards packet ONLY to C4.'); await animate(nodes[0], nodes[4]);
                log('4. Packet delivered!');
            };
        }

        // --- STAR BENEFITS (UNCHANGED) ---
        const starBenefitData = [
            { id: 'star-d1', text: 'If a node or device fails it does not affect the rest of the network', type: 'benefit' }, { id: 'star-d2', text: 'Fewer data collisions can occur', type: 'benefit' }, { id: 'star-d3', text: 'Easy to add a new node or device', type: 'benefit' }, { id: 'star-d4', text: 'If the central switch fails, the entire network fails', type: 'drawback' }, { id: 'star-d5', text: 'Can be expensive due to length of cable required', type: 'drawback' }
        ];
        function initStarBenefits() {
            document.getElementById('star-drag-items').innerHTML = shuffle([...starBenefitData]).map(d => `<div class="drag-item" id="${d.id}" data-type="${d.type}" draggable="true">${d.text}</div>`).join('');
            setupDragAndDrop('star-drag-items', '#task-star-benefits .drop-zone');
        }
        function checkStarBenefits() {
            let correct = true;
            document.querySelectorAll('#task-star-benefits .drop-zone').forEach(zone => {
                const type = zone.id.includes('benefits') ? 'benefit' : 'drawback';
                let zoneCorrect = zone.children.length > 0;
                Array.from(zone.children).forEach(item => {
                    if(item.dataset.type !== type) zoneCorrect = false;
                });
                zone.style.borderColor = zoneCorrect ? 'var(--success-color)' : 'var(--error-color)';
                if(!zoneCorrect) correct = false;
            });
            if (correct) { addXp(40, 'task-star-benefits'); unlockAchievement('STAR_MASTER'); }
        }
        function resetStarBenefits() {
            initStarBenefits();
            document.querySelectorAll('#task-star-benefits .drop-zone').forEach(z => { z.innerHTML = ''; z.style.borderColor = ''; });
        }


        // --- ACTIVITY 4: NEW MESH SIMULATION ---
        class MeshSimulator {
            constructor() {
                this.canvas = document.getElementById('mesh-sim-canvas');
                this.ctx = this.canvas.getContext('2d');
                this.logEl = document.getElementById('mesh-sim-log');
                this.width = this.canvas.width;
                this.height = this.canvas.height;
                this.reset();
            }

            reset() {
                this.nodes = [];
                this.connections = [];
                this.packet = null;
                this.path = [];
                this.brokenNode = -1;
                this.logEl.innerHTML = '';
                this.createNodes();
                this.createConnections();
                this.draw();
            }

            log(message) {
                this.logEl.innerHTML += `<p>${message}</p>`;
                this.logEl.scrollTop = this.logEl.scrollHeight;
            }

            createNodes() {
                const numNodes = 8;
                const radius = this.height / 2 - 40;
                const center = { x: this.width / 2, y: this.height / 2 };
                for (let i = 0; i < numNodes; i++) {
                    const angle = (i / numNodes) * 2 * Math.PI;
                    this.nodes.push({
                        id: i,
                        x: center.x + radius * Math.cos(angle),
                        y: center.y + radius * Math.sin(angle),
                        active: true
                    });
                }
            }

            createConnections() {
                // Create a partial mesh
                for (let i = 0; i < this.nodes.length; i++) {
                    // Connect to next two nodes and one across
                    this.addConnection(i, (i + 1) % this.nodes.length);
                    this.addConnection(i, (i + 2) % this.nodes.length);
                    this.addConnection(i, (i + 4) % this.nodes.length);
                }
            }
            
            addConnection(node1Id, node2Id) {
                // Avoid duplicate connections
                const exists = this.connections.some(c => (c[0] === node1Id && c[1] === node2Id) || (c[0] === node2Id && c[1] === node1Id));
                if (!exists) {
                    this.connections.push([node1Id, node2Id]);
                }
            }

            // A* pathfinding algorithm
            findPath(startId, endId) {
                let openSet = [startId];
                const cameFrom = {};
                const gScore = {};
                this.nodes.forEach(n => gScore[n.id] = Infinity);
                gScore[startId] = 0;

                const fScore = {};
                this.nodes.forEach(n => fScore[n.id] = Infinity);
                fScore[startId] = this.heuristic(startId, endId);

                while (openSet.length > 0) {
                    let current = openSet.sort((a, b) => fScore[a] - fScore[b])[0];
                    if (current === endId) return this.reconstructPath(cameFrom, current);

                    openSet = openSet.filter(id => id !== current);
                    const neighbors = this.connections
                        .filter(c => c[0] === current || c[1] === current)
                        .map(c => c[0] === current ? c[1] : c[0])
                        .filter(id => this.nodes[id].active);
                    
                    for (const neighborId of neighbors) {
                        const tentative_gScore = gScore[current] + this.dist(current, neighborId);
                        if (tentative_gScore < gScore[neighborId]) {
                            cameFrom[neighborId] = current;
                            gScore[neighborId] = tentative_gScore;
                            fScore[neighborId] = gScore[neighborId] + this.heuristic(neighborId, endId);
                            if (!openSet.includes(neighborId)) {
                                openSet.push(neighborId);
                            }
                        }
                    }
                }
                return null; // No path found
            }

            heuristic = (a, b) => this.dist(a,b);
            dist(a, b) {
                const nodeA = this.nodes[a];
                const nodeB = this.nodes[b];
                return Math.sqrt(Math.pow(nodeA.x - nodeB.x, 2) + Math.pow(nodeA.y - nodeB.y, 2));
            }
            reconstructPath(cameFrom, current) {
                const totalPath = [current];
                while (Object.keys(cameFrom).includes(current.toString())) {
                    current = cameFrom[current];
                    totalPath.unshift(current);
                }
                return totalPath;
            }

            draw() {
                this.ctx.clearRect(0, 0, this.width, this.height);
                // Draw connections
                this.connections.forEach(([n1, n2]) => {
                    this.drawLine(this.nodes[n1], this.nodes[n2], '#94a3b8', 2);
                });

                // Highlight path
                if (this.path.length > 1) {
                    for (let i = 0; i < this.path.length - 1; i++) {
                        this.drawLine(this.nodes[this.path[i]], this.nodes[this.path[i + 1]], 'var(--secondary-accent)', 4);
                    }
                }

                // Draw nodes
                this.nodes.forEach((node) => {
                    this.ctx.beginPath();
                    this.ctx.arc(node.x, node.y, 12, 0, 2 * Math.PI);
                    this.ctx.fillStyle = node.active ? 'var(--primary-accent)' : 'var(--error-color)';
                    this.ctx.fill();
                    this.ctx.strokeStyle = 'white'; this.ctx.lineWidth = 2; this.ctx.stroke();
                    this.ctx.fillStyle = 'white'; this.ctx.textAlign = 'center'; this.ctx.textBaseline = 'middle'; this.ctx.font = 'bold 12px Inter';
                    this.ctx.fillText(node.id, node.x, node.y);
                });
            }

            drawLine(from, to, color, width) {
                this.ctx.beginPath();
                this.ctx.moveTo(from.x, from.y);
                this.ctx.lineTo(to.x, to.y);
                this.ctx.strokeStyle = color;
                this.ctx.lineWidth = width;
                this.ctx.stroke();
            }
        }
        
        function initMeshSimulation() {
            const sim = new MeshSimulator();
            const btn1 = document.getElementById('mesh-sim-step1');
            const btn2 = document.getElementById('mesh-sim-step2');
            const btn3 = document.getElementById('mesh-sim-step3');
            const resetBtn = document.getElementById('mesh-sim-reset');
            
            btn1.onclick = () => {
                sim.log('1. Finding path from node 0 to 4...');
                sim.path = sim.findPath(0, 4);
                if (sim.path) {
                    sim.log(`-> Path found: ${sim.path.join(' -> ')}`);
                    sim.draw();
                    btn1.disabled = true;
                    btn2.disabled = false;
                } else {
                    sim.log('-> No path found!');
                }
            };
            
            btn2.onclick = () => {
                const nodeToBreak = sim.path[1]; // Break the second node in the path
                sim.brokenNode = nodeToBreak;
                sim.nodes[nodeToBreak].active = false;
                sim.log(`2. Oh no! Node ${nodeToBreak} has failed.`);
                sim.draw();
                 btn2.disabled = true;
                 btn3.disabled = false;
            };

            btn3.onclick = () => {
                sim.log('3. Rerouting... Finding new path...');
                sim.path = sim.findPath(0, 4);
                if (sim.path) {
                    sim.log(`-> New path found: ${sim.path.join(' -> ')}`);
                    sim.draw();
                } else {
                    sim.log('-> Could not find an alternative path!');
                }
                btn3.disabled = true;
                addXp(30, 'task-mesh-sim');
                unlockAchievement('MESH_MASTER');
            };

            resetBtn.onclick = () => {
                sim.reset();
                btn1.disabled = false;
                btn2.disabled = true;
                btn3.disabled = true;
            }
        }

        // --- ACTIVITY 5: NETWORK DESIGN CHALLENGE ---
        let designState = {
            icons: [],
            connections: [],
            nextId: 0,
            isConnecting: false,
            connectFrom: null
        };
        function initNetworkDesignChallenge() {
            const workspace = document.getElementById('design-workspace');
            const iconsContainer = document.getElementById('design-icons-container');
            const canvas = document.getElementById('design-canvas');
            const ctx = canvas.getContext('2d');

            // Resize canvas to match workspace
            canvas.width = workspace.clientWidth;
            canvas.height = workspace.clientHeight;

            // Drag from palette
            document.querySelectorAll('#design-palette .design-icon').forEach(icon => {
                icon.addEventListener('dragstart', e => {
                    e.dataTransfer.setData('text/plain', icon.dataset.type);
                });
            });

            workspace.addEventListener('dragover', e => e.preventDefault());

            workspace.addEventListener('drop', e => {
                e.preventDefault();
                const type = e.dataTransfer.getData('text/plain');
                const rect = workspace.getBoundingClientRect();
                const x = e.clientX - rect.left;
                const y = e.clientY - rect.top;
                createDesignIcon(type, x, y);
            });
            
            document.getElementById('design-connect-btn').onclick = () => {
                designState.isConnecting = !designState.isConnecting;
                document.getElementById('design-connect-btn').textContent = designState.isConnecting ? 'Connecting...' : 'Connect';
                document.getElementById('design-connect-btn').classList.toggle('secondary');
                if(!designState.isConnecting) designState.connectFrom = null;
            };

            document.getElementById('design-reset-btn').onclick = () => {
                designState.icons = [];
                designState.connections = [];
                designState.nextId = 0;
                iconsContainer.innerHTML = '';
                redrawDesignCanvas();
            };
            
            document.getElementById('design-show-solution-btn').onclick = () => {
                 // For simplicity, this draws the solution. A real check is complex.
                 unlockAchievement('NET_DESIGNER');
                 addXp(75, 'task-design-challenge');
                 redrawDesignCanvas(); // Clear user lines first
                 const solutionConnections = [
                    [{x:700,y:230}, {x:730,y:400}], [{x:620,y:230}, {x:730,y:400}], [{x:700,y:450}, {x:730,y:400}], // Switch 1
                    [{x:180,y:120}, {x:370,y:120}], [{x:300,y:300}, {x:370,y:120}], [{x:250,y:180}, {x:370,y:120}], // Switch 2
                    [{x:730,y:400}, {x:370,y:120}], // Switches
                    [{x:80,y:120}, {x:370,y:120}] // Server
                 ];
                 solutionConnections.forEach(c => {
                    ctx.beginPath();
                    ctx.moveTo(c[0].x, c[0].y);
                    ctx.lineTo(c[1].x, c[1].y);
                    ctx.strokeStyle = '#8b5cf6';
                    ctx.lineWidth = 4;
                    ctx.lineDashOffset = 0;
                    ctx.setLineDash([5, 5]);
                    ctx.stroke();
                 });
                 ctx.setLineDash([]);
            };
        }
        
        function createDesignIcon(type, x, y) {
            const id = designState.nextId++;
            const icon = document.createElement('div');
            icon.id = `design-icon-${id}`;
            icon.className = `design-icon ${type}`;
            icon.style.left = `${x - 15}px`; // Center icon on cursor
            icon.style.top = `${y - 15}px`;
            
            designState.icons.push({ id, x, y, el: icon });
            
            icon.onclick = () => {
                if(designState.isConnecting) {
                    if(!designState.connectFrom) {
                        designState.connectFrom = icon;
                        icon.style.border = '2px solid var(--secondary-accent)';
                    } else {
                        if (designState.connectFrom !== icon) {
                            designState.connections.push([designState.connectFrom.id, icon.id]);
                            redrawDesignCanvas();
                        }
                        designState.connectFrom.style.border = '';
                        designState.connectFrom = null;
                    }
                }
            };

            document.getElementById('design-icons-container').appendChild(icon);
        }

        function redrawDesignCanvas() {
            const canvas = document.getElementById('design-canvas');
            const ctx = canvas.getContext('2d');
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            designState.connections.forEach(([id1, id2]) => {
                const icon1 = document.getElementById(id1);
                const icon2 = document.getElementById(id2);
                const fromX = parseFloat(icon1.style.left) + 15;
                const fromY = parseFloat(icon1.style.top) + 15;
                const toX = parseFloat(icon2.style.left) + 15;
                const toY = parseFloat(icon2.style.top) + 15;
                
                ctx.beginPath();
                ctx.moveTo(fromX, fromY);
                ctx.lineTo(toX, toY);
                ctx.strokeStyle = '#6366f1';
                ctx.lineWidth = 3;
                ctx.stroke();
            });
        }
        
        // --- ACTIVITY 6: VENN DIAGRAM ---
        const vennData = [
            { id: 'venn-1', text: 'Connects computers in a network', type: 'both' }, { id: 'venn-2', text: 'Has a single point of failure', type: 'star' }, { id: 'venn-3', text: 'Highly resilient to node failure', type: 'mesh' }, { id: 'venn-4', text: 'All traffic goes through a central hub', type: 'star' }, { id: 'venn-5', text: 'Can self-heal and re-route traffic', type: 'mesh' }, { id: 'venn-6', text: 'Easy to add new nodes', type: 'both' },
        ];
        function initVenn() {
            document.getElementById('compare-drag-items').innerHTML = shuffle([...vennData]).map(d => `<div class="drag-item" id="${d.id}" data-type="${d.type}" draggable="true">${d.text}</div>`).join('');
            setupDragAndDrop('compare-drag-items', '#task-venn .drop-zone');
        }
        function checkVenn() {
            let correct = true;
            document.querySelectorAll('#task-venn .drop-zone').forEach(zone => {
                const zoneType = zone.id.split('-')[1]; 
                let isZoneCorrect = true;
                if (zone.children.length === 0) isZoneCorrect = false;
                Array.from(zone.children).forEach(item => {
                    if (item.dataset.type !== zoneType) isZoneCorrect = false;
                });
                zone.style.borderColor = isZoneCorrect ? 'var(--success-color)' : 'var(--error-color)';
                if(!isZoneCorrect) correct = false;
            });
            const allItemsDropped = document.querySelectorAll('#task-venn .drag-item').length === 6;
            if (correct && allItemsDropped) { addXp(50, 'task-venn'); unlockAchievement('TOPOLOGY_EXPERT'); }
        }
        function resetVenn() {
            initVenn();
            document.querySelectorAll('#task-venn .drop-zone').forEach(zone => { zone.innerHTML = ''; zone.style.borderColor = ''; });
        }
        
        // --- ACTIVITY 7: FINAL QUIZ ---
        const finalQuizData = [
            { question: "What is bandwidth typically measured in?", options: ["Hertz (Hz)", "Bytes", "Bits per second (bps)", "Volts"], answer: "Bits per second (bps)" },
            { question: "A star topology's main weakness is its reliance on a central ____.", options: ["client", "server", "switch", "router"], answer: "switch" },
            { question: "True or False: The Internet is an example of a LAN.", options: ["True", "False"], answer: "False" },
            { question: "Which topology is known for being highly scalable and resilient?", options: ["Bus", "Ring", "Star", "Mesh"], answer: "Mesh" },
            { question: "A network that connects devices in a single room or building is a...", options: ["WAN", "LAN", "MAN", "PAN"], answer: "LAN" },
            { question: "In a partial mesh network, are all nodes connected to all other nodes?", options: ["Yes", "No"], answer: "No" }
        ];
        function initFinalQuiz() {
            const container = document.getElementById('final-quiz-container');
            container.innerHTML = shuffle([...finalQuizData]).map((q, i) => {
                const optionsHTML = shuffle([...q.options]).map(opt => `<button class="quiz-option" onclick="selectQuizOption(this, '${q.answer}')">${opt}</button>`).join('');
                return `<div class="quiz-item" id="q-${i}"><h4>${i+1}. ${q.question}</h4><div>${optionsHTML}</div></div>`;
            }).join('');
            document.getElementById('final-quiz-results').innerHTML = '';
        }
        window.selectQuizOption = function(btn, answer) {
            const parent = btn.parentElement;
            parent.querySelectorAll('.quiz-option').forEach(b => b.classList.remove('selected'));
            btn.classList.add('selected');
            parent.dataset.selected = btn.textContent;
            parent.dataset.answer = answer;
        }
        function submitFinalQuiz() {
            let score = 0;
            document.querySelectorAll('.quiz-item div').forEach(item => {
                const isCorrect = item.dataset.selected === item.dataset.answer;
                const selectedBtn = item.querySelector('.selected');
                if (selectedBtn) {
                   selectedBtn.classList.add(isCorrect ? 'correct' : 'incorrect');
                }
                if (isCorrect) score++;
            });
            document.getElementById('final-quiz-results').innerHTML = `<h3>You scored ${score} out of ${finalQuizData.length}!</h3>`;
            if (score > 0) addXp(score * 15, 'task-final-quiz');
            if (score === finalQuizData.length) { unlockAchievement('PERFECT_SCORE'); unlockAchievement('QUIZ_WHIZ'); }
             else if (score > finalQuizData.length / 2) { unlockAchievement('QUIZ_WHIZ'); }
        }
        function resetFinalQuiz() { initFinalQuiz(); }

        // --- ACTIVITY 8: EXAM PRACTICE / WRITING SCORER ---
        // Logic largely unchanged
        function setupWritingScorer() {
            dom.studentAnswer.addEventListener('input', () => {
                dom.showMarkSchemeBtn.disabled = !(dom.studentAnswer.value.trim().length > 50 && dom.predictedMarks.value !== '');
            });
            dom.predictedMarks.addEventListener('input', () => {
                dom.showMarkSchemeBtn.disabled = !(dom.studentAnswer.value.trim().length > 50 && dom.predictedMarks.value !== '');
            });
            dom.showMarkSchemeBtn.addEventListener('click', () => {
                document.getElementById('mark-scheme').style.display = 'block';
            });
            document.getElementById('analyzeBtn').addEventListener('click', analyzeWriting);
        }
        function analyzeWriting() {
            const text = dom.studentAnswer.value;
            if (text.trim().length === 0) return alert("Please enter some text.");
            const keywords = document.getElementById('keywords').value.split(',');
            let score = 100, successes = [], improvements = [];
            const cleanedText = text.trim().replace(/\s+/g, ' ');
            const sentences = cleanedText.match(/[^.!?]+[.!?]+/g) || [cleanedText];

            // Checks
            const firstChar = cleanedText.charAt(0);
            if (firstChar === firstChar.toUpperCase() && isNaN(firstChar)) successes.push('✔️ Started with a capital letter.');
            else { score -= 15; improvements.push('❌ Your answer should begin with a capital letter.'); }

            sentences.forEach(s => {
                const trimmed = s.trim();
                const first = trimmed.charAt(0);
                if (first !== first.toUpperCase() || !isNaN(first)) { score -= 5; improvements.push(`❌ Sentence starting "${trimmed.substring(0,15)}..." needs a capital.`); }
                if (!['.','!','?'].includes(trimmed.slice(-1))) { score -= 10; improvements.push(`❌ Sentence starting "${trimmed.substring(0,15)}..." needs punctuation.`); }
                if (trimmed.split(' ').length < 4) { score -= 10; improvements.push(`❌ Sentence "${trimmed}" seems too short.`); }
            });
            if (/\bi think\b/i.test(cleanedText)) improvements.push('💡 Avoid "I think..." for a more confident tone.');
            
            const foundKWs = keywords.filter(kw => new RegExp(`\\b${kw}\\b`, 'i').test(cleanedText));
            if(foundKWs.length > 0) successes.push(`✔️ Included key terms: ${foundKWs.join(', ')}.`);
            
            score = Math.max(0, score);
            displayResults(score, successes, improvements);
            if(score > 85) { unlockAchievement('WRITING_PRO'); addXp(40, 'task-exam-q1'); }
        }
        function displayResults(score, successes, improvements) {
            const scoreCircle = document.getElementById('scoreCircle');
            document.getElementById('scoreValue').textContent = score;
            if (score > 75) scoreCircle.style.backgroundColor = 'var(--success-color)';
            else if (score > 50) scoreCircle.style.backgroundColor = 'var(--warning-color)';
            else scoreCircle.style.backgroundColor = 'var(--error-color)';
            document.getElementById('successList').innerHTML = successes.map(s => `<li>${s}</li>`).join('');
            document.getElementById('improvementList').innerHTML = improvements.length > 0 ? improvements.map(i => `<li>${i}</li>`).join('') : '<li>Great work! No issues found.</li>';
            document.getElementById('resultsDashboard').style.display = 'block';
        }

        // --- ACTIVITY 9: DRAWING CANVAS (UNCHANGED) ---
        function setupDrawingCanvas() {
            const canvas = document.getElementById('drawing-canvas'), ctx = canvas.getContext('2d');
            let drawing = false;
            const getCoords = e => {
                const r = canvas.getBoundingClientRect(), sX = canvas.width / r.width, sY = canvas.height / r.height;
                const cX = e.touches ? e.touches[0].clientX : e.clientX, cY = e.touches ? e.touches[0].clientY : e.clientY;
                return { x: (cX - r.left) * sX, y: (cY - r.top) * sY };
            }
            const start = e => { drawing = true; const {x,y} = getCoords(e); ctx.beginPath(); ctx.moveTo(x,y); }
            const draw = e => { if(!drawing) return; e.preventDefault(); const {x,y} = getCoords(e); ctx.lineTo(x,y); ctx.stroke(); }
            const stop = () => { drawing = false; ctx.closePath(); }
            canvas.addEventListener('mousedown', start); canvas.addEventListener('mousemove', draw);
            canvas.addEventListener('mouseup', stop); canvas.addEventListener('mouseout', stop);
            canvas.addEventListener('touchstart', start); canvas.addEventListener('touchmove', draw); canvas.addEventListener('touchend', stop);
            document.getElementById('clear-canvas-btn').onclick = () => ctx.clearRect(0,0,canvas.width,canvas.height);
        }
        
        // --- ACTIVITY 10: SUMMARY ---
        function updateSummary() {
            document.getElementById('summary-level').textContent = state.level;
            document.getElementById('summary-xp').textContent = state.xp;
            const list = document.getElementById('achievements-list');
            if(state.unlockedAchievements.size > 0) {
                list.innerHTML = '';
                state.unlockedAchievements.forEach(id => {
                    list.innerHTML += `<li>🏆 ${achievements[id].name}</li>`;
                });
            }
            if (state.tasksCompleted.size >= 8) { unlockAchievement('COMPLETED_ALL'); }
        }
        
        // --- FEEDBACK MODAL ---
        function setupFeedbackModal() {
            const modal = document.getElementById('feedback-modal');
            document.getElementById('feedback-btn').addEventListener('click', () => modal.style.display = 'block');
            document.getElementById('close-modal').addEventListener('click', () => modal.style.display = 'none');
            document.getElementById('send-feedback-btn').addEventListener('click', () => {
                const text = document.getElementById('feedback-text').value;
                if (!text.trim()) return alert('Please enter feedback.');
                const subject = "GCSE Worksheet Feedback";
                const body = `Section: ${state.sections[state.currentSectionIndex].name}\n\n${text}`;
                window.location.href = `mailto:millingtond@mgs.org?subject=${encodeURIComponent(subject)}&body=${encodeURIComponent(body)}`;
                modal.style.display = 'none';
            });
            window.addEventListener('click', e => { if(e.target == modal) modal.style.display = 'none'; });
        }

        // --- INITIALIZATION ---
        function init() {
            setupNavigation();
            setupAccessibility();
            preventPasting();
            
            initStarter();
            initFillInTheBlanks();
            initStarSimulation();
            initStarBenefits();
            initMeshSimulation();
            // Network Design Challenge is initialized on show
            initVenn();
            initFinalQuiz();
            setupWritingScorer();
            setupDrawingCanvas();
            setupFeedbackModal();

            showSection(0);
            updateGamificationUI();
        }

        window.onload = init;
    </script>
</body>
</html>
