<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Image Representation - GCSE Computer Science (Complete)</title>
    <style>
        :root {
            --primary-color: #3498db;
            --secondary-color: #2c3e50;
            --success-color: #27ae60;
            --error-color: #e74c3c;
            --warning-color: #f39c12;
            --light-bg: #f5f5f5;
            --dark-bg: #111;
            --text-light: #fff;
            --text-dark: #333;
            --font-size: 16px;
        }

        * { margin: 0; padding: 0; box-sizing: border-box; }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Arial, sans-serif;
            background: var(--light-bg);
            color: var(--text-dark);
            line-height: 1.6;
            overflow-x: hidden;
            font-size: var(--font-size);
            transition: background 0.3s, color 0.3s;
        }

        /* Accessibility Styles */
        body.high-contrast { background: #000; color: #fff; }
        body.high-contrast .container { background: var(--dark-bg); border: 2px solid #fff; }
        body.high-contrast h1, body.high-contrast h2, body.high-contrast h3 { color: var(--primary-color); }
        @font-face {
            font-family: 'OpenDyslexic';
            src: url('https://cdn.jsdelivr.net/npm/opendyslexic@0.0.3/dist/OpenDyslexic-Regular.woff') format('woff');
        }
        body.dyslexia-font { font-family: 'OpenDyslexic', sans-serif; }

        .container { max-width: 1200px; margin: 20px auto; padding: 20px; background: white; box-shadow: 0 2px 10px rgba(0,0,0,0.1); border-radius: 10px; }
        .nav-container { position: sticky; top: 0; background: var(--secondary-color); color: var(--text-light); padding: 15px; z-index: 1000; box-shadow: 0 2px 5px rgba(0,0,0,0.2); }
        .nav-controls { display: flex; justify-content: space-between; align-items: center; max-width: 1200px; margin: 0 auto; flex-wrap: wrap; }
        .nav-buttons { display: flex; gap: 10px; flex-wrap: wrap; }
        .nav-btn { background: var(--primary-color); color: var(--text-light); border: none; padding: 8px 16px; border-radius: 5px; cursor: pointer; font-size: 14px; transition: all 0.3s; }
        .nav-btn:hover { background: #2980b9; transform: translateY(-2px); }
        .nav-btn.active { background: var(--error-color); }

        /* XP Display */
        .stats-display { display: flex; gap: 20px; align-items: center; flex-wrap: wrap; }
        .xp-display, .level-display { background: rgba(255,255,255,0.2); padding: 10px 20px; border-radius: 20px; font-weight: bold; }
        .xp-bar { width: 200px; height: 20px; background: rgba(255,255,255,0.3); border-radius: 10px; overflow: hidden; margin-top: 5px; }
        .xp-fill { height: 100%; background: linear-gradient(90deg, #f39c12, #e67e22); transition: width 0.5s ease; width: 0%; }

        /* Sections */
        .section { display: none; animation: fadeIn 0.5s ease; }
        .section.active { display: block; }
        @keyframes fadeIn { from { opacity: 0; transform: translateY(20px); } to { opacity: 1; transform: translateY(0); } }
        
        .section-nav-buttons {
            display: flex;
            justify-content: space-between;
            margin-top: 40px;
            border-top: 1px solid #ddd;
            padding-top: 20px;
        }

        h1 { color: var(--secondary-color); margin-bottom: 20px; font-size: 2.5em; text-align: center; }
        h2 { color: #34495e; margin: 30px 0 20px; font-size: 1.8em; }
        h3 { color: #7f8c8d; margin: 20px 0 15px; font-size: 1.3em; }

        .task-container { background: #ecf0f1; padding: 20px; border-radius: 10px; margin: 20px 0; border-left: 5px solid var(--primary-color); }
        input[type="text"], input[type="number"], textarea { padding: 10px; border: 2px solid #bdc3c7; border-radius: 5px; font-size: inherit; width: 100%; max-width: 400px; transition: border-color 0.3s; }
        textarea { margin-bottom: 15px; }
        input[type="text"]:focus, input[type="number"]:focus, textarea:focus { outline: none; border-color: var(--primary-color); }
        
        .btn { background: var(--primary-color); color: var(--text-light); border: none; padding: 10px 20px; border-radius: 5px; cursor: pointer; font-size: 1em; transition: all 0.3s; margin: 5px; }
        .btn:hover { opacity: 0.9; transform: translateY(-2px); box-shadow: 0 2px 5px rgba(0,0,0,0.2); }
        .btn:disabled { background-color: #bdc3c7; cursor: not-allowed; }
        .btn-check { background: var(--success-color); }
        .btn-reset { background: var(--error-color); }
        .btn-hint { background: var(--warning-color); }
        
        .pixel-grid { display: grid; grid-template-columns: repeat(8, 1fr); border: 2px solid var(--secondary-color); margin: 20px auto; background: white; width: clamp(240px, 90vw, 360px); aspect-ratio: 1 / 1; }
        .pixel { border: 1px solid #bdc3c7; cursor: pointer; transition: transform 0.2s; background-color: #FFFFFF; }
        .pixel:hover { transform: scale(1.1); box-shadow: 0 0 10px rgba(0,0,0,0.3); z-index: 10; position: relative; }
        .color-palette { display: flex; gap: 10px; margin: 20px 0; flex-wrap: wrap; }
        .color-option { width: 50px; height: 50px; border: 3px solid transparent; cursor: pointer; transition: all 0.2s; border-radius: 5px; }
        .color-option.selected { border-color: var(--primary-color); box-shadow: 0 0 10px rgba(52, 152, 219, 0.5); }
        .binary-display { font-family: 'Courier New', monospace; font-size: 14px; background: var(--secondary-color); color: #ecf0f1; padding: 15px; border-radius: 5px; margin: 10px 0; word-wrap: break-word; max-height: 200px; overflow-y: auto; }

        /* Drag and Drop */
        .drag-container { display: flex; gap: 20px; margin: 20px 0; flex-wrap: wrap; align-items: start; }
        .drag-items, .drop-targets { flex: 1; min-width: 250px; }
        .draggable { padding: 10px 20px; background: var(--primary-color); color: white; border-radius: 5px; cursor: move; transition: all 0.3s; user-select: none; margin-bottom: 10px; }
        .draggable.dragging { opacity: 0.5; }
        .drop-zone { min-height: 50px; padding: 15px; border: 2px dashed #bdc3c7; border-radius: 5px; text-align: center; transition: all 0.3s; background: white; margin-bottom: 10px; }
        .drop-zone.drag-over { border-color: var(--primary-color); background: #ebf5fb; }
        .drop-zone.correct { border: 2px solid var(--success-color); background: #d5f4e6; color: #155724; }
        .drop-zone p { color: #333; font-style: italic; }

        /* Quiz & Table Styles */
        .quiz-question { margin: 20px 0; padding: 20px; background: #f8f9fa; border-radius: 10px; }
        .quiz-options .quiz-option { display: block; width: 100%; text-align: left; padding: 12px 20px; margin: 8px 0; background: white; border: 2px solid #e0e0e0; border-radius: 8px; cursor: pointer; transition: all 0.3s; }
        .quiz-options .quiz-option.correct { background: var(--success-color); color: white; border-color: #229954; }
        .quiz-options .quiz-option.incorrect { background: var(--error-color); color: white; border-color: #c0392b; }
        
        .interactive-table { width: 100%; border-collapse: collapse; margin: 20px 0; overflow-x: auto; display: block; }
        .interactive-table th, .interactive-table td { border: 1px solid #ddd; padding: 8px; text-align: center; white-space: nowrap; }
        .interactive-table input { width: 90%; min-width: 80px; text-align: center; border: 1px solid #ccc; padding: 5px; }
        #working-out-canvas { border: 2px dashed #ccc; border-radius: 5px; cursor: crosshair; touch-action: none; background-color: #fff; }

        /* Mark Scheme */
        .mark-scheme { display: none; }
        .mark-scheme.visible { display: block; margin-top: 15px; padding: 15px; background: #e8f8f5; border-left: 4px solid var(--success-color); border-radius: 5px; }
        
        .achievement-popup { position: fixed; top: 20px; right: -400px; background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); color: white; padding: 20px 30px; border-radius: 10px; box-shadow: 0 5px 20px rgba(0,0,0,0.3); transition: right 0.5s ease; z-index: 2000; max-width: 350px; }
        .achievement-popup.show { right: 20px; }
        .achievement-title { font-size: 18px; font-weight: bold; }
        
        .rle-row { display: flex; margin: 10px 0; }
        .rle-pixel { width: 30px; height: 30px; border: 1px solid #777; }
        
        /* Color Manipulation Styles */
        .rgb-mixer-container { display: flex; flex-wrap: wrap; gap: 30px; align-items: center; justify-content: center; }
        .rgb-sliders { flex: 2; min-width: 280px; }
        .rgb-sliders .slider-group { margin-bottom: 10px; display: flex; align-items: center; gap: 10px; }
        .rgb-sliders label { width: 50px; }
        .rgb-sliders input[type="range"] { flex-grow: 1; }
        .rgb-sliders .value-display { font-family: 'Courier New', monospace; font-weight: bold; width: 40px; }
        .color-preview { flex: 1; min-width: 150px; text-align: center; }
        .color-preview-box { width: 150px; height: 150px; border: 2px solid var(--secondary-color); border-radius: 10px; transition: background-color 0.2s; margin: 0 auto 10px auto; }
        .color-value-outputs { font-family: 'Courier New', monospace; line-height: 1.4; }
        
        .bit-depth-container { display: flex; flex-wrap: wrap; gap: 20px; justify-content: center; }
        .bit-depth-container img, .bit-depth-container canvas { max-width: 256px; width: 100%; border: 1px solid #ccc; border-radius: 8px; image-rendering: pixelated; }
        .bit-depth-controls { text-align: center; width: 100%; margin-top: 10px; }
        
        /* Floating Buttons and Modals */
        .floating-btn { position: fixed; background: var(--secondary-color); color: white; border: none; padding: 12px; border-radius: 50%; cursor: pointer; box-shadow: 0 2px 10px rgba(0,0,0,0.2); z-index: 998; transition: all 0.3s; font-size: 20px; width: 50px; height: 50px; display: flex; align-items: center; justify-content: center;}
        .floating-btn:hover { transform: translateY(-2px); }
        #accessibility-btn { top: 80px; right: 20px; }
        #feedback-btn { bottom: 20px; right: 20px; background: #9b59b6; }
        
        .accessibility-controls { display: none; position: fixed; top: 140px; right: 20px; background: white; padding: 15px; border-radius: 10px; box-shadow: 0 2px 10px rgba(0,0,0,0.2); z-index: 999; }
        .accessibility-controls.visible { display: block; }
        .accessibility-btn { display: block; width: 100%; margin: 5px 0; padding: 8px 15px; background: var(--secondary-color); color: white; border: none; border-radius: 5px; cursor: pointer; font-size: 14px; }

        .feedback-modal { display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.5); z-index: 3000; align-items: center; justify-content: center; }
        .feedback-modal.visible { display: flex; }
        .feedback-content { background: white; padding: 30px; border-radius: 10px; max-width: 500px; width: 90%; }
        
        #paste-warning { display: none; position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%); background: #e74c3c; color: white; padding: 30px 50px; border-radius: 10px; font-size: 24px; font-weight: bold; z-index: 5000; }
        
        .skip-link { position: absolute; top: -40px; left: 0; background: #000; color: #fff; padding: 8px; text-decoration: none; z-index: 1000; }
        .skip-link:focus { top: 0; }
    </style>
</head>
<body>
    <a href="#main-content" class="skip-link">Skip to main content</a>
    
    <nav class="nav-container" role="navigation">
        <div class="nav-controls">
            <div class="nav-buttons" id="nav-buttons"></div>
            <div class="stats-display">
                <div class="xp-display">XP: <span id="xp-count">0</span><div class="xp-bar"><div class="xp-fill" id="xp-fill"></div></div></div>
                <div class="level-display">Level: <span id="level-count">0</span> / 5</div>
            </div>
        </div>
    </nav>

    <main id="main-content" class="container">
        <section id="starter" class="section active"></section>
        <section id="pixels" class="section"></section>
        <section id="vectors" class="section"></section>
        <section id="properties" class="section"></section>
        <section id="rle" class="section"></section>
        <section id="practice" class="section"></section>
        <section id="summary" class="section"></section>
    </main>

    <!-- Floating Buttons and Modals -->
    <button id="accessibility-btn" class="floating-btn" aria-label="Accessibility Settings">♿</button>
    <div id="accessibility-controls" class="accessibility-controls">
        <button class="accessibility-btn" id="contrast-btn">Toggle High Contrast</button>
        <button class="accessibility-btn" id="dyslexia-btn">Toggle Dyslexia Font</button>
        <button class="accessibility-btn" id="font-increase-btn">Increase Font Size</button>
        <button class="accessibility-btn" id="font-decrease-btn">Decrease Font Size</button>
    </div>

    <button id="feedback-btn" class="floating-btn" aria-label="Submit Feedback">✉️</button>
    <div id="feedback-modal" class="feedback-modal">
        <div class="feedback-content">
            <h2>Submit Feedback</h2>
            <p>Found a bug or have a suggestion? Let us know!</p>
            <textarea id="feedback-text" placeholder="Describe the issue or suggestion..." style="height: 150px; margin-top: 10px;"></textarea>
            <button class="btn btn-check" id="send-feedback-btn">Send Feedback</button>
            <button class="btn btn-reset" id="cancel-feedback-btn">Cancel</button>
        </div>
    </div>

    <div id="paste-warning">🚫 PASTE DETECTED! 🚫<br>Type your own answers!</div>

    <div id="achievement-popup" class="achievement-popup">
        <div id="achievement-title"></div>
        <div id="achievement-desc"></div>
    </div>
    
    <script>
    document.addEventListener('DOMContentLoaded', () => {
        // --- App State ---
        const defaultGameState = {
            xp: 0, level: 0, completedTasks: {}, achievements: {}, hintsUsed: {},
            pixelGrid: Array(64).fill('111'),
        };
        let gameState = {};
        
        const SECTIONS = [
            { id: 'starter', title: 'Starter', generator: generateStarterSection }, 
            { id: 'pixels', title: 'Pixels', generator: generatePixelsSection }, 
            { id: 'vectors', title: 'Vectors', generator: generateVectorsSection },
            { id: 'properties', title: 'Properties', generator: generatePropertiesSection }, 
            { id: 'rle', title: 'RLE', generator: generateRleSection }, 
            { id: 'practice', title: 'Practice', generator: generatePracticeSection }, 
            { id: 'summary', title: 'Summary', generator: generateSummarySection }
        ];

        // --- Constants ---
        const XP_PER_LEVEL = [0, 100, 250, 450, 700, 1000];
        const COLORS = {
            '000':{hex:'#000000',name:'Black',rle:'K'},'001':{hex:'#FF0000',name:'Red',rle:'R'},'010':{hex:'#00FF00',name:'Green',rle:'G'},
            '011':{hex:'#0000FF',name:'Blue',rle:'B'},'100':{hex:'#FFFF00',name:'Yellow',rle:'Y'},'101':{hex:'#FF00FF',name:'Magenta',rle:'M'},
            '110':{hex:'#00FFFF',name:'Cyan',rle:'C'},'111':{hex:'#FFFFFF',name:'White',rle:'W'}
        };
        const ACHIEVEMENTS = {
            firstPixel: { name: "First Pixel", desc: "Draw your first pixel", xp: 20 },
            fileSizeCalc: { name: "Calculation Wiz", desc: "Correctly calculate file sizes", xp: 50 },
            rleMaster: { name: "RLE Master", desc: "Solve an RLE challenge", xp: 50 },
            examReady: { name: "Exam Ready", desc: "Complete a practice question", xp: 40},
            quizChampion: { name: "Quiz Champion", desc: "Complete the final quiz", xp: 60},
            konami: { name: "Retro Gamer", desc: "You found a classic secret!", xp: 100 }
        };
        const KONAMI_CODE = ['ArrowUp', 'ArrowUp', 'ArrowDown', 'ArrowDown', 'ArrowLeft', 'ArrowRight', 'ArrowLeft', 'ArrowRight', 'b', 'a'];

        // --- Interaction Variables ---
        let selectedColor = '111';
        let rleChallenge = { solution: '', data: [] };
        let draggedElement = null;
        let bitDepthSourceImage = null;
        let workingCanvas, workingCtx, isDrawing = false;
        let konamiIndex = 0;
        let touchStartX = 0;

        const DOM = {};

        function main() {
            gameState = JSON.parse(JSON.stringify(defaultGameState));
            cacheDOMElements();
            generateNav();
            initializeAllSections();
            setupEventDelegation();
            updateAllUI();
            randomizeAllQuizOptions();
        }

        function cacheDOMElements() {
            const ids = ['xp-count', 'xp-fill', 'level-count', 'nav-buttons', 'main-content', 'achievement-popup', 'achievement-title', 'achievement-desc', 'accessibility-btn', 'accessibility-controls', 'feedback-btn', 'feedback-modal', 'paste-warning'];
            ids.forEach(id => DOM[id.replace(/-./g, m => m[1].toUpperCase())] = document.getElementById(id));
            SECTIONS.forEach(s => DOM[s.id] = document.getElementById(s.id));
        }

        function initializeAllSections() {
            SECTIONS.forEach(s => s.generator());
            generateColorPalettes();
            drawComparisonImages(1);
            updateRgbMixer();
            const bitDepthImg = document.getElementById('bit-depth-original-img');
            if (bitDepthImg) {
                bitDepthSourceImage = bitDepthImg;
                if (bitDepthSourceImage.complete && bitDepthSourceImage.naturalWidth > 0) {
                    updateBitDepthImage();
                } else {
                    bitDepthSourceImage.onload = () => updateBitDepthImage();
                }
            }
            initWorkingCanvas();
        }

        function generateNav() {
            DOM.navButtons.innerHTML = SECTIONS.map((s, i) =>
                `<button class="nav-btn ${i === 0 ? 'active' : ''}" data-section="${s.id}">${s.title}</button>`
            ).join('');
        }
        
        function updateAllUI() {
            DOM.xpCount.textContent = gameState.xp;
            DOM.levelCount.textContent = gameState.level;
            const currentLevelXP = XP_PER_LEVEL[gameState.level] ?? 0;
            const nextLevelXP = XP_PER_LEVEL[gameState.level + 1] ?? XP_PER_LEVEL[XP_PER_LEVEL.length - 1];
            const progress = nextLevelXP > currentLevelXP ? ((gameState.xp - currentLevelXP) / (nextLevelXP - currentLevelXP)) * 100 : 100;
            DOM.xpFill.style.width = `${Math.min(100, Math.max(0, progress))}%`;
        }
        
        function generateColorPalettes() {
            let paletteHTML = '';
            for(const key in COLORS){
                paletteHTML += `<div class="color-option ${key === selectedColor ? 'selected' : ''}" style="background: ${COLORS[key].hex}" data-binary="${key}"></div>`;
            };
            const pixelPalette = document.getElementById('color-palette');
            if (pixelPalette) pixelPalette.innerHTML = paletteHTML;
        }

        function setupEventDelegation() {
            DOM.navButtons.addEventListener('click', e => {
                if(e.target.matches('.nav-btn')) handleNavClickByButton(e.target);
            });
            
            DOM.mainContent.addEventListener('click', e => {
                const target = e.target;
                if(target.matches('.nav-button-next')) navigateSection(1);
                else if(target.matches('.nav-button-prev')) navigateSection(-1);
                else if(target.matches('.quiz-option')) handleQuizClick(target);
                else if(target.id === 'clear-grid-btn') clearPixelGrid();
                else if(target.id === 'show-binary-btn') generateBinaryRepresentation();
                else if(target.matches('.color-option')) handleColorPaletteClick(target);
                else if(target.id === 'check-table-btn') checkTableAnswers();
                else if(target.id === 'rle-check-btn') checkRLEAnswer();
                else if(target.id === 'rle-new-btn') generateRLEChallenge();
                else if(target.matches('.show-mark-scheme')) showMarkScheme(target);
                else if(target.id === 'clear-working-btn') workingCtx.clearRect(0, 0, workingCanvas.width, workingCanvas.height);
                else if(target.matches('.hint-btn')) showHint(target.dataset.task);
                else if (target.matches('.pixel')) handlePixelGridClick(target);
            });

            DOM.mainContent.addEventListener('input', e => {
                const target = e.target;
                if(target.matches('.rgb-slider')) updateRgbMixer();
                else if(target.id === 'bit-depth-slider') updateBitDepthImage();
                else if(target.matches('#zoom-slider')) drawComparisonImages(parseFloat(target.value));
            });

            const dragAndDropEvents = ['dragstart', 'dragend', 'dragover', 'dragleave', 'drop'];
            dragAndDropEvents.forEach(type => DOM.mainContent.addEventListener(type, handleDragDropEvents));

            const canvasEvents = ['mousedown', 'mousemove', 'mouseup', 'mouseout', 'touchstart', 'touchmove', 'touchend'];
            canvasEvents.forEach(type => DOM.mainContent.addEventListener(type, handleCanvasEvents));

            DOM.accessibilityBtn.addEventListener('click', () => DOM.accessibilityControls.classList.toggle('visible'));
            document.getElementById('contrast-btn').addEventListener('click', () => document.body.classList.toggle('high-contrast'));
            document.getElementById('dyslexia-btn').addEventListener('click', () => document.body.classList.toggle('dyslexia-font'));
            document.getElementById('font-increase-btn').addEventListener('click', () => changeFontSize(1));
            document.getElementById('font-decrease-btn').addEventListener('click', () => changeFontSize(-1));

            DOM.feedbackBtn.addEventListener('click', () => DOM.feedbackModal.classList.add('visible'));
            document.getElementById('cancel-feedback-btn').addEventListener('click', () => DOM.feedbackModal.classList.remove('visible'));
            document.getElementById('send-feedback-btn').addEventListener('click', () => {
                console.log('Feedback submitted:', document.getElementById('feedback-text').value);
                DOM.feedbackModal.classList.remove('visible');
                document.getElementById('feedback-text').value = '';
                alert('Thank you for your feedback!');
            });
            
            document.addEventListener('paste', e => {
                e.preventDefault();
                DOM.pasteWarning.style.display = 'block';
                setTimeout(() => DOM.pasteWarning.style.display = 'none', 2000);
            });
            
            document.addEventListener('keydown', handleKeyPress);
            document.addEventListener('touchstart', e => { touchStartX = e.changedTouches[0].screenX }, {passive: true});
            document.addEventListener('touchend', handleSwipe);
        }
        
        function handleNavClickByButton(button) {
            const sectionId = button.dataset.section;
            const newIndex = SECTIONS.findIndex(s => s.id === sectionId);
            updateSection(newIndex);
        }

        function navigateSection(direction) {
             const activeSection = document.querySelector('.section.active');
             if(!activeSection) return;
             const currentIndex = SECTIONS.findIndex(s => s.id === activeSection.id);
             const newIndex = currentIndex + direction;
             if (newIndex >= 0 && newIndex < SECTIONS.length) {
                 updateSection(newIndex);
             }
        }
        
        function updateSection(newIndex) {
            const currentActiveButton = DOM.navButtons.querySelector('.active');
            if(currentActiveButton) currentActiveButton.classList.remove('active');
            DOM.navButtons.children[newIndex].classList.add('active');

            const currentSection = document.querySelector('.section.active');
            if(currentSection) currentSection.classList.remove('active');
            DOM[SECTIONS[newIndex].id].classList.add('active');
        }

        function handlePixelGridClick(pixel) {
            const index = parseInt(pixel.dataset.index, 10);
            gameState.pixelGrid[index] = selectedColor;
            pixel.style.backgroundColor = COLORS[selectedColor].hex;
            unlockAchievement('firstPixel');
        }
        
        function renderPixelGrid() {
            const grid = document.getElementById('pixel-grid');
            if(grid && gameState.pixelGrid) grid.innerHTML = gameState.pixelGrid.map((color, index) =>
                `<div class="pixel" data-index="${index}" style="background-color: ${COLORS[color].hex};"></div>`
            ).join('');
        }
        
        function clearPixelGrid() {
            gameState.pixelGrid.fill('111');
            renderPixelGrid();
        }

        function handleColorPaletteClick(colorOption) {
            selectedColor = colorOption.dataset.binary;
            document.getElementById('selected-binary').textContent = selectedColor;
            const currentSelected = document.querySelector('#color-palette .selected');
            if(currentSelected) currentSelected.classList.remove('selected');
            colorOption.classList.add('selected');
        }

        function generateBinaryRepresentation() {
            document.getElementById('binary-output').textContent = gameState.pixelGrid.join('');
            addXP(20, 'generate-binary');
        }

        function drawComparisonImages(zoom) {
            const zoomSlider = document.getElementById('zoom-slider');
            if (!zoomSlider) return;
            document.getElementById('zoom-level').textContent = `${zoom}x`;
            const zoomPointX = 70, zoomPointY = 85;
            const bmpCtx = document.getElementById('bitmap-canvas').getContext('2d');
            const dx = zoomPointX - (zoomPointX * zoom);
            const dy = zoomPointY - (zoomPointY * zoom);
            bmpCtx.imageSmoothingEnabled = false;
            bmpCtx.clearRect(0, 0, 200, 200);
            bmpCtx.drawImage(getSmileyImage(), dx, dy, 200 * zoom, 200 * zoom);
            const vecCtx = document.getElementById('vector-canvas').getContext('2d');
            vecCtx.clearRect(0, 0, 200, 200);
            vecCtx.save();
            vecCtx.translate(zoomPointX, zoomPointY);
            vecCtx.scale(zoom, zoom);
            vecCtx.translate(-zoomPointX, -zoomPointY);
            drawVectorSmiley(vecCtx, 100, 80);
            vecCtx.restore();
        }

        function getSmileyImage() {
            const canvas = document.createElement('canvas');
            canvas.width = 40; canvas.height = 40;
            const ctx = canvas.getContext('2d');
            drawVectorSmiley(ctx, 20, 18);
            return canvas;
        }

        function drawVectorSmiley(ctx, x, radius) {
             ctx.fillStyle = '#FFFF00';
             ctx.beginPath(); ctx.arc(x, x, radius, 0, Math.PI * 2); ctx.fill();
             ctx.fillStyle = '#000000';
             ctx.beginPath(); ctx.arc(x-radius*0.4, x-radius*0.2, radius*0.1, 0, Math.PI * 2); ctx.fill();
             ctx.beginPath(); ctx.arc(x+radius*0.4, x-radius*0.2, radius*0.1, 0, Math.PI * 2); ctx.fill();
             ctx.strokeStyle = '#000000'; ctx.lineWidth = radius * 0.1;
             ctx.beginPath(); ctx.arc(x, x, radius*0.7, 0.25 * Math.PI, 0.75 * Math.PI); ctx.stroke();
        }
        
        function handleQuizClick(button) {
            const optionsDiv = button.parentElement;
            if (optionsDiv.dataset.answered) return;
            optionsDiv.dataset.answered = true;
            const isCorrect = button.dataset.correct === 'true';
            button.classList.add(isCorrect ? 'correct' : 'incorrect');
            if (isCorrect) {
                addXP(10, button.closest('[data-task-id]').dataset.taskId);
            } else {
                const correctButton = optionsDiv.querySelector('[data-correct="true"]');
                if (correctButton) correctButton.classList.add('correct');
            }
             if (button.closest('#summary-quiz-container')) {
                const answered = document.querySelectorAll('#summary-quiz-container [data-answered]').length;
                if (answered === 5) unlockAchievement('quizChampion');
            }
        }
        
        function addXP(amount, taskId) {
            if (taskId && gameState.completedTasks[taskId]) return;
            if (taskId) gameState.completedTasks[taskId] = true;
            gameState.xp += amount;
            const newLevel = XP_PER_LEVEL.filter(xp => gameState.xp >= xp).length - 1;
            if (newLevel > gameState.level) gameState.level = newLevel;
            updateAllUI();
        }

        function unlockAchievement(id) {
            if (gameState.achievements[id]) return;
            gameState.achievements[id] = true;
            const ach = ACHIEVEMENTS[id];
            addXP(ach.xp);
            DOM.achievementTitle.textContent = ach.name;
            DOM.achievementDesc.textContent = ach.desc || '';
            DOM.achievementPopup.classList.add('show');
            setTimeout(() => DOM.achievementPopup.classList.remove('show'), 4000);
        }

        function handleDrop(dropZone) {
            if (!draggedElement || !dropZone) return;
            
            const accepts = dropZone.dataset.accepts;
            const answer = draggedElement.dataset.answer;
            if(accepts === answer) {
                dropZone.innerHTML = '';
                dropZone.appendChild(draggedElement);
                dropZone.classList.add('correct');
                addXP(15, `dnd-${answer}`);
            }
        }
        
        function generateSectionNav(index) {
            const prevDisabled = index === 0 ? 'disabled' : '';
            const nextDisabled = index === SECTIONS.length - 1 ? 'disabled' : '';
            return `
                <div class="section-nav-buttons">
                    <button class="btn nav-button-prev" ${prevDisabled}>&larr; Previous</button>
                    <button class="btn nav-button-next" ${nextDisabled}>Next &rarr;</button>
                </div>
            `;
        }
        
        // Section Generation
        function generateStarterSection(){
            DOM.starter.innerHTML = `
            <h1>Image Representation: Starter Activity</h1>
            <div class="task-container">
                <h2>Learning Objectives</h2>
                <ul>
                    <li>Understand the difference between bitmap and vector images.</li>
                    <li>Explain how pixels, resolution, and colour depth affect image quality and file size.</li>
                    <li>Perform calculations for image file sizes.</li>
                    <li>Understand the purpose of metadata and compression.</li>
                </ul>
            </div>
            <div class="task-container">
                <h2>Think About It...</h2>
                <p>A digital image isn't really an 'image' to a computer. It's just a long list of numbers. How do you think these numbers are turned into the pictures we see on screen?</p>
            </div>
            <div class="task-container" id="starter-vocab-dnd"></div>
            <div id="starter-quiz-container" class="task-container"></div>
            ${generateSectionNav(0)}`;
            
            const vocabItems = [ { text: 'Pixel', answer: 'pixel' }, { text: 'Bitmap', answer: 'bitmap' }, { text: 'Resolution', answer: 'resolution' } ];
            vocabItems.sort(() => Math.random() - 0.5);
            document.getElementById('starter-vocab-dnd').innerHTML = `<h2>Vocabulary Match</h2><div class="drag-container"><div class="drag-items">${vocabItems.map(item => `<div class="draggable" draggable="true" data-answer="${item.answer}">${item.text}</div>`).join('')}</div><div class="drop-targets"><h3>Definitions</h3><div class="drop-zone" data-accepts="pixel"><p>The smallest single point of colour in a digital image.</p></div><div class="drop-zone" data-accepts="resolution"><p>The dimensions of an image, measured in pixels (e.g., 1920x1080).</p></div><div class="drop-zone" data-accepts="bitmap"><p>An image made from a grid of pixels.</p></div></div></div>`;
            const questions = [{ q: "Which image type is best for logos and text?", opts: ["Bitmap", "Vector"], correct: 1 },{ q: "If you double the resolution of an image, what happens to the file size (assuming colour depth is the same)?", opts: ["It doubles", "It halves", "It quadruples"], correct: 2 }];
            document.getElementById('starter-quiz-container').innerHTML = `<h2>Quick Knowledge Check</h2>` + questions.map((item, index) => `<div class="quiz-question" data-task-id="starter-q${index}"><h3>${item.q}</h3><div class="quiz-options">${item.opts.map((opt, optIndex) => `<button class="quiz-option" data-correct="${optIndex === item.correct}">${opt}</button>`).join('')}</div></div>`).join('');
        }
        
        function generatePixelsSection(){
            DOM.pixels.innerHTML = `
            <h1>Pixels and Bitmap Images</h1>
            <div class="task-container">
                <h2>Interactive Pixel Art Creator</h2>
                <div style="display: flex; gap: 30px; flex-wrap: wrap; align-items: flex-start;">
                    <div><h3>Color Palette (3-bit colors)</h3><div class="color-palette" id="color-palette"></div><p>Selected color binary: <strong id="selected-binary">111</strong></p></div>
                    <div><h3>Draw Your Image</h3><div class="pixel-grid" id="pixel-grid"></div><button class="btn btn-reset" id="clear-grid-btn">Clear</button><button class="btn" id="show-binary-btn">Show Binary</button></div>
                </div>
                <h3>Binary Representation</h3><div class="binary-display" id="binary-output">Click "Show Binary" to see how your image is stored!</div>
            </div>
             ${generateSectionNav(1)}`;
            renderPixelGrid();
        }

        function generateVectorsSection(){
            DOM.vectors.innerHTML = `
            <h1>Vector Graphics</h1>
             <div class="task-container">
                <h2>Interactive Vector vs Bitmap Comparison</h2>
                <div class="image-comparison" style="display:flex; gap: 20px; flex-wrap: wrap;">
                    <div style="flex:1; min-width: 250px; text-align:center;"><h3>Bitmap Image</h3><canvas id="bitmap-canvas" width="200" height="200"></canvas></div>
                    <div style="flex:1; min-width: 250px; text-align:center;"><h3>Vector Image</h3><canvas id="vector-canvas" width="200" height="200"></canvas></div>
                </div>
                <div class="zoom-controls" style="margin: 10px 0; text-align:center;"><label>Zoom: <span id="zoom-level">1x</span></label><input type="range" id="zoom-slider" min="1" max="10" value="1" step="0.5"></div>
            </div>
            <div class="task-container" id="vector-drag-drop-container"></div>
            ${generateSectionNav(2)}`;
            const items = [{ text: 'Made of pixels', answer: 'bitmap' }, { text: 'Mathematical instructions', answer: 'vector' },{ text: 'Best for photos', answer: 'bitmap' }, { text: 'Best for logos', answer: 'vector' },{ text: 'Loses quality when scaled', answer: 'bitmap' }, { text: 'Scales perfectly', answer: 'vector' }];
            items.sort(() => Math.random() - 0.5);
            document.getElementById('vector-drag-drop-container').innerHTML = `<h2>Task: Match the Properties</h2><div class="drag-container"><div class="drag-items">${items.map(item => `<div class="draggable" draggable="true" data-answer="${item.answer}">${item.text}</div>`).join('')}</div><div class="drop-targets"><h3>Bitmap Images</h3><div class="drop-zone" data-accepts="bitmap"><p>Drop here</p></div><div class="drop-zone" data-accepts="bitmap"><p>Drop here</p></div><div class="drop-zone" data-accepts="bitmap"><p>Drop here</p></div><h3>Vector Images</h3><div class="drop-zone" data-accepts="vector"><p>Drop here</p></div><div class="drop-zone" data-accepts="vector"><p>Drop here</p></div><div class="drop-zone" data-accepts="vector"><p>Drop here</p></div></div></div>`;
        }
        
        function generatePropertiesSection() {
            DOM.properties.innerHTML = `
                <h1>Image Properties</h1>
                <div class="task-container">
                    <h2>Task: Interactive RGB Colour Mixer</h2>
                    <p>Adjust the sliders to see how red, green, and blue light combine to create different colours. This demonstrates how 24-bit colour works.</p>
                    <div class="rgb-mixer-container">
                        <div class="rgb-sliders">
                            <div class="slider-group"><label for="red-slider">Red:</label><span id="red-value" class="value-display">128</span><input type="range" id="red-slider" class="rgb-slider" min="0" max="255" value="128"></div>
                            <div class="slider-group"><label for="green-slider">Green:</label><span id="green-value" class="value-display">128</span><input type="range" id="green-slider" class="rgb-slider" min="0" max="255" value="128"></div>
                            <div class="slider-group"><label for="blue-slider">Blue:</label><span id="blue-value" class="value-display">128</span><input type="range" id="blue-slider" class="rgb-slider" min="0" max="255" value="128"></div>
                        </div>
                        <div class="color-preview">
                            <div id="color-preview-box" class="color-preview-box"></div>
                            <div id="color-value-outputs" class="color-value-outputs"></div>
                        </div>
                    </div>
                </div>
                <div class="task-container">
                    <h2>Task: Interactive Bit Depth Demonstrator</h2>
                    <p>Use the slider to change the bit depth of the image. Notice how the quality degrades as the number of available colours decreases. This is called posterization.</p>
                    <div class="bit-depth-container">
                        <div><h3>Original (24-bit)</h3><img id="bit-depth-original-img" src="https://images.unsplash.com/photo-1542044896530-05d85be9b11a?q=80&w=256&h=256&fit=crop" crossorigin="anonymous" alt="Chameleon"></div>
                        <div><h3>Manipulated Image</h3><canvas id="bit-depth-canvas" width="256" height="256"></canvas></div>
                    </div>
                    <div class="bit-depth-controls">
                        <label for="bit-depth-slider">Bit Depth: <span id="bit-depth-value">8</span> bits (<span id="bit-depth-colors">256</span> colours)</label>
                        <input type="range" id="bit-depth-slider" min="1" max="8" value="8" style="width: 100%;">
                    </div>
                </div>
                <div class="task-container">
                    <h2>Task: File Size Calculation</h2>
                    <p>Calculate the file sizes by filling in the blank cells. Use the canvas below for your working out.</p>
                    <table class="interactive-table" id="file-size-table">
                        <thead><tr><th>Image</th><th>Resolution</th><th>Total Pixels</th><th>Colours</th><th>Colour Depth (bits)</th><th>File Size (bits)</th><th>File Size (Bytes)</th></tr></thead>
                        <tbody>
                            <tr><td>Image 1</td><td>20 x 20</td><td><input type="number" data-row="1" data-col="pixels"></td><td>8</td><td><input type="number" data-row="1" data-col="depth"></td><td><input type="number" data-row="1" data-col="bits"></td><td><input type="number" data-row="1" data-col="bytes"></td></tr>
                            <tr><td>Image 2</td><td>10 x 10</td><td><input type="number" data-row="2" data-col="pixels"></td><td>8</td><td><input type="number" data-row="2" data-col="depth"></td><td><input type="number" data-row="2" data-col="bits"></td><td><input type="number" data-row="2" data-col="bytes"></td></tr>
                            <tr><td>Image 3</td><td>20 x 20</td><td><input type="number" data-row="3" data-col="pixels"></td><td>4</td><td><input type="number" data-row="3" data-col="depth"></td><td><input type="number" data-row="3" data-col="bits"></td><td><input type="number" data-row="3" data-col="bytes"></td></tr>
                        </tbody>
                    </table>
                    <button class="btn btn-check" id="check-table-btn">Check Table Answers</button>
                    <div style="margin-top: 15px;">
                        <h3>Working Out Space</h3>
                        <canvas id="working-out-canvas" width="800" height="200"></canvas>
                        <button class="btn btn-reset" id="clear-working-btn">Clear Working</button>
                    </div>
                </div>
                ${generateSectionNav(3)}
            `;
        }
        
        function updateRgbMixer() {
            const container = document.getElementById('color-preview-box');
            if(!container) return;

            const r = document.getElementById('red-slider').value;
            const g = document.getElementById('green-slider').value;
            const b = document.getElementById('blue-slider').value;
            document.getElementById('red-value').textContent = r;
            document.getElementById('green-value').textContent = g;
            document.getElementById('blue-value').textContent = b;
            container.style.backgroundColor = `rgb(${r}, ${g}, ${b})`;
            
            const toHex = (c) => ('0' + parseInt(c).toString(16)).slice(-2);
            const hex = `#${toHex(r)}${toHex(g)}${toHex(b)}`.toUpperCase();
            
            const r_norm = r / 255, g_norm = g / 255, b_norm = b / 255;
            const max = Math.max(r_norm, g_norm, b_norm), min = Math.min(r_norm, g_norm, b_norm);
            let h, s, l = (max + min) / 2;
            if (max === min) { h = s = 0; } 
            else {
                const d = max - min;
                s = l > 0.5 ? d / (2 - max - min) : d / (max + min);
                switch(max){
                    case r_norm: h = (g_norm - b_norm) / d + (g_norm < b_norm ? 6 : 0); break;
                    case g_norm: h = (b_norm - r_norm) / d + 2; break;
                    case b_norm: h = (r_norm - g_norm) / d + 4; break;
                }
                h /= 6;
            }
            const hsl = `hsl(${Math.round(h * 360)}, ${Math.round(s * 100)}%, ${Math.round(l * 100)}%)`;

            document.getElementById('color-value-outputs').innerHTML = `HEX: ${hex}<br>HSL: ${hsl}`;
        }
        
        function updateBitDepthImage() {
            if (!bitDepthSourceImage || !bitDepthSourceImage.complete || bitDepthSourceImage.width === 0) return;
            const canvas = document.getElementById('bit-depth-canvas');
            if(!canvas) return;
            const ctx = canvas.getContext('2d');
            ctx.drawImage(bitDepthSourceImage, 0, 0, 256, 256);
            
            const imageData = ctx.getImageData(0, 0, 256, 256);
            const data = imageData.data;
            const bitDepth = parseInt(document.getElementById('bit-depth-slider').value, 10);
            
            document.getElementById('bit-depth-value').textContent = bitDepth;
            document.getElementById('bit-depth-colors').textContent = Math.pow(2, bitDepth);

            for(let i=0; i < data.length; i += 4) {
                 if (bitDepth === 1) { 
                    const avg = (data[i] + data[i+1] + data[i+2]) / 3;
                    const color = avg > 127 ? 255 : 0;
                    data[i] = data[i+1] = data[i+2] = color;
                } else {
                    const bitsPerChannel = Math.floor(bitDepth / 3);
                    const remainder = bitDepth % 3;
                    const rBits = bitsPerChannel + (remainder > 0 ? 1 : 0);
                    const gBits = bitsPerChannel + (remainder > 1 ? 1 : 0);
                    const bBits = bitsPerChannel;
                    
                    const rLevels = Math.pow(2, rBits);
                    const gLevels = Math.pow(2, gBits);
                    const bLevels = Math.pow(2, bBits);

                    data[i] = Math.round(data[i] / (256/rLevels)) * (255/(rLevels-1 || 1));
                    data[i+1] = Math.round(data[i+1] / (256/gLevels)) * (255/(gLevels-1 || 1));
                    data[i+2] = Math.round(data[i+2] / (256/bLevels)) * (255/(bLevels-1 || 1));
                }
            }
            ctx.putImageData(imageData, 0, 0);
        }

        function checkTableAnswers() {
            const answers = { '1': { pixels: 400, depth: 3, bits: 1200, bytes: 150 }, '2': { pixels: 100, depth: 3, bits: 300, bytes: 37.5 }, '3': { pixels: 400, depth: 2, bits: 800, bytes: 100 } };
            let allCorrect = true;
            const inputs = document.querySelectorAll('#file-size-table input');
            inputs.forEach(input => {
                const row = input.dataset.row;
                const col = input.dataset.col;
                const userAnswer = parseFloat(input.value);
                const correctAnswer = answers[row][col];
                if (Math.abs(userAnswer - correctAnswer) < 0.01) {
                    input.style.borderColor = 'var(--success-color)';
                } else {
                    input.style.borderColor = 'var(--error-color)';
                    allCorrect = false;
                }
            });
            if (allCorrect) {
                alert('Great job! All calculations are correct.');
                unlockAchievement('fileSizeCalc');
            } else {
                alert('Some calculations are incorrect. Check the highlighted boxes.');
            }
        }
        
        function initWorkingCanvas() {
            workingCanvas = document.getElementById('working-out-canvas');
            if (!workingCanvas) return;
            workingCtx = workingCanvas.getContext('2d');
            workingCtx.strokeStyle = '#333';
            workingCtx.lineWidth = 2;
            workingCtx.lineCap = 'round';
        }

        function startDrawing(e) {
            e.preventDefault();
            const pos = getCanvasPos(e);
            isDrawing = true;
            workingCtx.beginPath();
            workingCtx.moveTo(pos.x, pos.y);
        }

        function draw(e) {
            if (!isDrawing) return;
            e.preventDefault();
            const pos = getCanvasPos(e);
            workingCtx.lineTo(pos.x, pos.y);
            workingCtx.stroke();
        }

        function stopDrawing() { isDrawing = false; }
        
        function getCanvasPos(e) {
            const rect = workingCanvas.getBoundingClientRect();
            const touch = e.touches ? e.touches[0] : e;
            return {
                x: touch.clientX - rect.left,
                y: touch.clientY - rect.top
            };
        }

        function generateRleSection() {
            DOM.rle.innerHTML = `<h1>Compression: Run-Length Encoding (RLE)</h1><div id="rle-container" class="task-container"></div>  ${generateSectionNav(4)}`;
            document.getElementById('rle-container').innerHTML = `
                <h2>Interactive RLE Challenge</h2>
                <p>Enter the correct Run-Length Encoding for the pixel row below (e.g., 4W2B3W).</p>
                <div class="rle-row" id="rle-challenge-row"></div>
                <div>
                    <input type="text" id="rle-answer-input" placeholder="e.g., 5B3W2R">
                    <button class="btn btn-check" id="rle-check-btn">Check</button>
                    <button class="btn" id="rle-new-btn">New Challenge</button>
                    <button class="btn btn-hint hint-btn" data-task="rle">Hint (-5 XP)</button>
                </div>
                <p id="rle-feedback"></p>`;
             generateRLEChallenge();
        }
        
        function generatePracticeSection() {
            DOM.practice.innerHTML = `<h1>Reflection & Practice</h1>
            <div class="task-container">
                <h2>Consolidation Questions</h2>
                <p>Before the exam-style questions, take a moment to reflect on what you've learned. Write a short answer for each of the following prompts.</p>
                <div class="quiz-question">
                    <h3>Metadata Privacy</h3>
                    <p>Most smartphones automatically add GPS coordinates to the metadata of photos. Describe one benefit and one potential danger of this feature.</p>
                    <textarea placeholder="Your answer here..."></textarea>
                </div>
                <div class="quiz-question">
                    <h3>Choosing the Right Tool</h3>
                    <p>You are designing a new app. Would you use a bitmap or a vector image for the app's icon, which needs to be displayed at many different sizes? Justify your choice.</p>
                    <textarea placeholder="Your answer here..."></textarea>
                </div>
                <div class="quiz-question">
                    <h3>The Compression Trade-Off</h3>
                    <p>A news website needs to load articles very quickly, especially on slow mobile connections. Explain why they might choose to use high compression on their images, even if it makes them look slightly worse.</p>
                    <textarea placeholder="Your answer here..."></textarea>
                </div>
            </div>
            <div id="practice-questions-container" class="task-container">
                <h2>Exam-Style Questions</h2>
                <div class="quiz-question">
                    <h3>Question 1 (4 marks)</h3>
                    <p>Explain how a bitmap image is stored.</p>
                    <textarea id="exam-q1-answer" placeholder="Write your answer here..." style="width: 100%; min-height: 100px;"></textarea>
                    <label>Predicted Marks: <input type="number" id="exam-q1-marks" min="0" max="4" style="width: 60px;"></label>
                    <button class="btn btn-check show-mark-scheme" data-question="q1">Show Mark Scheme</button>
                    <div id="mark-scheme-q1" class="mark-scheme"><h4>Mark Scheme:</h4><ul><li>1 mark: Image is made up of / consists of pixels.</li><li>1 mark: Each pixel has one colour.</li><li>1 mark: Colours are encoded as binary numbers.</li><li>1 mark: Binary values stored in order/sequence in the file.</li></ul></div>
                </div>
                <div class="quiz-question">
                    <h3>Question 2 (4 marks)</h3>
                    <p>A photographer has two options for saving a company logo. <strong>Option A:</strong> A 1000x1000 pixel bitmap image. <strong>Option B:</strong> A vector image. The logo will be used on both a small business card and a large promotional banner. Justify which option is more suitable and explain the main drawback of the other option.</p>
                    <textarea id="exam-q2-answer" placeholder="Write your answer here..." style="width: 100%; min-height: 120px;"></textarea>
                    <label>Predicted Marks: <input type="number" id="exam-q2-marks" min="0" max="4" style="width: 60px;"></label>
                    <button class="btn btn-check show-mark-scheme" data-question="q2">Show Mark Scheme</button>
                    <div id="mark-scheme-q2" class="mark-scheme"><h4>Mark Scheme:</h4><ul><li>1 mark: Vector (Option B) is more suitable.</li><li>1 mark: Justification: It can be scaled to any size (for both card and banner) without losing quality.</li><li>1 mark: Drawback of Bitmap (Option A): It will become pixelated/blurry when enlarged for the banner.</li><li>1 mark: Further drawback of bitmap: The file size would be very large and fixed, whereas the vector file would be smaller.</li></ul></div>
                </div>
                 <div class="quiz-question">
                    <h3>Question 3 (3 marks)</h3>
                    <p>An image is 500 pixels wide and 800 pixels high. It uses a 16-bit colour depth. Calculate the file size in kilobytes (KB). You must show your working. (Assume 1 KB = 1000 Bytes).</p>
                    <textarea id="exam-q3-answer" placeholder="Show all your working here..." style="width: 100%; min-height: 120px;"></textarea>
                    <label>Predicted Marks: <input type="number" id="exam-q3-marks" min="0" max="3" style="width: 60px;"></label>
                    <button class="btn btn-check show-mark-scheme" data-question="q3">Show Mark Scheme</button>
                    <div id="mark-scheme-q3" class="mark-scheme"><h4>Mark Scheme:</h4><ul><li>1 mark: Total pixels = 500 * 800 = 400,000 pixels.</li><li>1 mark: Total bits = 400,000 * 16 = 6,400,000 bits. Then, total bytes = 6,400,000 / 8 = 800,000 Bytes.</li><li>1 mark: Total KB = 800,000 / 1000 = 800 KB.</li></ul></div>
                </div>
            </div>
            ${generateSectionNav(5)}
            `;
        }
        
        function showMarkScheme(button) {
            const qId = button.dataset.question;
            const answerText = document.getElementById(`exam-${qId}-answer`).value;
            const marksInput = document.getElementById(`exam-${qId}-marks`).value;

            if (answerText.length < 50 || !marksInput) {
                alert('Please provide a complete answer and predict your marks before viewing the mark scheme.');
                return;
            }

            document.getElementById(`mark-scheme-${qId}`).classList.toggle('visible');
            addXP(20, `practice-${qId}`);
            unlockAchievement('examReady');
        }

        function generateSummarySection() {
            DOM.summary.innerHTML = `<h1>Lesson Summary</h1><div id="summary-quiz-container" class="task-container"></div>${generateSectionNav(6)}`;
            const questions = [
                { q: "How many colors can be represented with 8 bits?", opts: ["128", "256", "512"], correct: 1, taskId: "sum-q1" },
                { q: "Which image type is best for photographs?", opts: ["Bitmap", "Vector"], correct: 0, taskId: "sum-q2" },
                { q: "True or False: Vector images lose quality when enlarged.", opts: ["True", "False"], correct: 1, taskId: "sum-q3" },
                { q: "Which of these increases file size?", opts: ["Higher resolution", "More compression"], correct: 0, taskId: "sum-q4" },
                { q: "What does RLE stand for?", opts: ["Run-Length Encoding", "Real-time Live Encoding"], correct: 0, taskId: "sum-q5" }
            ];
             document.getElementById('summary-quiz-container').innerHTML = '<h2>Final Quiz</h2>' + questions.map(item => `
                <div class="quiz-question" data-task-id="${item.taskId}">
                    <h3>${item.q}</h3>
                    <div class="quiz-options">${item.opts.map((opt, optIndex) => `<button class="quiz-option" data-correct="${optIndex === item.correct}">${opt}</button>`).join('')}</div>
                </div>`).join('');
        }

        function generateRLEChallenge(check) { 
            const rleContainer = document.getElementById('rle-container');
            if (!rleContainer) return;
            const rleInput = rleContainer.querySelector('#rle-answer-input');
            const rleFeedback = rleContainer.querySelector('#rle-feedback');

            if(check){
                 const userAnswer = rleInput.value.toUpperCase().replace(/\s/g, '');
                 if (userAnswer === rleChallenge.solution) {
                    rleFeedback.textContent = 'Correct! Great job!';
                    rleFeedback.style.color = 'var(--success-color)';
                    unlockAchievement('rleMaster');
                } else {
                    rleFeedback.textContent = `Incorrect. The right answer is ${rleChallenge.solution}. Try another!`;
                    rleFeedback.style.color = 'var(--error-color)';
                }
                return;
            }

            const length = 10;
            const colorKeys = Object.keys(COLORS);
            rleChallenge.data = [];
            for (let i = 0; i < length; i++) rleChallenge.data.push(colorKeys[Math.floor(Math.random() * colorKeys.length)]);
            let solution = '';
            let count = 1;
            for (let i = 0; i < rleChallenge.data.length; i++) {
                if (i < length - 1 && rleChallenge.data[i] === rleChallenge.data[i + 1]) count++;
                else {
                    solution += count + COLORS[rleChallenge.data[i]].rle;
                    count = 1;
                }
            }
            rleChallenge.solution = solution;
            rleContainer.querySelector('#rle-challenge-row').innerHTML = rleChallenge.data.map(color => `<div class="rle-pixel" style="background-color: ${COLORS[color].hex};"></div>`).join('');
            rleFeedback.textContent = '';
            rleInput.value = '';
        }
        
        function checkRLEAnswer() {
             const rleContainer = document.getElementById('rle-container');
            if (!rleContainer) return;
            const rleInput = rleContainer.querySelector('#rle-answer-input');
            const rleFeedback = rleContainer.querySelector('#rle-feedback');
            const userAnswer = rleInput.value.toUpperCase().replace(/\s/g, '');
            if (userAnswer === rleChallenge.solution) {
                rleFeedback.textContent = 'Correct! Great job!';
                rleFeedback.style.color = 'var(--success-color)';
                unlockAchievement('rleMaster');
            } else {
                rleFeedback.textContent = `Incorrect. The right answer is ${rleChallenge.solution}. Try another!`;
                rleFeedback.style.color = 'var(--error-color)';
            }
        }
        
        // --- UX and Gamification Functions ---
        function changeFontSize(delta) {
            const currentSize = parseFloat(getComputedStyle(document.body).fontSize);
            document.body.style.fontSize = (currentSize + delta) + 'px';
        }
        
        function showHint(taskType) {
            if (gameState.hintsUsed[taskType]) {
                alert('You have already used the hint for this task.');
                return;
            }
            
            let hintText = '';
            if (taskType === 'rle') {
                hintText = 'Count the number of consecutive pixels of the same colour, then write the count followed by the colour initial (e.g., 3R for three red pixels).';
            }
            
            if (hintText) {
                alert(hintText);
                addXP(-5); // XP penalty
                gameState.hintsUsed[taskType] = true;
            }
        }
        
        function handleKeyPress(e) {
             // Konami Code Logic
            if (e.key === KONAMI_CODE[konamiIndex]) {
                konamiIndex++;
                if (konamiIndex === KONAMI_CODE.length) {
                    unlockAchievement('konami');
                    konamiIndex = 0;
                }
            } else {
                konamiIndex = 0;
            }
            
            // Arrow Key Navigation
            if (e.key === 'ArrowRight') navigateSection(1);
            if (e.key === 'ArrowLeft') navigateSection(-1);
        }
        
        function handleSwipe(e) {
            const touchEndX = e.changedTouches[0].screenX;
            const swipeThreshold = 50;
            if (touchStartX - touchEndX > swipeThreshold) {
                navigateSection(1);
            } else if (touchEndX - touchStartX > swipeThreshold) {
                 navigateSection(-1);
            }
        }
        
        function randomizeAllQuizOptions() {
            document.querySelectorAll('.quiz-options').forEach(container => {
                for (let i = container.children.length; i >= 0; i--) {
                    container.appendChild(container.children[Math.random() * i | 0]);
                }
            });
        }
        
        function handleCanvasEvents(e) {
            if (e.target.id === 'working-out-canvas') {
                switch (e.type) {
                    case 'mousedown': case 'touchstart': startDrawing(e); break;
                    case 'mousemove': case 'touchmove': draw(e); break;
                    case 'mouseup': case 'mouseout': case 'touchend': stopDrawing(); break;
                }
            } else if (e.target.matches('.pixel')) {
                 if (e.type === 'click') handlePixelGridClick(e.target);
            }
        }
        
        function handleDragDropEvents(e) {
             const target = e.target;
             switch (e.type) {
                 case 'dragstart':
                    if (target.matches('.draggable')) {
                        draggedElement = target;
                        setTimeout(() => target.style.opacity = '0.5', 0);
                    }
                    break;
                 case 'dragend':
                    if(draggedElement) draggedElement.style.opacity = '1';
                    draggedElement = null;
                    break;
                 case 'dragover':
                    if (target.closest('.drop-zone')) {
                        e.preventDefault();
                        target.closest('.drop-zone').classList.add('drag-over');
                    }
                    break;
                case 'dragleave':
                     if (target.closest('.drop-zone')) target.closest('.drop-zone').classList.remove('drag-over');
                     break;
                case 'drop':
                    const dropZone = target.closest('.drop-zone');
                    if (dropZone) {
                        e.preventDefault();
                        dropZone.classList.remove('drag-over');
                        handleDrop(dropZone);
                    }
                    break;
             }
        }

        main();
    });
    </script>
</body>
</html>
