<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>OS Memory Management Simulation - GCSE Computer Science</title>
    <style>
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            max-width: 1200px;
            margin: 0 auto;
            padding: 20px;
            background: linear-gradient(135deg, #1e3c72 0%, #2a5298 100%);
            color: #333;
            min-height: 100vh;
        }
        
        .container {
            background: rgba(255, 255, 255, 0.95);
            border-radius: 20px;
            padding: 30px;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.3);
        }
        
        h1 {
            color: #1e3c72;
            text-align: center;
            margin-bottom: 10px;
            font-size: 2.5em;
            text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.1);
        }
        
        .subtitle {
            text-align: center;
            color: #666;
            margin-bottom: 30px;
            font-size: 1.1em;
        }
        
        .simulation-area {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 20px;
            margin-bottom: 30px;
        }
        
        .memory-display {
            background: #f0f4f8;
            border-radius: 10px;
            padding: 20px;
            position: relative;
            height: 450px;
            overflow: hidden;
            box-shadow: inset 0 2px 4px rgba(0, 0, 0, 0.1);
        }
        
        .memory-title {
            font-weight: bold;
            color: #2a5298;
            margin-bottom: 15px;
            font-size: 1.2em;
            position: relative;
            z-index: 10;
            background: #f0f4f8;
            padding-bottom: 10px;
        }
        
        .memory-block {
            position: absolute;
            left: 10px;
            right: 10px;
            background: #e0e0e0;
            border: 2px solid #999;
            border-radius: 5px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: bold;
            transition: all 0.5s ease;
            cursor: pointer;
            overflow: hidden;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.2);
        }
        
        .memory-block:hover {
            transform: scale(1.02);
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.3);
        }
        
        .memory-block.allocated {
            /* No animation */
        }
        
        .memory-usage-bar {
            height: 30px;
            background: #e0e0e0;
            border-radius: 15px;
            overflow: hidden;
            margin: 20px 0;
            position: relative;
            box-shadow: inset 0 2px 4px rgba(0, 0, 0, 0.1);
        }
        
        .memory-usage-fill {
            height: 100%;
            background: linear-gradient(90deg, #4CAF50 0%, #FFC107 60%, #F44336 90%);
            transition: width 0.5s ease;
            display: flex;
            align-items: center;
            justify-content: center;
            color: white;
            font-weight: bold;
            text-shadow: 1px 1px 2px rgba(0, 0, 0, 0.5);
        }
        
        .warning {
            background: #fff3cd;
            border: 1px solid #ffeeba;
            color: #856404;
            padding: 10px;
            border-radius: 5px;
            margin: 10px 0;
            display: none;
            animation: shake 0.5s;
        }
        
        @keyframes shake {
            0%, 100% { transform: translateX(0); }
            25% { transform: translateX(-5px); }
            75% { transform: translateX(5px); }
        }
        
        @keyframes allocate {
            0% { transform: scale(0); opacity: 0; }
            50% { transform: scale(1.1); }
            100% { transform: scale(1); opacity: 1; }
        }
        
        .process-list {
            background: #f0f4f8;
            border-radius: 10px;
            padding: 20px;
            box-shadow: inset 0 2px 4px rgba(0, 0, 0, 0.1);
        }
        
        .process-item {
            background: white;
            padding: 15px;
            margin: 10px 0;
            border-radius: 8px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
            transition: all 0.3s ease;
        }
        
        .process-item:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.15);
        }
        
        .process-name {
            font-weight: bold;
            display: flex;
            align-items: center;
            gap: 12px;
            font-size: 1.1em;
        }
        
        .process-status {
            width: 10px;
            height: 10px;
            border-radius: 50%;
            display: inline-block;
        }
        
        .controls {
            display: flex;
            gap: 10px;
            margin-bottom: 30px;
            flex-wrap: wrap;
            justify-content: center;
        }
        
        button {
            padding: 12px 24px;
            font-size: 16px;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.3s ease;
            font-weight: 600;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }
        
        .btn-primary {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
        }
        
        .btn-primary:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(102, 126, 234, 0.4);
        }
        
        .btn-secondary {
            background: linear-gradient(135deg, #f093fb 0%, #f5576c 100%);
            color: white;
        }
        
        .btn-secondary:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(245, 87, 108, 0.4);
        }
        
        .btn-reset {
            background: linear-gradient(135deg, #fa709a 0%, #fee140 100%);
            color: #333;
        }
        
        .btn-reset:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(250, 112, 154, 0.4);
        }
        
        .info-panel {
            background: linear-gradient(135deg, #f5f7fa 0%, #c3cfe2 100%);
            padding: 20px;
            border-radius: 10px;
            margin-bottom: 30px;
            box-shadow: 0 3px 10px rgba(0, 0, 0, 0.1);
        }
        
        .stats {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
            gap: 15px;
            margin-top: 15px;
        }
        
        .stat-item {
            background: white;
            padding: 15px;
            border-radius: 8px;
            text-align: center;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
        }
        
        .stat-value {
            font-size: 24px;
            font-weight: bold;
            color: #2a5298;
        }
        
        .stat-label {
            font-size: 14px;
            color: #666;
            margin-top: 5px;
        }
        
        .quiz-section {
            background: linear-gradient(135deg, #ffecd2 0%, #fcb69f 100%);
            padding: 30px;
            border-radius: 10px;
            margin-top: 30px;
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.1);
        }
        
        .quiz-question {
            font-size: 18px;
            margin-bottom: 20px;
            color: #333;
            font-weight: 600;
        }
        
        .quiz-options {
            display: flex;
            flex-direction: column;
            gap: 10px;
        }
        
        .quiz-option {
            background: white;
            padding: 15px;
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.3s ease;
            border: 2px solid transparent;
        }
        
        .quiz-option:hover {
            background: #f0f4f8;
            transform: translateX(10px);
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
        }
        
        .quiz-option.selected {
            border-color: #2a5298;
            background: #e8f0fe;
            transform: translateX(10px);
        }
        
        .quiz-option.correct {
            background: #d4edda;
            border-color: #28a745;
            border-width: 4px;
        }
        
        .quiz-option.incorrect {
            background: #f8d7da;
            border-color: #dc3545;
            border-width: 4px;
        }
        
        .quiz-feedback {
            margin-top: 20px;
            padding: 15px;
            border-radius: 8px;
            font-weight: 600;
            display: none;
        }
        
        .quiz-feedback.correct {
            background: #d4edda;
            color: #155724;
            border: 2px solid #c3e6cb;
        }
        
        .quiz-feedback.incorrect {
            background: #f8d7da;
            color: #721c24;
            border: 2px solid #f5c6cb;
        }
        
        .score-display {
            text-align: center;
            font-size: 24px;
            font-weight: bold;
            color: #2a5298;
            margin-top: 30px;
        }
        
        .explanation {
            background: #e8f4fd;
            padding: 15px;
            border-radius: 8px;
            margin: 20px 0;
            border-left: 4px solid #2a5298;
        }
        
        .cpu-indicator {
            width: 15px;
            height: 15px;
            background: #ffeb3b;
            border-radius: 50%;
            display: inline-block;
            animation: pulse 1s infinite;
            margin-left: 10px;
        }
        
        .performance-graph {
            background: #f0f4f8;
            border-radius: 10px;
            padding: 20px;
            margin: 20px 0;
            height: 150px;
            position: relative;
            overflow: hidden;
        }
        
        .graph-canvas {
            width: 100%;
            height: 100%;
            background: white;
            border-radius: 5px;
        }
        
        .process-state {
            display: inline-block;
            padding: 2px 8px;
            border-radius: 12px;
            font-size: 11px;
            font-weight: bold;
            margin-left: 5px;
        }
        
        .state-running { 
            background: #4CAF50; 
            color: white; 
            box-shadow: 0 2px 4px rgba(76, 175, 80, 0.3);
        }
        .state-ready { 
            background: #2196F3; 
            color: white; 
            box-shadow: 0 2px 4px rgba(33, 150, 243, 0.3);
        }
        .state-blocked { 
            background: #FF9800; 
            color: white; 
            box-shadow: 0 2px 4px rgba(255, 152, 0, 0.3);
        }
        
        .memory-fragment {
            background: repeating-linear-gradient(
                45deg,
                #ffcdd2,
                #ffcdd2 5px,
                #ef9a9a 5px,
                #ef9a9a 10px
            );
            border: 2px dashed #f44336;
        }
        
        .history-log {
            background: #fafafa;
            border: 1px solid #e0e0e0;
            border-radius: 5px;
            padding: 10px;
            height: 150px;
            overflow-y: auto;
            font-family: monospace;
            font-size: 12px;
            margin: 10px 0;
        }
        
        .log-entry {
            padding: 4px 0;
            border-bottom: 1px solid #f0f0f0;
            font-size: 14px;
        }
        
        .log-entry.add { color: #4CAF50; }
        .log-entry.remove { color: #F44336; }
        .log-entry.warning { color: #FF9800; }
        
        .sound-toggle {
            position: fixed;
            bottom: 30px;
            right: 30px;
            background: #2196F3;
            color: white;
            border: none;
            border-radius: 50%;
            width: 60px;
            height: 60px;
            cursor: pointer;
            font-size: 28px;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);
            z-index: 1000;
            transition: transform 0.3s ease;
        }
        
        .sound-toggle:hover {
            transform: scale(1.1);
            box-shadow: 0 6px 16px rgba(0, 0, 0, 0.4);
        }
        
        .virtual-memory {
            background: linear-gradient(135deg, #f3e5f5 0%, #e1bee7 100%);
            border-radius: 15px;
            padding: 25px;
            margin: 20px 0;
            border: 3px dashed #9c27b0;
            font-size: 1.1em;
        }
        
        .virtual-memory h4 {
            font-size: 1.4em;
            color: #7b1fa2;
            margin-bottom: 15px;
        }
        
        .swap-indicator {
            display: inline-block;
            background: #9c27b0;
            color: white;
            padding: 4px 12px;
            border-radius: 6px;
            font-size: 13px;
            margin-left: 8px;
            font-weight: bold;
        }
        
        @keyframes memoryLeak {
            0% { transform: scale(1); }
            50% { transform: scale(1.1); background-color: #ffeb3b; }
            100% { transform: scale(1); }
        }
        
        @keyframes pulse {
            0% { transform: scale(1); opacity: 1; }
            50% { transform: scale(1.2); opacity: 0.7; }
            100% { transform: scale(1); opacity: 1; }
        }
        
        @media (max-width: 768px) {
            .container { padding: 20px; }
            h1 { font-size: 2em; }
            .subtitle { font-size: 1.1em; }
            button { 
                font-size: 16px; 
                padding: 12px 20px;
                min-width: 150px;

            .controls { gap: 10px; }
            .memory-display { height: 400px; }
            .stat-value { font-size: 28px; }
            .quiz-question { font-size: 18px; }
            .quiz-option { font-size: 16px; padding: 15px; }
        }
    }
    </style>
</head>
<body>
    <div class="container">
        <h1>🖥️ OS Memory Management Simulation</h1>
        <p class="subtitle">OCR J277 - Understanding How Operating Systems Manage Memory for Multitasking</p>
        
        <div class="info-panel">
            <h3>🎯 Learning Objectives</h3>
            <p>Understand how memory management enables multitasking by:</p>
            <ul>
                <li>Efficient allocation and deallocation of memory</li>
                <li>Managing multiple running processes</li>
                <li>Allowing processes to share CPU time</li>
                <li>Preventing processes from overwriting each other's data</li>
            </ul>
            
            <div class="stats">
                <div class="stat-item">
                    <div class="stat-value" id="memoryUsed">0</div>
                    <div class="stat-label">MB Used</div>
                </div>
        
        <div class="virtual-memory" id="virtualMemory" style="display: none; margin: 30px 0;">
            <h4>💾 Virtual Memory (Swap Space)</h4>
            <p style="font-size: 1.1em;">When physical memory is full, the OS can use disk space as virtual memory!</p>
            <div id="swapInfo"></div>
        </div>
        
        <div class="info-panel" style="margin-top: 30px;">
            <div class="memory-title">📜 System History Log</div>
            <div class="history-log" id="historyLog" style="margin-top: 20px;">
                <div class="log-entry">System started...</div>
            </div>
            <button class="btn-secondary" onclick="clearLog()" style="margin-top: 15px;">Clear Log</button>
        </div>
        
        <div class="virtual-memory" id="virtualMemory" style="display: none;">
            <h3>💾 Virtual Memory (Swap Space)</h3>
            <p style="font-size: 1.1em;">When physical memory is full, the OS can use disk space as virtual memory!</p>
            <div id="swapInfo"></div>
        </div>
                <div class="stat-item">
                    <div class="stat-value" id="memoryFree">1024</div>
                    <div class="stat-label">MB Free</div>
                </div>
                <div class="stat-item">
                    <div class="stat-value" id="processCount">0</div>
                    <div class="stat-label">Active Processes</div>
                </div>
                <div class="stat-item">
                    <div class="stat-value" id="cpuShare">0</div>
                    <div class="stat-label">CPU Time (ms)</div>
                </div>
            </div>
        </div>
        
        <div class="controls">
            <button class="btn-primary" onclick="addProcess()">➕ Add Process</button>
            <button class="btn-secondary" onclick="removeRandomProcess()">➖ Remove Process</button>
            <button class="btn-primary" onclick="simulateMultitasking()">⚡ Simulate Multitasking</button>
            
            <button class="btn-reset" onclick="resetSimulation()">🔄 Reset All</button>
        </div>
        
        <div style="text-align: center; margin-bottom: 40px; color: #666; font-size: 18px; background: #f0f4f8; padding: 15px; border-radius: 10px;">
            💡 <strong>Tip:</strong> Click on processes in the list to terminate them individually
        </div>
        
        
        
        <div class="main-content" style="margin-bottom: 40px;">
            <div class="memory-section">
                <div class="memory-title">📊 Physical Memory (1024 MB Total)</div>
                <div class="memory-usage-bar">
                    <div class="memory-usage-fill" id="memoryUsageBar">0%</div>
                </div>
                <div class="warning" id="memoryWarning">⚠️ Memory usage is high! Consider closing some processes.</div>
                <div class="memory-display">
                    <div id="memoryContainer" style="position: relative; height: 100%;"></div>
                </div>
            </div>
            
            <div class="process-section">
                <div class="memory-title">📋 Active Processes</div>
                <div class="process-list" id="processList"></div>
            </div>
        </div>
        
        <div class="explanation">
            <h3 style="font-size: 1.5em; color: #2a5298; margin-bottom: 20px;">💡 How It Works</h3>
            <p><strong>Memory Protection:</strong> Each process gets its own protected memory space (shown as different colors). The OS prevents processes from accessing each other's memory.</p>
            <p><strong>CPU Time Sharing:</strong> The yellow indicator shows which process is currently using the CPU. The OS rapidly switches between processes (multitasking).</p>
            <p><strong>Efficient Allocation:</strong> When you add/remove processes, the OS allocates and deallocates memory dynamically.</p>
            <p><strong>Process Priority:</strong> Critical and High priority processes (shown with colored borders) get preferential treatment in memory allocation and CPU scheduling.</p>
            <p><strong>Memory Addresses:</strong> Each process is assigned a unique memory address (shown in hex when you click a memory block).</p>
            <p><strong>Process States:</strong> <span class="process-state state-running">Running</span> = Currently using CPU, <span class="process-state state-ready">Ready</span> = Waiting for CPU, <span class="process-state state-blocked">Blocked</span> = Waiting for I/O or resources.</p>
        </div>
        
        <div class="quiz-section">
            <h3 style="font-size: 1.8em; margin-bottom: 30px; color: #333;">📝 Test Your Knowledge</h3>
            <div id="quizContainer"></div>
            <div class="quiz-feedback" id="quizFeedback"></div>
            <div style="text-align: center;">
                <button class="btn-primary" onclick="nextQuestion()" style="display: none; margin-top: 20px;" id="nextBtn">Next Question</button>
            </div>
            <div class="score-display" id="scoreDisplay"></div>
        </div>
    </div>
    
    <script>
        // Global variables
        let processes = [];
        let totalMemory = 1024; // MB
        let processIdCounter = 1;
        let currentQuestionIndex = 0;
        let score = 0;
        let questionsAnswered = 0;
        let multitaskingInterval;
        let currentActiveProcess = 0;
        let soundEnabled = true;
        let performanceData = [];
        let graphInterval;
        let swappedProcesses = [];
        let fragmentedBlocks = [];
        
        const processStates = ['Running', 'Ready', 'Blocked'];
        
        const processTypes = [
            { name: 'Web Browser', minSize: 200, maxSize: 400, color: '#4CAF50', priority: 'Normal' },
            { name: 'Text Editor', minSize: 50, maxSize: 150, color: '#2196F3', priority: 'Low' },
            { name: 'Music Player', minSize: 100, maxSize: 200, color: '#FF9800', priority: 'Normal' },
            { name: 'Video Editor', minSize: 300, maxSize: 500, color: '#9C27B0', priority: 'High' },
            { name: 'Game', minSize: 400, maxSize: 600, color: '#F44336', priority: 'Normal' },
            { name: 'Spreadsheet', minSize: 150, maxSize: 250, color: '#00BCD4', priority: 'Normal' },
            { name: 'Image Editor', minSize: 200, maxSize: 350, color: '#FF5722', priority: 'High' },
            { name: 'Email Client', minSize: 100, maxSize: 180, color: '#607D8B', priority: 'Low' },
            { name: 'System Update', minSize: 150, maxSize: 300, color: '#795548', priority: 'Critical' },
            { name: 'Antivirus', minSize: 100, maxSize: 200, color: '#9E9E9E', priority: 'Critical' }
        ];
        
        const questions = [
            {
                question: "What is the primary purpose of memory management in an operating system?",
                options: [
                    "To make the computer run faster",
                    "To enable efficient allocation of memory for multiple processes",
                    "To increase the size of RAM",
                    "To delete unwanted files"
                ],
                correct: 1,
                explanation: "Memory management ensures efficient allocation and deallocation of memory for multiple running processes, enabling multitasking."
            },
            {
                question: "How does memory management prevent data corruption between processes?",
                options: [
                    "By running only one process at a time",
                    "By giving each process its own protected memory space",
                    "By using more RAM",
                    "By slowing down the CPU"
                ],
                correct: 1,
                explanation: "Each process is allocated its own protected memory space, preventing one process from overwriting another's data."
            },
            {
                question: "What happens when a process is terminated?",
                options: [
                    "The memory is lost forever",
                    "The memory is automatically deallocated and becomes available",
                    "The computer needs to restart",
                    "Other processes slow down"
                ],
                correct: 1,
                explanation: "When a process terminates, the OS deallocates its memory, making it available for other processes to use."
            },
            {
                question: "How does the OS enable multiple processes to share CPU time?",
                options: [
                    "By having multiple CPUs",
                    "By rapidly switching between processes (time slicing)",
                    "By running all processes simultaneously",
                    "By making processes wait in a queue"
                ],
                correct: 1,
                explanation: "The OS uses time slicing to rapidly switch between processes, giving each a small amount of CPU time in turn."
            },
            {
                question: "What would happen without proper memory management?",
                options: [
                    "The computer would run faster",
                    "Processes could overwrite each other's data causing crashes",
                    "More programs could run at once",
                    "The CPU would work better"
                ],
                correct: 1,
                explanation: "Without memory management, processes could access and overwrite each other's memory, causing data corruption and system crashes."
            },
            {
                question: "What is memory fragmentation?",
                options: [
                    "When memory breaks physically",
                    "When there are gaps of unused memory between allocated blocks",
                    "When a process uses too much memory",
                    "When the CPU runs too fast"
                ],
                correct: 1,
                explanation: "Memory fragmentation occurs when there are small gaps of unused memory between allocated blocks, which can waste memory space."
            },
            {
                question: "What are the three main process states?",
                options: [
                    "Start, Middle, End",
                    "Fast, Medium, Slow",
                    "Running, Ready, Blocked",
                    "New, Old, Deleted"
                ],
                correct: 2,
                explanation: "The three main process states are Running (using CPU), Ready (waiting for CPU), and Blocked (waiting for I/O or resources)."
            },
            {
                question: "What is virtual memory?",
                options: [
                    "Fake memory that doesn't exist",
                    "Using disk space as additional memory when RAM is full",
                    "Memory used by virtual machines",
                    "Memory that disappears when you turn off the computer"
                ],
                correct: 1,
                explanation: "Virtual memory allows the OS to use disk space as additional memory when physical RAM is full, though it's slower than real RAM."
            },
            {
                question: "Why do operating systems use process priorities?",
                options: [
                    "To make some programs run faster",
                    "To ensure critical system processes get resources first",
                    "To make the computer look busy",
                    "To use more memory"
                ],
                correct: 1,
                explanation: "Process priorities ensure that critical system processes (like security updates or antivirus) get CPU time and memory resources before less important processes."
            }
        ];
        
        function initializeSimulation() {
            updateMemoryDisplay();
            updateStats();
            showQuestion();
        }
        
        function addProcess() {
            const usedMemory = processes.reduce((sum, p) => sum + p.size, 0);
            const freeMemory = totalMemory - usedMemory;
            
            if (freeMemory < 50) {
                alert('Not enough memory! Remove some processes first.');
                document.getElementById('memoryWarning').style.animation = 'shake 0.5s';
                return;
            }
            
            const processType = processTypes[Math.floor(Math.random() * processTypes.length)];
            const maxPossibleSize = Math.min(processType.maxSize, freeMemory);
            const size = Math.floor(Math.random() * (maxPossibleSize - processType.minSize + 1)) + processType.minSize;
            
            const newProcess = {
                id: processIdCounter++,
                name: processType.name,
                size: size,
                color: processType.color,
                priority: processType.priority,
                cpuTime: 0,
                active: false,
                startTime: Date.now(),
                state: 'Ready',
                memoryLeaking: false
            };
            
            processes.push(newProcess);
            
            updateMemoryDisplay();
            updateProcessList();
            updateStats();
        }
        
        function removeRandomProcess() {
            if (processes.length === 0) {
                alert('No processes to remove!');
                return;
            }
            
            const randomIndex = Math.floor(Math.random() * processes.length);
            processes.splice(randomIndex, 1);
            updateMemoryDisplay();
            updateProcessList();
            updateStats();
        }
        
        function updateMemoryDisplay() {
            const container = document.getElementById('memoryContainer');
            container.innerHTML = '';
            
            let currentTop = 0;
            const containerHeight = container.offsetHeight || 450; // Use actual height with fallback
            
            // Update memory usage bar
            const usedMemory = processes.reduce((sum, p) => sum + p.size, 0);
            const usagePercent = Math.round((usedMemory / totalMemory) * 100);
            const usageBar = document.getElementById('memoryUsageBar');
            usageBar.style.width = usagePercent + '%';
            usageBar.textContent = usagePercent + '%';
            
            // Show warning if memory usage is high
            const warning = document.getElementById('memoryWarning');
            if (usagePercent > 80) {
                warning.style.display = 'block';
            } else {
                warning.style.display = 'none';
            }
            
            // Sort processes by priority for visual arrangement
            const sortedProcesses = [...processes].sort((a, b) => {
                const priorityOrder = { 'Critical': 0, 'High': 1, 'Normal': 2, 'Low': 3 };
                return priorityOrder[a.priority] - priorityOrder[b.priority];
            });
            
            // Show allocated memory blocks
            sortedProcesses.forEach((process, index) => {
                const blockHeight = Math.max((process.size / totalMemory) * containerHeight, 40); // Minimum height
                const block = document.createElement('div');
                block.className = 'memory-block';
                block.style.backgroundColor = process.color;
                block.style.top = currentTop + 'px';
                block.style.height = blockHeight + 'px';
                
                // Add priority indicator border
                if (process.priority === 'Critical') {
                    block.style.border = '4px solid #d32f2f';
                } else if (process.priority === 'High') {
                    block.style.border = '4px solid #ff6f00';
                }
                
                block.innerHTML = `
                    <div style="text-align: center; color: white; text-shadow: 1px 1px 3px rgba(0,0,0,0.7); padding: 10px; font-size: 1.1em; width: 100%; display: flex; flex-direction: column; justify-content: center; align-items: center;">
                        <div style="font-weight: bold; margin-bottom: 5px;">${process.name}</div>
                        <div>${process.size} MB | ${process.priority}</div>
                        ${process.active ? '<span class="cpu-indicator" style="margin-top: 5px;"></span>' : ''}
                    </div>
                `;
                block.onclick = () => highlightProcess(process.id);
                
                if (process.memoryLeaking) {
                    block.style.animation = 'memoryLeak 2s infinite';
                }
                
                container.appendChild(block);
                currentTop += blockHeight + 4; // Increased gap
            });
            
            // Show free memory
            const freeMemory = totalMemory - usedMemory;
            if (freeMemory > 0 && currentTop < containerHeight) {
                const freeBlockHeight = Math.min((freeMemory / totalMemory) * containerHeight, containerHeight - currentTop);
                const freeBlock = document.createElement('div');
                freeBlock.className = 'memory-block';
                freeBlock.style.top = currentTop + 'px';
                freeBlock.style.height = freeBlockHeight + 'px';
                freeBlock.style.background = 'repeating-linear-gradient(45deg, #e0e0e0, #e0e0e0 10px, #f0f0f0 10px, #f0f0f0 20px)';
                freeBlock.innerHTML = `<div style="text-align: center; color: #666; font-size: 1.2em; font-weight: bold; padding: 10px;">Free Memory<br>${freeMemory} MB</div>`;
                container.appendChild(freeBlock);
            }
        }
        
        function updateProcessList() {
            const list = document.getElementById('processList');
            list.innerHTML = '';
            
            // Sort by priority
            const sortedProcesses = [...processes].sort((a, b) => {
                const priorityOrder = { 'Critical': 0, 'High': 1, 'Normal': 2, 'Low': 3 };
                return priorityOrder[a.priority] - priorityOrder[b.priority];
            });
            
            sortedProcesses.forEach(process => {
                const item = document.createElement('div');
                item.className = 'process-item';
                const runtime = Math.round((Date.now() - process.startTime) / 1000);
                
                // Add priority-based styling
                if (process.priority === 'Critical') {
                    item.style.borderLeft = '6px solid #d32f2f';
                } else if (process.priority === 'High') {
                    item.style.borderLeft = '6px solid #ff6f00';
                } else {
                    item.style.borderLeft = '6px solid transparent';
                }
                
                item.innerHTML = `
                    <div class="process-name" style="display: flex; align-items: center; gap: 10px;">
                        <span class="process-status" style="background: ${process.color}"></span>
                        <span style="font-weight: bold;">${process.name} (PID: ${process.id})</span>
                        <span style="font-size: 14px; color: #666; margin-left: 10px;">${process.priority}</span>
                        <span class="process-state state-${process.state.toLowerCase()}">${process.state}</span>
                        ${process.memoryLeaking ? '<span style="color: #f44336; margin-left: 10px; font-weight: bold;">⚠️ LEAK</span>' : ''}
                    </div>
                    <div style="text-align: right; font-size: 16px;">
                        <strong>${process.size} MB</strong> | CPU: ${process.cpuTime}ms | Runtime: ${runtime}s
                        ${process.active ? '<span class="cpu-indicator"></span>' : ''}
                    </div>
                `;
                item.onclick = () => terminateProcess(process.id);
                item.title = 'Click to terminate this process';
                list.appendChild(item);
            });
            
            if (processes.length === 0) {
                list.innerHTML = '<div style="text-align: center; color: #999; padding: 40px; font-size: 18px;">No processes running. Click "Add Process" to start!</div>';
            }
        }
        
        function updateStats() {
            const usedMemory = processes.reduce((sum, p) => sum + p.size, 0);
            const freeMemory = totalMemory - usedMemory;
            const totalCpuTime = processes.reduce((sum, p) => sum + p.cpuTime, 0);
            
            document.getElementById('memoryUsed').textContent = usedMemory;
            document.getElementById('memoryFree').textContent = freeMemory;
            document.getElementById('processCount').textContent = processes.length;
            document.getElementById('cpuShare').textContent = totalCpuTime;
        }
        
        function simulateMultitasking() {
            if (processes.length === 0) {
                alert('Add some processes first!');
                return;
            }
            
            // Clear any existing interval
            if (multitaskingInterval) {
                clearInterval(multitaskingInterval);
            }
            
            addLogEntry('Started multitasking simulation', 'info');
            
            // Simulate CPU time slicing
            multitaskingInterval = setInterval(() => {
                // Update process states
                processes.forEach(p => {
                    p.active = false;
                    if (p.state === 'Running') p.state = 'Ready';
                });
                
                // Randomly block some processes
                if (Math.random() < 0.3 && processes.length > 2) {
                    const randomProcess = processes[Math.floor(Math.random() * processes.length)];
                    randomProcess.state = 'Blocked';
                }
                
                // Activate next process
                if (processes.length > 0) {
                    currentActiveProcess = (currentActiveProcess + 1) % processes.length;
                    const activeProcess = processes[currentActiveProcess];
                    if (activeProcess.state !== 'Blocked') {
                        activeProcess.active = true;
                        activeProcess.state = 'Running';
                        activeProcess.cpuTime += 100; // 100ms time slice
                    }
                }
                
                updateMemoryDisplay();
                updateProcessList();
                updateStats();
            }, 500); // Switch every 500ms for visibility
            
            // Stop after 10 seconds
            setTimeout(() => {
                clearInterval(multitaskingInterval);
                processes.forEach(p => {
                    p.active = false;
                    p.state = 'Ready';
                });
                updateMemoryDisplay();
                updateProcessList();
                addLogEntry('Multitasking simulation ended', 'info');
            }, 10000);
        }
        
        function highlightProcess(processId) {
            const process = processes.find(p => p.id === processId);
            if (process) {
                const runtime = Math.round((Date.now() - process.startTime) / 1000);
                alert(`Process Information:\n\nName: ${process.name}\nPID: ${process.id}\nPriority: ${process.priority}\nMemory: ${process.size} MB\nCPU Time: ${process.cpuTime}ms\nRuntime: ${runtime} seconds\n\nMemory Address: 0x${(1000000 + processId * 100000).toString(16).toUpperCase()}`);
            }
        }
        
        function terminateProcess(processId) {
            if (confirm('Terminate this process?')) {
                const index = processes.findIndex(p => p.id === processId);
                if (index !== -1) {
                    // Visual feedback
                    const processItem = event.currentTarget;
                    processItem.style.transition = 'all 0.2s ease';
                    processItem.style.transform = 'translateX(-100%)';
                    processItem.style.opacity = '0';
                    
                    setTimeout(() => {
                        processes.splice(index, 1);
                        updateMemoryDisplay();
                        updateProcessList();
                        updateStats();
                    }, 200);
                }
            }
        }
        
        function showQuestion() {
            const container = document.getElementById('quizContainer');
            const question = questions[currentQuestionIndex];
            
            container.innerHTML = `
                <div class="quiz-question">Question ${currentQuestionIndex + 1}: ${question.question}</div>
                <div class="quiz-options">
                    ${question.options.map((option, index) => `
                        <div class="quiz-option" onclick="selectAnswer(${index})">${option}</div>
                    `).join('')}
                </div>
            `;
            
            document.getElementById('quizFeedback').style.display = 'none';
            document.getElementById('nextBtn').style.display = 'none';
        }
        
        function selectAnswer(index) {
            const question = questions[currentQuestionIndex];
            const options = document.querySelectorAll('.quiz-option');
            const feedback = document.getElementById('quizFeedback');
            
            // Disable all options
            options.forEach(option => {
                option.onclick = null;
                option.style.cursor = 'default';
            });
            
            // Mark selected option
            options[index].classList.add('selected');
            
            // Show correct/incorrect
            if (index === question.correct) {
                options[index].classList.add('correct');
                feedback.className = 'quiz-feedback correct';
                feedback.textContent = '✅ Correct! ' + question.explanation;
                score++;
            } else {
                options[index].classList.add('incorrect');
                options[question.correct].classList.add('correct');
                feedback.className = 'quiz-feedback incorrect';
                feedback.textContent = '❌ Incorrect. ' + question.explanation;
            }
            
            feedback.style.display = 'block';
            questionsAnswered++;
            
            // Show next button or final score
            if (currentQuestionIndex < questions.length - 1) {
                document.getElementById('nextBtn').style.display = 'inline-block';
            } else {
                document.getElementById('scoreDisplay').textContent = 
                    `Quiz Complete! Your score: ${score}/${questions.length} (${Math.round(score/questions.length*100)}%)`;
            }
        }
        
        function nextQuestion() {
            currentQuestionIndex++;
            showQuestion();
        }
        
        function resetSimulation() {
            // Clear intervals
            if (multitaskingInterval) {
                clearInterval(multitaskingInterval);
            }
            if (graphInterval) {
                clearInterval(graphInterval);
            }
            
            // Reset all variables
            processes = [];
            processIdCounter = 1;
            currentQuestionIndex = 0;
            score = 0;
            questionsAnswered = 0;
            currentActiveProcess = 0;
            swappedProcesses = [];
            fragmentedBlocks = [];
            performanceData = [];
            
            // Reset displays
            updateMemoryDisplay();
            updateProcessList();
            updateStats();
            showQuestion();
            document.getElementById('scoreDisplay').textContent = '';
            addLogEntry('System reset', 'warning');
            
            // Reset graph
            const canvas = document.getElementById('perfGraph');
            const ctx = canvas.getContext('2d');

        }
        
        // New functions for enhanced features
        function addLogEntry(message, type = 'info') {
            const log = document.getElementById('historyLog');
            const entry = document.createElement('div');
            entry.className = `log-entry ${type}`;
            const timestamp = new Date().toLocaleTimeString();
            entry.textContent = `[${timestamp}] ${message}`;
            log.appendChild(entry);
            log.scrollTop = log.scrollHeight;
            
            // Keep only last 50 entries
            while (log.children.length > 50) {
                log.removeChild(log.firstChild);
            }
        }
        
        function clearLog() {
            const log = document.getElementById('historyLog');
            log.innerHTML = '<div class="log-entry">Log cleared...</div>';
        }
        
        
        
        
        
        function simulateMemoryLeak() {
            if (processes.length === 0) return;
            
            const randomProcess = processes[Math.floor(Math.random() * processes.length)];
            if (!randomProcess.memoryLeaking && randomProcess.size < 300) {
                randomProcess.memoryLeaking = true;
                
                const leakInterval = setInterval(() => {
                    const usedMemory = processes.reduce((sum, p) => sum + p.size, 0);
                    if (usedMemory < totalMemory - 10 && processes.includes(randomProcess)) {
                        randomProcess.size += 10;
                        updateMemoryDisplay();
                        updateStats();
                        addLogEntry(`⚠️ Memory leak detected in ${randomProcess.name}!`, 'warning');
                    } else {
                        clearInterval(leakInterval);
                        randomProcess.memoryLeaking = false;
                    }
                }, 2000);
            }
        }
        
        function showVirtualMemory() {
            const usedMemory = processes.reduce((sum, p) => sum + p.size, 0);
            if (usedMemory > totalMemory * 0.9) {
                document.getElementById('virtualMemory').style.display = 'block';
                const swapInfo = document.getElementById('swapInfo');
                swapInfo.innerHTML = `
                    <p style="font-size: 1.1em; margin: 10px 0;">⚠️ Physical memory almost full!</p>
                    <p style="font-size: 1.1em; margin: 10px 0;">Swapped processes: ${swappedProcesses.length}</p>
                    <p style="font-size: 1.1em; margin: 10px 0;">Performance may be slower when using swap space.</p>
                `;
            } else {
                document.getElementById('virtualMemory').style.display = 'none';
            }
        }
        
        // Sound effects using Web Audio API
        function playSound(type) {
            if (!soundEnabled) return;
            
            const audioContext = new (window.AudioContext || window.webkitAudioContext)();
            const oscillator = audioContext.createOscillator();
            const gainNode = audioContext.createGain();
            
            oscillator.connect(gainNode);
            gainNode.connect(audioContext.destination);
            
            switch(type) {
                case 'add':
                    oscillator.frequency.value = 800;
                    gainNode.gain.value = 0.1;
                    break;
                case 'remove':
                    oscillator.frequency.value = 400;
                    gainNode.gain.value = 0.1;
                    break;
                case 'error':
                    oscillator.frequency.value = 200;
                    gainNode.gain.value = 0.2;
                    break;
            }
            
            oscillator.start();
            oscillator.stop(audioContext.currentTime + 0.1);
        }
        
        // Update existing functions to use new features
        const originalAddProcess = addProcess;
        addProcess = function() {
            originalAddProcess();
            const lastProcess = processes[processes.length - 1];
            if (lastProcess) {
                addLogEntry(`Added process: ${lastProcess.name} (${lastProcess.size} MB)`, 'add');
                playSound('add');
                
                // Update performance graph immediately
                const canvas = document.getElementById('perfGraph');
                const ctx = canvas.getContext('2d');
                if (ctx) {
                    const usedMemory = processes.reduce((sum, p) => sum + p.size, 0);
                    const usage = (usedMemory / totalMemory) * 100;
                    performanceData.push(usage);
                    if (performanceData.length > 50) performanceData.shift();
                    drawPerformanceGraph(ctx, canvas);
                }
                
                // Random chance of memory leak
                if (Math.random() < 0.1) {
                    setTimeout(() => simulateMemoryLeak(), 3000);
                }
            }
            showVirtualMemory();
        };
        
        const originalRemoveProcess = removeRandomProcess;
        removeRandomProcess = function() {
            const processCount = processes.length;
            originalRemoveProcess();
            if (processes.length < processCount) {
                addLogEntry('Removed random process', 'remove');
                playSound('remove');
                
                // Update performance graph immediately
                const canvas = document.getElementById('perfGraph');
                const ctx = canvas.getContext('2d');
                if (ctx) {
                    const usedMemory = processes.reduce((sum, p) => sum + p.size, 0);
                    const usage = (usedMemory / totalMemory) * 100;
                    performanceData.push(usage);
                    if (performanceData.length > 50) performanceData.shift();
                    drawPerformanceGraph(ctx, canvas);
                }
            } else {
                playSound('error');
            }
            showVirtualMemory();
        };
        
        
        
        // Initialize on load
        window.onload = function() {
            initializeSimulation();
            
            // Delay graph initialization to ensure DOM is ready
            setTimeout(() => {
                initPerformanceGraph();
            }, 100);
            
            // Add sound toggle button
            const soundBtn = document.createElement('button');
            soundBtn.className = 'sound-toggle';
            soundBtn.innerHTML = '🔊';
            soundBtn.onclick = () => {
                soundEnabled = !soundEnabled;
                soundBtn.innerHTML = soundEnabled ? '🔊' : '🔇';
            };
            document.body.appendChild(soundBtn);
            
            // Keyboard shortcuts
            document.addEventListener('keydown', (e) => {
                if (e.key === 'a' || e.key === 'A') addProcess();
                if (e.key === 'r' || e.key === 'R') removeRandomProcess();
                if (e.key === 'm' || e.key === 'M') simulateMultitasking();
                
                if (e.key === 'Escape') resetSimulation();
            });
            
            // Add keyboard shortcut info
            const shortcutInfo = document.createElement('div');
            shortcutInfo.style.cssText = 'text-align: center; color: #666; font-size: 16px; margin: 30px 0 0 0; padding: 20px 0; border-top: 1px solid #e0e0e0;';
            shortcutInfo.innerHTML = '⌨️ Keyboard Shortcuts: <strong>[A]</strong>dd process, <strong>[R]</strong>emove process, <strong>[M]</strong>ultitasking, <strong>[F]</strong>ragmentation, <strong>[ESC]</strong> Reset';
            document.querySelector('.container').appendChild(shortcutInfo);
        };
    </script>
</body>
</html>