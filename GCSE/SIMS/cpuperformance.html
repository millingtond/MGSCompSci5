<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>CPU Performance Factory - Interactive Learning</title>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700;800&display=swap');
        
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Inter', -apple-system, BlinkMacSystemFont, sans-serif;
            background: #0a0a0a;
            color: #ffffff;
            overflow: hidden;
            user-select: none;
        }

        .app {
            display: flex;
            flex-direction: column;
            height: 100vh;
            position: relative;
        }

        .header {
            background: rgba(17, 24, 39, 0.8);
            backdrop-filter: blur(20px);
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
            padding: 20px 40px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            z-index: 100;
        }

        .logo-section {
            display: flex;
            align-items: center;
            gap: 20px;
        }

        .logo {
            width: 40px;
            height: 40px;
            background: #3b82f6;
            border-radius: 12px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: bold;
            font-size: 20px;
        }

        .title {
            font-size: 24px;
            font-weight: 700;
            color: #fff;
        }

        .mode-selector {
            display: flex;
            gap: 4px;
            background: rgba(30, 41, 59, 0.5);
            padding: 4px;
            border-radius: 12px;
            border: 1px solid rgba(255, 255, 255, 0.1);
        }

        .mode-btn {
            padding: 10px 24px;
            border: none;
            background: transparent;
            color: #94a3b8;
            cursor: pointer;
            border-radius: 8px;
            transition: all 0.3s;
            font-size: 14px;
            font-weight: 500;
        }

        .mode-btn:hover {
            color: #fff;
        }

        .mode-btn.active {
            background: rgba(59, 130, 246, 0.2);
            color: #3b82f6;
        }

        .main-container {
            display: flex;
            flex: 1;
            overflow: hidden;
            position: relative;
        }

        .control-panel {
            width: 340px;
            background: rgba(17, 24, 39, 0.6);
            backdrop-filter: blur(10px);
            padding: 30px;
            overflow-y: auto;
            border-right: 1px solid rgba(255, 255, 255, 0.1);
        }

        .control-panel::-webkit-scrollbar {
            width: 8px;
        }

        .control-panel::-webkit-scrollbar-track {
            background: rgba(255, 255, 255, 0.05);
            border-radius: 4px;
        }

        .control-panel::-webkit-scrollbar-thumb {
            background: rgba(255, 255, 255, 0.2);
            border-radius: 4px;
        }

        .simulation-area {
            flex: 1;
            position: relative;
            background: #0a0a0a;
            overflow: hidden;
        }

        .metrics-panel {
            width: 300px;
            background: rgba(17, 24, 39, 0.6);
            backdrop-filter: blur(10px);
            padding: 30px;
            overflow-y: auto;
            border-left: 1px solid rgba(255, 255, 255, 0.1);
        }

        .canvas-container {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
        }

        canvas {
            display: block;
            width: 100%;
            height: 100%;
        }

        .control-group {
            margin-bottom: 32px;
        }

        .control-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 12px;
        }

        .control-label {
            font-size: 13px;
            color: #94a3b8;
            font-weight: 600;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        .control-value {
            font-size: 18px;
            font-weight: 700;
            color: #3b82f6;
        }

        .slider-track {
            position: relative;
            height: 40px;
            background: rgba(30, 41, 59, 0.5);
            border-radius: 20px;
            border: 1px solid rgba(255, 255, 255, 0.1);
            overflow: hidden;
        }

        .slider-fill {
            position: absolute;
            left: 0;
            top: 0;
            height: 100%;
            background: #3b82f6;
            border-radius: 20px;
            transition: width 0.3s;
        }

        .slider-handle {
            position: absolute;
            top: 50%;
            transform: translate(-50%, -50%);
            width: 32px;
            height: 32px;
            background: #fff;
            border-radius: 50%;
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.3);
            cursor: grab;
            transition: all 0.2s;
        }

        .slider-handle:active {
            cursor: grabbing;
            transform: translate(-50%, -50%) scale(1.1);
        }

        .slider {
            position: absolute;
            width: 100%;
            height: 100%;
            opacity: 0;
            cursor: pointer;
        }

        .task-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 12px;
        }

        .task-card {
            padding: 16px;
            border: 2px solid rgba(255, 255, 255, 0.1);
            background: rgba(30, 41, 59, 0.5);
            border-radius: 12px;
            cursor: pointer;
            transition: all 0.3s;
            position: relative;
            overflow: hidden;
        }

        .task-card:hover {
            transform: translateY(-4px);
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.3);
        }

        .task-card.active {
            border-color: #3b82f6;
            background: rgba(59, 130, 246, 0.2);
        }

        .task-icon {
            font-size: 24px;
            margin-bottom: 8px;
        }

        .task-name {
            font-weight: 600;
            font-size: 14px;
            color: #fff;
        }

        .task-desc {
            font-size: 12px;
            color: #64748b;
            margin-top: 4px;
        }

        .metric-card {
            background: rgba(30, 41, 59, 0.5);
            border: 1px solid rgba(255, 255, 255, 0.1);
            border-radius: 16px;
            padding: 20px;
            margin-bottom: 16px;
            position: relative;
            overflow: hidden;
        }

        .metric-header {
            display: flex;
            justify-content: space-between;
            align-items: baseline;
            margin-bottom: 12px;
        }

        .metric-label {
            font-size: 12px;
            color: #94a3b8;
            font-weight: 600;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        .metric-value {
            font-size: 28px;
            font-weight: 700;
            color: #3b82f6;
        }

        .metric-bar {
            height: 8px;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 4px;
            overflow: hidden;
            position: relative;
        }

        .metric-fill {
            height: 100%;
            background: #3b82f6;
            border-radius: 4px;
            transition: width 0.5s ease-out;
        }

        .scenario-section {
            margin-top: 32px;
            padding-top: 32px;
            border-top: 1px solid rgba(255, 255, 255, 0.1);
        }

        .scenario-card {
            background: rgba(30, 41, 59, 0.5);
            border: 2px solid rgba(255, 255, 255, 0.1);
            border-radius: 16px;
            padding: 20px;
            margin-bottom: 12px;
            cursor: pointer;
            transition: all 0.3s;
            position: relative;
            overflow: hidden;
        }

        .scenario-card:hover {
            border-color: rgba(59, 130, 246, 0.5);
            transform: translateX(4px);
        }

        .scenario-card.active {
            border-color: #3b82f6;
            background: rgba(59, 130, 246, 0.1);
        }

        .scenario-header {
            display: flex;
            align-items: center;
            gap: 12px;
            margin-bottom: 8px;
        }

        .scenario-icon {
            font-size: 20px;
        }

        .scenario-title {
            font-weight: 600;
            font-size: 16px;
            color: #fff;
        }

        .scenario-desc {
            font-size: 13px;
            color: #64748b;
            line-height: 1.5;
        }

        /* Tutorial System */
        .tutorial-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.8);
            z-index: 1000;
            display: none;
            opacity: 0;
            transition: opacity 0.5s;
        }

        .tutorial-overlay.active {
            display: block;
            opacity: 1;
        }

        .tutorial-spotlight {
            position: absolute;
            border: 3px solid #3b82f6;
            border-radius: 12px;
            box-shadow: 0 0 0 3000px rgba(0, 0, 0, 0.7);
            transition: all 0.5s ease-out;
            pointer-events: none;
        }

        .tutorial-bubble {
            position: absolute;
            background: #1e3c72;
            color: white;
            padding: 24px;
            border-radius: 16px;
            box-shadow: 0 10px 40px rgba(0, 0, 0, 0.5);
            max-width: 400px;
            z-index: 1001;
            transform: translateY(20px);
            opacity: 0;
            transition: all 0.5s;
        }

        .tutorial-bubble.show {
            transform: translateY(0);
            opacity: 1;
        }

        .tutorial-bubble::before {
            content: '';
            position: absolute;
            width: 20px;
            height: 20px;
            background: inherit;
            transform: rotate(45deg);
        }

        .tutorial-bubble.top::before {
            bottom: -10px;
            left: 50%;
            transform: translateX(-50%) rotate(45deg);
        }

        .tutorial-bubble.bottom::before {
            top: -10px;
            left: 50%;
            transform: translateX(-50%) rotate(45deg);
        }

        .tutorial-bubble.left::before {
            right: -10px;
            top: 50%;
            transform: translateY(-50%) rotate(45deg);
        }

        .tutorial-bubble.right::before {
            left: -10px;
            top: 50%;
            transform: translateY(-50%) rotate(45deg);
        }

        .tutorial-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 16px;
        }

        .tutorial-title {
            font-size: 20px;
            font-weight: 700;
        }

        .tutorial-step {
            font-size: 14px;
            color: rgba(255, 255, 255, 0.8);
        }

        .tutorial-content {
            font-size: 16px;
            line-height: 1.6;
            margin-bottom: 20px;
        }

        .tutorial-actions {
            display: flex;
            gap: 12px;
            justify-content: flex-end;
        }

        .tutorial-btn {
            padding: 10px 20px;
            border: none;
            border-radius: 8px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s;
            font-size: 14px;
        }

        .tutorial-btn.primary {
            background: #fff;
            color: #1e3c72;
        }

        .tutorial-btn.primary:hover {
            transform: translateY(-2px);
        }

        .tutorial-btn.secondary {
            background: rgba(255, 255, 255, 0.2);
            color: #fff;
        }

        .quiz-container {
            background: rgba(255, 255, 255, 0.1);
            border-radius: 12px;
            padding: 20px;
            margin: 20px 0;
        }

        .quiz-question {
            font-size: 16px;
            font-weight: 600;
            margin-bottom: 16px;
        }

        .quiz-options {
            display: flex;
            flex-direction: column;
            gap: 12px;
        }

        .quiz-option {
            padding: 12px 16px;
            background: rgba(255, 255, 255, 0.1);
            border: 2px solid rgba(255, 255, 255, 0.2);
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.3s;
        }

        .quiz-option:hover {
            background: rgba(255, 255, 255, 0.2);
            border-color: #3b82f6;
        }

        .quiz-option.correct {
            background: rgba(34, 197, 94, 0.2);
            border-color: #22c55e;
        }

        .quiz-option.incorrect {
            background: rgba(239, 68, 68, 0.2);
            border-color: #ef4444;
        }

        .start-tutorial-btn {
            position: fixed;
            bottom: 30px;
            right: 30px;
            padding: 16px 32px;
            background: #3b82f6;
            color: white;
            border: none;
            border-radius: 50px;
            font-weight: 600;
            font-size: 16px;
            cursor: pointer;
            box-shadow: 0 10px 30px rgba(59, 130, 246, 0.5);
            transition: all 0.3s;
            z-index: 100;
        }

        .start-tutorial-btn:hover {
            transform: translateY(-4px);
            box-shadow: 0 15px 40px rgba(59, 130, 246, 0.6);
        }

        .start-tutorial-btn.pulse {
            animation: pulse 2s infinite;
        }

        .reset-btn {
            position: fixed;
            bottom: 30px;
            right: 250px;
            padding: 16px 32px;
            background: #ef4444;
            color: white;
            border: none;
            border-radius: 50px;
            font-weight: 600;
            font-size: 16px;
            cursor: pointer;
            box-shadow: 0 10px 30px rgba(239, 68, 68, 0.5);
            transition: all 0.3s;
            z-index: 100;
        }

        .reset-btn:hover {
            transform: translateY(-4px);
            box-shadow: 0 15px 40px rgba(239, 68, 68, 0.6);
        }

        @keyframes pulse {
            0% { transform: scale(1); }
            50% { transform: scale(1.05); }
            100% { transform: scale(1); }
        }

        /* Advanced mode styles */
        .advanced-feature {
            opacity: 0.3;
            pointer-events: none;
            transition: all 0.5s;
        }

        .advanced-mode .advanced-feature {
            opacity: 1;
            pointer-events: all;
        }

        .achievement-notification {
            position: fixed;
            top: 100px;
            right: 30px;
            background: #fbbf24;
            color: #1a1a1a;
            padding: 20px 30px;
            border-radius: 16px;
            box-shadow: 0 10px 40px rgba(251, 191, 36, 0.5);
            transform: translateX(400px);
            transition: transform 0.5s;
            z-index: 1000;
        }

        .achievement-notification.show {
            transform: translateX(0);
        }

        .achievement-header {
            display: flex;
            align-items: center;
            gap: 12px;
            margin-bottom: 8px;
        }

        .achievement-icon {
            font-size: 32px;
        }

        .achievement-title {
            font-size: 18px;
            font-weight: 700;
        }

        .achievement-desc {
            font-size: 14px;
            opacity: 0.8;
        }

        /* Performance indicators */
        .performance-indicator {
            position: absolute;
            top: 20px;
            left: 20px;
            display: flex;
            flex-direction: column;
            gap: 10px;
        }

        .indicator-item {
            background: rgba(0, 0, 0, 0.6);
            backdrop-filter: blur(10px);
            padding: 10px 16px;
            border-radius: 8px;
            display: flex;
            align-items: center;
            gap: 10px;
            min-width: 180px;
        }

        .indicator-icon {
            font-size: 20px;
        }

        .indicator-text {
            font-size: 12px;
            font-weight: 600;
        }

        .loading-screen {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: #0a0a0a;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 2000;
            transition: opacity 0.5s;
        }

        .loading-screen.hidden {
            opacity: 0;
            pointer-events: none;
        }

        .loader-container {
            position: relative;
            width: 120px;
            height: 120px;
        }

        .loader-ring {
            position: absolute;
            width: 100%;
            height: 100%;
            border: 3px solid rgba(59, 130, 246, 0.2);
            border-radius: 50%;
        }

        .loader-ring:nth-child(1) {
            border-top-color: #3b82f6;
            animation: spin 1s linear infinite;
        }

        @keyframes spin {
            to { transform: rotate(360deg); }
        }

        /* Info panel styles */
        .info-panel {
            position: absolute;
            top: 10px;
            right: 20px;
            background: rgba(17, 24, 39, 0.9);
            backdrop-filter: blur(10px);
            padding: 15px;
            border-radius: 8px;
            border: 1px solid rgba(255, 255, 255, 0.1);
            max-width: 250px;
            z-index: 50;
        }

        .info-title {
            font-size: 14px;
            font-weight: 600;
            color: #3b82f6;
            margin-bottom: 10px;
        }

        .info-text {
            font-size: 12px;
            color: #94a3b8;
            line-height: 1.4;
            margin-bottom: 6px;
        }

        .info-highlight {
            color: #3b82f6;
            font-weight: 600;
        }

        .loading-text {
            margin-top: 30px;
            font-size: 18px;
            font-weight: 600;
            color: #64748b;
        }

        /* System crash overlay */
        .crash-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(220, 38, 38, 0.95);
            z-index: 1500;
            display: none;
            justify-content: center;
            align-items: center;
        }

        .crash-dialog {
            background: #1a1a1a;
            padding: 40px;
            border-radius: 20px;
            box-shadow: 0 20px 60px rgba(0, 0, 0, 0.5);
            max-width: 600px;
            text-align: center;
        }

        .crash-icon {
            font-size: 72px;
            margin-bottom: 20px;
        }

        .crash-title {
            font-size: 32px;
            font-weight: 700;
            color: #ef4444;
            margin-bottom: 16px;
        }

        .crash-message {
            font-size: 18px;
            color: #e5e7eb;
            line-height: 1.6;
            margin-bottom: 24px;
        }

        .crash-details {
            background: rgba(255, 255, 255, 0.1);
            padding: 20px;
            border-radius: 12px;
            margin-bottom: 24px;
            text-align: left;
        }

        .crash-detail-item {
            display: flex;
            justify-content: space-between;
            margin-bottom: 12px;
            font-size: 16px;
        }

        .crash-detail-label {
            color: #9ca3af;
        }

        .crash-detail-value {
            color: #fff;
            font-weight: 600;
        }

        .crash-btn {
            padding: 14px 32px;
            background: #ef4444;
            color: white;
            border: none;
            border-radius: 12px;
            font-weight: 600;
            font-size: 16px;
            cursor: pointer;
            transition: all 0.3s;
        }

        .crash-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 10px 30px rgba(239, 68, 68, 0.5);
        }

        /* Queue indicator styles */
        .queue-indicator {
            position: absolute;
            top: 10px;
            left: 50px;
            background: rgba(17, 24, 39, 0.9);
            backdrop-filter: blur(10px);
            padding: 12px 20px;
            border-radius: 8px;
            border: 1px solid rgba(255, 255, 255, 0.1);
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .queue-icon {
            font-size: 20px;
        }

        .queue-text {
            font-size: 14px;
            font-weight: 600;
            color: #fff;
        }

        .queue-count {
            font-size: 20px;
            font-weight: 700;
            color: #3b82f6;
            margin-left: 6px;
        }

        .queue-warning {
            color: #f59e0b;
        }

        .queue-critical {
            color: #ef4444;
        }

        /* Performance settings */
        .perf-control {
            display: flex;
            align-items: center;
            gap: 8px;
            margin-bottom: 12px;
        }

        .perf-checkbox {
            width: 20px;
            height: 20px;
        }
    </style>
</head>
<body>
    <div class="loading-screen" id="loadingScreen">
        <div class="loader-container">
            <div class="loader-ring"></div>
        </div>
        <div class="loading-text">Initializing CPU Factory...</div>
    </div>

    <div class="app" id="app" class="basic-mode">
        <div class="header">
            <div class="logo-section">
                <div class="logo">⚡</div>
                <h1 class="title">CPU Performance Factory</h1>
            </div>
            <div class="mode-selector">
                <button class="mode-btn active" onclick="setMode('basic')">Basic Mode</button>
                <button class="mode-btn" onclick="setMode('advanced')">Advanced Mode</button>
            </div>
        </div>

        <div class="main-container">
            <div class="control-panel">
                <div class="control-group">
                    <div class="control-header">
                        <label class="control-label">CPU Cores</label>
                        <span class="control-value" id="coreValue">4</span>
                    </div>
                    <div class="slider-track">
                        <div class="slider-fill" id="coreFill" style="width: 25%"></div>
                        <div class="slider-handle" id="coreHandle" style="left: 25%"></div>
                        <input type="range" class="slider" id="coreSlider" min="1" max="16" value="4">
                    </div>
                </div>

                <div class="control-group">
                    <div class="control-header">
                        <label class="control-label">Clock Speed</label>
                        <span class="control-value" id="clockValue">3.0 GHz</span>
                    </div>
                    <div class="slider-track">
                        <div class="slider-fill" id="clockFill" style="width: 50%"></div>
                        <div class="slider-handle" id="clockHandle" style="left: 50%"></div>
                        <input type="range" class="slider" id="clockSlider" min="1" max="5" step="0.1" value="3">
                    </div>
                </div>

                <div class="control-group">
                    <label class="control-label">Workload Type</label>
                    <div class="task-grid">
                        <div class="task-card active" data-task="simple">
                            <div class="task-icon">🌐</div>
                            <div class="task-name">Web Browsing</div>
                            <div class="task-desc">Light tasks</div>
                        </div>
                        <div class="task-card" data-task="complex">
                            <div class="task-icon">🎮</div>
                            <div class="task-name">Gaming</div>
                            <div class="task-desc">Complex tasks</div>
                        </div>
                        <div class="task-card" data-task="heavy">
                            <div class="task-icon">🎬</div>
                            <div class="task-name">Video Editing</div>
                            <div class="task-desc">Heavy processing</div>
                        </div>
                        <div class="task-card" data-task="memory">
                            <div class="task-icon">📊</div>
                            <div class="task-name">Data Analysis</div>
                            <div class="task-desc">Memory intensive</div>
                        </div>
                    </div>
                </div>

                <div class="scenario-section">
                    <label class="control-label">Challenge Scenarios</label>
                    <div class="scenario-card" data-scenario="gaming">
                        <div class="scenario-header">
                            <span class="scenario-icon">🎮</span>
                            <span class="scenario-title">Gaming Performance</span>
                        </div>
                        <div class="scenario-desc">
                            Balance high single-core speed with adequate multi-threading
                        </div>
                    </div>
                    <div class="scenario-card" data-scenario="productivity">
                        <div class="scenario-header">
                            <span class="scenario-icon">💼</span>
                            <span class="scenario-title">Productivity Suite</span>
                        </div>
                        <div class="scenario-desc">
                            Maximize parallel processing for multiple applications
                        </div>
                    </div>
                    <div class="scenario-card" data-scenario="budget">
                        <div class="scenario-header">
                            <span class="scenario-icon">💰</span>
                            <span class="scenario-title">Budget Build</span>
                        </div>
                        <div class="scenario-desc">
                            Achieve performance targets with limited resources
                        </div>
                    </div>
                    <div class="scenario-card advanced-feature" data-scenario="thermal">
                        <div class="scenario-header">
                            <span class="scenario-icon">🌡️</span>
                            <span class="scenario-title">Thermal Challenge</span>
                        </div>
                        <div class="scenario-desc">
                            Maintain performance under thermal constraints
                        </div>
                    </div>
                </div>

                <div class="control-group advanced-feature">
                    <label class="control-label">Advanced Features</label>
                    <div style="display: flex; flex-direction: column; gap: 12px;">
                        <label style="display: flex; align-items: center; gap: 8px; cursor: pointer;">
                            <input type="checkbox" id="hyperThreading" style="width: 20px; height: 20px;">
                            <span>Hyper-Threading (SMT)</span>
                        </label>
                        <label style="display: flex; align-items: center; gap: 8px; cursor: pointer;">
                            <input type="checkbox" id="turboBoost" checked style="width: 20px; height: 20px;">
                            <span>Turbo Boost</span>
                        </label>
                        <label style="display: flex; align-items: center; gap: 8px; cursor: pointer;">
                            <input type="checkbox" id="outOfOrder" checked style="width: 20px; height: 20px;">
                            <span>Out-of-Order Execution</span>
                        </label>
                    </div>
                </div>

                <div class="control-group">
                    <label class="control-label">Cooling Solution</label>
                    <select id="coolingSelect" style="width: 100%; padding: 10px; background: rgba(30, 41, 59, 0.5); color: #fff; border: 1px solid rgba(255, 255, 255, 0.2); border-radius: 8px; font-size: 14px;">
                        <option value="stock">Stock Cooler (95W TDP)</option>
                        <option value="tower" selected>Tower Cooler (180W TDP)</option>
                        <option value="aio">AIO Liquid (280W TDP)</option>
                        <option value="custom">Custom Loop (400W+ TDP)</option>
                    </select>
                </div>

                <div class="control-group">
                    <label class="control-label">Performance Settings</label>
                    <div class="perf-control">
                        <input type="checkbox" id="reducedEffects" class="perf-checkbox" checked>
                        <label for="reducedEffects">Reduced Visual Effects</label>
                    </div>
                    <div class="perf-control">
                        <input type="checkbox" id="lowParticles" class="perf-checkbox" checked>
                        <label for="lowParticles">Minimal Particles</label>
                    </div>
                </div>
            </div>

            <div class="simulation-area">
                <div class="canvas-container">
                    <canvas id="mainCanvas"></canvas>
                </div>
                <div class="info-panel">
                    <div class="info-title">🎓 What's Happening?</div>
                    <div class="info-text">
                        <span class="info-highlight">Workers (Cores)</span> process incoming tasks. More workers = more parallel processing.
                    </div>
                    <div class="info-text">
                        <span class="info-highlight">Task Queue</span> holds tasks waiting for a free core. Watch the queue build up when cores are busy!
                    </div>
                    <div class="info-text" id="dynamicInfo">
                        Currently: <span class="info-highlight" id="currentStatus">Running smoothly</span>
                    </div>
                </div>
                <div class="queue-indicator" id="queueIndicator">
                    <span class="queue-icon">📋</span>
                    <span class="queue-text">Queue:</span>
                    <span class="queue-count" id="queueCount">0</span>
                </div>
                <div class="performance-indicator" style="bottom: 20px; left: 20px; top: auto;">
                    <div class="indicator-item">
                        <span class="indicator-icon">⚙️</span>
                        <span class="indicator-text" id="activeWorkersText">4 Threads Active</span>
                    </div>
                    <div class="indicator-item" id="bottleneckIndicator" style="display: none;">
                        <span class="indicator-icon">⚠️</span>
                        <span class="indicator-text">Bottleneck Detected!</span>
                    </div>
                </div>
            </div>

            <div class="metrics-panel">
                <div class="metric-card">
                    <div class="metric-header">
                        <span class="metric-label">Performance</span>
                    </div>
                    <div class="metric-value" id="tasksPerSecond">0</div>
                    <div style="font-size: 12px; color: #64748b; margin-bottom: 8px;">tasks/second</div>
                    <div class="metric-bar">
                        <div class="metric-fill" id="tasksFill" style="width: 0%"></div>
                    </div>
                </div>

                <div class="metric-card">
                    <div class="metric-header">
                        <span class="metric-label">Efficiency</span>
                    </div>
                    <div class="metric-value" id="efficiency">0%</div>
                    <div style="font-size: 12px; color: #64748b; margin-bottom: 8px;">core utilization</div>
                    <div class="metric-bar">
                        <div class="metric-fill" id="efficiencyFill" style="width: 0%"></div>
                    </div>
                </div>

                <div class="metric-card">
                    <div class="metric-header">
                        <span class="metric-label">Queue Depth</span>
                    </div>
                    <div class="metric-value" id="queueDepth">0</div>
                    <div style="font-size: 12px; color: #64748b; margin-bottom: 8px;">waiting tasks</div>
                    <div class="metric-bar">
                        <div class="metric-fill" id="queueFill" style="width: 0%"></div>
                    </div>
                </div>

                <div class="metric-card">
                    <div class="metric-header">
                        <span class="metric-label">Temperature</span>
                    </div>
                    <div class="metric-value" id="temperature">45°C</div>
                    <div style="font-size: 12px; color: #64748b; margin-bottom: 8px;">thermal status</div>
                    <div class="metric-bar">
                        <div class="metric-fill" id="tempFill" style="width: 30%"></div>
                    </div>
                </div>

                <div class="metric-card">
                    <div class="metric-header">
                        <span class="metric-label">Power Draw</span>
                    </div>
                    <div class="metric-value" id="power">65W</div>
                    <div style="font-size: 12px; color: #64748b; margin-bottom: 8px;">consumption</div>
                    <div class="metric-bar">
                        <div class="metric-fill" id="powerFill" style="width: 40%"></div>
                    </div>
                </div>

                <div class="metric-card">
                    <div class="metric-header">
                        <span class="metric-label">Avg Wait Time</span>
                    </div>
                    <div class="metric-value" id="avgWaitTime">0ms</div>
                    <div style="font-size: 12px; color: #64748b;">queue latency</div>
                </div>

                <div class="metric-card advanced-feature">
                    <div class="metric-header">
                        <span class="metric-label">Pipeline</span>
                    </div>
                    <div class="metric-value" id="pipelineEff">0%</div>
                    <div style="font-size: 12px; color: #64748b;">efficiency</div>
                </div>

                <div class="metric-card advanced-feature">
                    <div class="metric-header">
                        <span class="metric-label">IPC</span>
                    </div>
                    <div class="metric-value" id="ipc">0.00</div>
                    <div style="font-size: 12px; color: #64748b;">instructions/cycle</div>
                </div>
            </div>
        </div>
    </div>

    <button class="start-tutorial-btn pulse" onclick="startTutorial()">
        🎓 Start Guided Tutorial
    </button>
    
    <button class="reset-btn" onclick="resetSimulation()">
        🔄 Reset Simulation
    </button>

    <div class="tutorial-overlay" id="tutorialOverlay">
        <div class="tutorial-spotlight" id="tutorialSpotlight"></div>
        <div class="tutorial-bubble" id="tutorialBubble">
            <div class="tutorial-header">
                <h3 class="tutorial-title" id="tutorialTitle">Welcome!</h3>
                <span class="tutorial-step" id="tutorialStep">Step 1 of 7</span>
            </div>
            <div class="tutorial-content" id="tutorialContent">
                Let's learn how CPUs work!
            </div>
            <div class="tutorial-actions">
                <button class="tutorial-btn secondary" onclick="skipTutorial()">Skip</button>
                <button class="tutorial-btn primary" onclick="nextTutorialStep()">Next</button>
            </div>
        </div>
    </div>

    <div class="achievement-notification" id="achievementNotification">
        <div class="achievement-header">
            <span class="achievement-icon">🏆</span>
            <div>
                <div class="achievement-title" id="achievementTitle">Achievement Unlocked!</div>
                <div class="achievement-desc" id="achievementDesc">Description</div>
            </div>
        </div>
    </div>

    <div class="crash-overlay" id="crashOverlay">
        <div class="crash-dialog">
            <div class="crash-icon">💥</div>
            <h2 class="crash-title">System Overload!</h2>
            <p class="crash-message">
                Your CPU has become overwhelmed and cannot keep up with the workload.
            </p>
            <div class="crash-details">
                <div class="crash-detail-item">
                    <span class="crash-detail-label">Unprocessed Tasks:</span>
                    <span class="crash-detail-value" id="crashTaskCount">0</span>
                </div>
                <div class="crash-detail-item">
                    <span class="crash-detail-label">Queue Depth:</span>
                    <span class="crash-detail-value" id="crashQueueDepth">0</span>
                </div>
                <div class="crash-detail-item">
                    <span class="crash-detail-label">Temperature:</span>
                    <span class="crash-detail-value" id="crashTemp">0°C</span>
                </div>
                <div class="crash-detail-item">
                    <span class="crash-detail-label">Efficiency:</span>
                    <span class="crash-detail-value" id="crashEfficiency">0%</span>
                </div>
                <div class="crash-detail-item">
                    <span class="crash-detail-label">Cooler:</span>
                    <span class="crash-detail-value" id="crashCooler">Unknown</span>
                </div>
                <div class="crash-detail-item">
                    <span class="crash-detail-label">Reason:</span>
                    <span class="crash-detail-value" id="crashReason">Unknown</span>
                </div>
            </div>
            <p class="crash-message" style="font-size: 16px; color: #9ca3af;">
                Try: Better cooling, lower clock speed, or fewer active cores. Check if your cooler can handle the power draw!
            </p>
            <button class="crash-btn" onclick="resetFromCrash()">Reset System</button>
        </div>
    </div>

    <script>
        // Global state
        let coolingSelectElement;
        let mode = 'basic';
        let cores = 4;
        let clockSpeed = 3.0;
        let taskType = 'simple';
        let currentScenario = null;
        let hyperThreading = false;
        let turboBoost = true;
        let outOfOrderExecution = true;
        let reducedEffects = true;
        let lowParticles = true;
        
        // Performance metrics
        let tasksCompleted = 0;
        let totalTasks = 0;
        let efficiency = 0;
        let temperature = 42; // Realistic idle temperature
        let powerDraw = 25; // Realistic idle power
        let pipelineEfficiency = 0;
        let frameCount = 0;
        let lastFrameTime = performance.now();
        let fps = 60;
        let ipc = 0;
        
        // Task queue system
        let taskQueue = [];
        let maxQueueSize = 50; // Reduced for performance
        let totalWaitTime = 0;
        let tasksQueued = 0;
        let queueOverflowCount = 0;
        
        // Animation state
        let workers = [];
        let tasks = [];
        let particles = [];
        let animationId;
        
        // Canvas setup
        const canvas = document.getElementById('mainCanvas');
        const ctx = canvas.getContext('2d');
        ctx.imageSmoothingEnabled = false;
        
        // Tutorial state
        let tutorialActive = false;
        let tutorialStep = 0;
        const tutorialSteps = [
            {
                title: "Welcome to CPU Performance Factory!",
                content: "In this interactive simulation, you'll learn how CPU cores and clock speed work together. Watch how tasks queue up when cores are busy!",
                target: null,
                position: 'center'
            },
            {
                title: "Task Queue System",
                content: "Tasks queue up when all cores are busy, just like in real CPUs! The queue indicator shows how many tasks are waiting.",
                target: '#queueIndicator',
                position: 'bottom',
                quiz: {
                    question: "What happens when all CPU cores are busy?",
                    options: [
                        "Tasks disappear",
                        "Tasks wait in a queue",
                        "Tasks process slower",
                        "New tasks stop generating"
                    ],
                    correct: 1
                }
            },
            {
                title: "CPU Cores - Your Workers",
                content: "CPU cores are like workers in a factory. More cores mean more tasks can be processed simultaneously, reducing queue buildup.",
                target: '.control-group:nth-child(1)',
                position: 'right'
            },
            {
                title: "Clock Speed - Worker Speed",
                content: "Clock speed determines how fast each core works. Higher clock speed means workers process tasks faster.",
                target: '.control-group:nth-child(2)',
                position: 'right'
            },
            {
                title: "Performance Metrics",
                content: "Monitor these metrics: Queue Depth shows waiting tasks, Average Wait Time indicates queue latency, and other metrics show system health.",
                target: '.metrics-panel',
                position: 'left'
            },
            {
                title: "Finding Balance",
                content: "The key is preventing queue overflow while maintaining efficiency. Too few cores? Long queues. Too slow? Tasks pile up.",
                target: '.scenario-section',
                position: 'top'
            },
            {
                title: "Ready to Experiment!",
                content: "Now you understand the basics! Try different configurations and watch how they affect the queue. In Advanced Mode, explore Hyper-Threading!",
                target: null,
                position: 'center'
            }
        ];
        
        // Thermal model constants
        const T_AMBIENT = 22;
        const T_THROTTLE = 90;
        const TJ_MAX = 100;
        
        // Realistic Thermal Resistance for Coolers (°C per Watt)
        const COOLER_RESISTANCE = {
            stock: 0.85,    // Can handle ~95W max
            tower: 0.35,    // Can handle ~180W max
            aio: 0.20,      // Can handle ~280W max
            custom: 0.12    // Can handle ~400W max
        };
        
        // Realistic cooler limits (watts)
        const COOLER_LIMITS = {
            stock: 95,
            tower: 180,
            aio: 280,
            custom: 400
        };
        
        const POWER_LIMITS = {
            PL1: 125,
            PL2: 241,
            TAU: 28
        };
        
        let currentTemperature = T_AMBIENT + 20; // Start at ~42°C (realistic idle)
        let effectiveClockSpeed = 3.0;
        let isBoosting = false;
        let boostTimer = 0;
        
        // System crash detection
        let systemCrashed = false;
        let crashReason = '';
        
        // Task properties
        const taskProperties = {
            simple: { 
                size: 25, 
                complexity: 1, 
                color: '#22c55e',
                priority: 1
            },
            complex: { 
                size: 35, 
                complexity: 3, 
                color: '#f59e0b',
                priority: 2
            },
            heavy: { 
                size: 45, 
                complexity: 5, 
                color: '#ef4444',
                priority: 3
            },
            memory: { 
                size: 30, 
                complexity: 2, 
                color: '#8b5cf6',
                priority: 2
            }
        };
        
        // Achievements
        const achievements = {
            overclocker: { 
                name: "Speed Demon", 
                desc: "Reached 5.0 GHz clock speed!", 
                icon: "⚡",
                earned: false 
            },
            efficiency: { 
                name: "Efficiency Master", 
                desc: "Achieved 95% core utilization", 
                icon: "📊",
                earned: false 
            },
            multimaster: { 
                name: "Parallel Processing Pro", 
                desc: "Used all 16 cores effectively", 
                icon: "🔧",
                earned: false 
            },
            cool: { 
                name: "Cool Under Pressure", 
                desc: "High performance at low temperature", 
                icon: "❄️",
                earned: false 
            },
            balanced: {
                name: "Perfect Balance",
                desc: "Optimized all metrics simultaneously",
                icon: "⚖️",
                earned: false
            },
            queuemaster: {
                name: "Queue Management Expert",
                desc: "Maintained zero queue depth under heavy load",
                icon: "📋",
                earned: false
            }
        };

        // Initialize
        function init() {
            resizeCanvas();
            setupEventListeners();
            coolingSelectElement = document.getElementById('coolingSelect');
            initializeWorkers();
            systemCrashed = false;
            animate();
            
            // Hide loading screen
            setTimeout(() => {
                document.getElementById('loadingScreen').classList.add('hidden');
            }, 1000);
            
            // Show tutorial prompt after loading
            setTimeout(() => {
                if (!localStorage.getItem('tutorialCompleted')) {
                    document.querySelector('.start-tutorial-btn').classList.add('pulse');
                }
            }, 2000);
        }

        function resizeCanvas() {
            const container = canvas.parentElement;
            canvas.width = container.clientWidth;
            canvas.height = container.clientHeight;
            resetTasksOnly();
        }

        function setupEventListeners() {
            // Core slider
            const coreSlider = document.getElementById('coreSlider');
            coreSlider.addEventListener('input', (e) => {
                cores = parseInt(e.target.value);
                updateSliderVisual('core', cores, 16);
                document.getElementById('coreValue').textContent = cores;
                resetTasksOnly();
                initializeWorkers();
                checkAchievements();
            });

            // Clock speed slider
            const clockSlider = document.getElementById('clockSlider');
            clockSlider.addEventListener('input', (e) => {
                updateClockSpeed(parseFloat(e.target.value));
            });

            // Task type cards
            document.querySelectorAll('.task-card').forEach(card => {
                card.addEventListener('click', () => {
                    document.querySelectorAll('.task-card').forEach(c => c.classList.remove('active'));
                    card.classList.add('active');
                    taskType = card.dataset.task;
                    resetTasksOnly();
                });
            });

            // Scenario cards
            document.querySelectorAll('.scenario-card').forEach(card => {
                card.addEventListener('click', () => {
                    if (card.classList.contains('advanced-feature') && mode === 'basic') return;
                    resetTasksOnly();
                    document.querySelectorAll('.scenario-card').forEach(c => c.classList.remove('active'));
                    card.classList.add('active');
                    currentScenario = card.dataset.scenario;
                    applyScenario(currentScenario);
                });
            });

            // Advanced controls
            document.getElementById('hyperThreading').addEventListener('change', (e) => {
                hyperThreading = e.target.checked;
                initializeWorkers();
                resetTasksOnly();
            });

            document.getElementById('turboBoost').addEventListener('change', (e) => {
                turboBoost = e.target.checked;
                resetTasksOnly();
            });

            document.getElementById('outOfOrder').addEventListener('change', (e) => {
                outOfOrderExecution = e.target.checked;
            });

            // Performance controls
            document.getElementById('reducedEffects').addEventListener('change', (e) => {
                reducedEffects = e.target.checked;
            });

            document.getElementById('lowParticles').addEventListener('change', (e) => {
                lowParticles = e.target.checked;
            });

            // Window resize
            window.addEventListener('resize', () => {
                resizeCanvas();
                resetTasksOnly();
                initializeWorkers();
            });
        }
        
        function resetTasksOnly() {
            tasks = [];
            taskQueue = [];
            particles = [];
            totalWaitTime = 0;
            tasksQueued = 0;
            queueOverflowCount = 0;
            workers.forEach(w => {
                w.idle = true;
                w.currentTask = null;
            });
        }

        function updateSliderVisual(type, value, max) {
            const percentage = ((value - 1) / (max - 1)) * 100;
            document.getElementById(`${type}Fill`).style.width = `${percentage}%`;
            document.getElementById(`${type}Handle`).style.left = `${percentage}%`;
        }

        function updateClockSpeed(value) {
            clockSpeed = value;
            updateSliderVisual('clock', value - 1, 4);
            document.getElementById('clockValue').textContent = `${clockSpeed.toFixed(1)} GHz`;
            checkAchievements();
        }

        function setMode(newMode) {
            mode = newMode;
            document.querySelectorAll('.mode-btn').forEach(btn => btn.classList.remove('active'));
            document.querySelector(`[onclick="setMode('${newMode}')"]`).classList.add('active');
            document.getElementById('app').className = `app ${newMode}-mode`;
            
            if (newMode === 'advanced') {
                showAchievement({ 
                    name: "Advanced Mode Unlocked", 
                    desc: "Explore advanced CPU features!",
                    icon: "🚀"
                });
            }
        }

        function initializeWorkers() {
            workers = [];
            const baseWorkers = cores;

            const margin = 220; // Increased from 150 to account for queue area
            const spacingX = 110; // Reduced from 120
            const spacingY = 160; // Reduced from 180
            const availableWidth = canvas.width - margin - 200;
            const workersPerRow = Math.max(1, Math.floor(availableWidth / spacingX));
            
            const rows = Math.ceil(baseWorkers / workersPerRow);
            const totalHeight = (rows - 1) * spacingY;
            const startY = (canvas.height / 2) - (totalHeight / 2);

            for (let i = 0; i < baseWorkers; i++) {
                const row = Math.floor(i / workersPerRow);
                const col = i % workersPerRow;
                const workersInThisRow = Math.min(workersPerRow, baseWorkers - row * workersPerRow);
                const rowStartX = margin + (availableWidth - (workersInThisRow - 1) * spacingX) / 2;
                const physicalX = rowStartX + col * spacingX;
                const physicalY = startY + row * spacingY;

                workers.push({
                    id: i,
                    parentCoreId: i,
                    threadId: 0,
                    x: physicalX,
                    y: physicalY,
                    targetY: physicalY,
                    isVirtual: false,
                    heat: 0,
                    currentTask: null,
                    idle: true,
                    instructionsProcessed: 0
                });

                if (hyperThreading && mode === 'advanced') {
                    const virtualYOffset = 85; // Reduced from 95

                    workers.push({
                        id: i + baseWorkers,
                        parentCoreId: i,
                        threadId: 1,
                        x: physicalX,
                        y: physicalY + virtualYOffset,
                        targetY: physicalY,
                        isVirtual: true,
                        heat: 0,
                        currentTask: null,
                        idle: true,
                        instructionsProcessed: 0
                    });
                }
            }
            
            document.getElementById('activeWorkersText').textContent = `${workers.length} Threads Active`;
        }

        function applyScenario(scenario) {
            const scenarios = {
                gaming: { 
                    cores: 8, 
                    clock: 4.2, // More realistic for gaming OC
                    message: "Gaming: Moderate OC for single-thread performance" 
                },
                productivity: { 
                    cores: 16, 
                    clock: 3.5, // Lower clock for many-core stability
                    message: "Productivity: Many cores at moderate speed for stability" 
                },
                budget: { 
                    cores: 4, 
                    clock: 3.0, 
                    message: "Budget: Stock speeds for reliability" 
                },
                thermal: { 
                    cores: 6, 
                    clock: 2.8, // Even lower for minimal heat
                    message: "Low Power: Underclocked for silent operation" 
                }
            };
            
            const config = scenarios[scenario];
            if (config) {
                document.getElementById('coreSlider').value = config.cores;
                document.getElementById('clockSlider').value = config.clock;
                cores = config.cores;
                clockSpeed = config.clock;
                updateSliderVisual('core', cores, 16);
                updateSliderVisual('clock', clockSpeed - 1, 4);
                document.getElementById('coreValue').textContent = cores;
                document.getElementById('clockValue').textContent = `${clockSpeed.toFixed(1)} GHz`;
                
                initializeWorkers();
                
                showToast(config.message);
            }
        }

        function showToast(message) {
            const toast = document.createElement('div');
            toast.style.cssText = `
                position: fixed;
                bottom: 30px;
                left: 50%;
                transform: translateX(-50%) translateY(100px);
                background: #1e3c72;
                color: white;
                padding: 16px 24px;
                border-radius: 8px;
                font-weight: 600;
                box-shadow: 0 10px 30px rgba(0, 0, 0, 0.3);
                z-index: 1000;
                transition: transform 0.3s;
            `;
            toast.textContent = message;
            document.body.appendChild(toast);
            
            setTimeout(() => {
                toast.style.transform = 'translateX(-50%) translateY(0)';
            }, 100);
            
            setTimeout(() => {
                toast.style.transform = 'translateX(-50%) translateY(100px)';
                setTimeout(() => toast.remove(), 300);
            }, 3000);
        }

        // Tutorial System
        function startTutorial() {
            tutorialActive = true;
            tutorialStep = 0;
            document.getElementById('tutorialOverlay').classList.add('active');
            document.querySelector('.start-tutorial-btn').classList.remove('pulse');
            showTutorialStep();
        }

        function showTutorialStep() {
            const step = tutorialSteps[tutorialStep];
            const bubble = document.getElementById('tutorialBubble');
            const spotlight = document.getElementById('tutorialSpotlight');

            document.getElementById('tutorialTitle').textContent = step.title;
            document.getElementById('tutorialStep').textContent = `Step ${tutorialStep + 1} of ${tutorialSteps.length}`;
            
            if (step.quiz) {
                const quizHtml = `
                    <div class="quiz-container">
                        <div class="quiz-question">${step.quiz.question}</div>
                        <div class="quiz-options">
                            ${step.quiz.options.map((opt, i) => `
                                <div class="quiz-option" onclick="checkQuizAnswer(${i}, ${step.quiz.correct})">${opt}</div>
                            `).join('')}
                        </div>
                    </div>
                `;
                document.getElementById('tutorialContent').innerHTML = step.content + quizHtml;
            } else {
                document.getElementById('tutorialContent').innerHTML = step.content;
            }

            bubble.style.visibility = 'hidden';
            bubble.style.transform = 'none';
            bubble.style.top = '0px';
            bubble.style.left = '0px';

            const bubbleWidth = bubble.offsetWidth;
            const bubbleHeight = bubble.offsetHeight;

            bubble.style.visibility = 'visible';

            if (step.target) {
                const target = document.querySelector(step.target);
                const rect = target.getBoundingClientRect();

                spotlight.style.left = `${rect.left - 10}px`;
                spotlight.style.top = `${rect.top - 10}px`;
                spotlight.style.width = `${rect.width + 20}px`;
                spotlight.style.height = `${rect.height + 20}px`;
                spotlight.style.display = 'block';

                bubble.classList.remove('top', 'bottom', 'left', 'right');
                bubble.classList.add(step.position);

                let bubbleLeft, bubbleTop;
                const BUBBLE_OFFSET = 30;

                switch (step.position) {
                    case 'right':
                        bubbleLeft = rect.right + BUBBLE_OFFSET;
                        bubbleTop = rect.top + (rect.height / 2) - (bubbleHeight / 2);
                        break;
                    case 'left':
                        bubbleLeft = rect.left - bubbleWidth - BUBBLE_OFFSET;
                        bubbleTop = rect.top + (rect.height / 2) - (bubbleHeight / 2);
                        break;
                    case 'top':
                        bubbleLeft = rect.left + (rect.width / 2) - (bubbleWidth / 2);
                        bubbleTop = rect.top - bubbleHeight - BUBBLE_OFFSET;
                        break;
                    case 'bottom':
                    default:
                        bubbleLeft = rect.left + (rect.width / 2) - (bubbleWidth / 2);
                        bubbleTop = rect.bottom + BUBBLE_OFFSET;
                        break;
                }

                const PADDING = 10;

                if (bubbleLeft < PADDING) {
                    bubbleLeft = PADDING;
                }
                if (bubbleLeft + bubbleWidth > window.innerWidth - PADDING) {
                    bubbleLeft = window.innerWidth - bubbleWidth - PADDING;
                }
                if (bubbleTop < PADDING) {
                    bubbleTop = PADDING;
                }
                if (bubbleTop + bubbleHeight > window.innerHeight - PADDING) {
                    bubbleTop = window.innerHeight - bubbleHeight - PADDING;
                }

                bubble.style.left = `${bubbleLeft}px`;
                bubble.style.top = `${bubbleTop}px`;
                bubble.style.transform = '';

            } else {
                spotlight.style.display = 'none';
                bubble.style.left = '50%';
                bubble.style.top = '50%';
                bubble.style.transform = 'translate(-50%, -50%)';
            }

            bubble.classList.add('show');

            if (step.action) {
                setTimeout(step.action, 500);
            }
        }

        function checkQuizAnswer(selected, correct) {
            const options = document.querySelectorAll('.quiz-option');
            options[selected].classList.add(selected === correct ? 'correct' : 'incorrect');
            
            if (selected === correct) {
                setTimeout(() => {
                    nextTutorialStep();
                }, 1000);
            } else {
                options[correct].classList.add('correct');
            }
            
            options.forEach(opt => opt.style.pointerEvents = 'none');
        }

        function nextTutorialStep() {
            tutorialStep++;
            if (tutorialStep < tutorialSteps.length) {
                document.getElementById('tutorialBubble').classList.remove('show');
                setTimeout(() => showTutorialStep(), 300);
            } else {
                endTutorial();
            }
        }

        function skipTutorial() {
            if (confirm('Are you sure you want to skip the tutorial?')) {
                endTutorial();
            }
        }

        function endTutorial() {
            tutorialActive = false;
            document.getElementById('tutorialOverlay').classList.remove('active');
            localStorage.setItem('tutorialCompleted', 'true');
            showToast('Tutorial completed! Start experimenting!');
        }

        // Queue management functions
        function addToQueue(task) {
            if (taskQueue.length < maxQueueSize) {
                task.queuedAt = Date.now();
                taskQueue.push(task);
                tasksQueued++;
                
                // Sort by priority if out-of-order execution is enabled
                if (outOfOrderExecution && mode === 'advanced') {
                    taskQueue.sort((a, b) => {
                        const priorityA = taskProperties[a.taskType].priority;
                        const priorityB = taskProperties[b.taskType].priority;
                        return priorityA - priorityB;
                    });
                }
            } else {
                queueOverflowCount++;
                // Visual feedback for dropped task
                if (!lowParticles) {
                    createParticle(task.x, task.y, '#ef4444', 'overflow');
                }
            }
        }

        function getFromQueue() {
            if (taskQueue.length > 0) {
                const task = taskQueue.shift();
                const waitTime = Date.now() - task.queuedAt;
                totalWaitTime += waitTime;
                return task;
            }
            return null;
        }

        // Animation functions
        function generateTask() {
            const props = taskProperties[taskType];
            
            const workerYPositions = [...new Set(workers.map(w => w.y))].filter(y => !isNaN(y));
            const targetY = workerYPositions[Math.floor(Math.random() * workerYPositions.length)] || canvas.height / 2;
            
            const task = {
                id: Date.now(),
                x: Math.random() * 20 + 20, // Adjusted for new RAM width
                y: targetY + (Math.random() - 0.5) * 40,
                targetY: targetY,
                size: props.size,
                complexity: props.complexity,
                color: props.color,
                progress: 0,
                assigned: false,
                speed: 2 + Math.random(),
                rotation: 0,
                scale: 0.8,
                opacity: 0,
                taskType: taskType,
                inQueue: false,
                queuedAt: null
            };
            
            tasks.push(task);
            totalTasks++;
        }

        function createParticle(x, y, color, type = 'complete') {
            if (lowParticles) return; // Skip particles if low particle mode
            
            const count = type === 'complete' ? 5 : 3; // Reduced particle count
            
            for (let i = 0; i < count; i++) {
                particles.push({
                    x: x,
                    y: y,
                    vx: (Math.random() - 0.5) * 6,
                    vy: type === 'overflow' ? -Math.random() * 6 - 3 : -Math.random() * 4 - 2,
                    life: 1.0,
                    color: color,
                    size: Math.random() * 4 + 2, // Smaller particles
                    type: type
                });
            }
        }

        function updateMetrics() {
            const tasksPerSec = Math.floor(tasksCompleted / (frameCount / 60) || 0);
            document.getElementById('tasksPerSecond').textContent = tasksPerSec;
            const perfPercentage = Math.min(100, (tasksPerSec / 500) * 100);
            document.getElementById('tasksFill').style.width = `${perfPercentage}%`;

            const activePhysical = workers.filter(w => !w.isVirtual && !w.idle).length;
            const activeVirtual = workers.filter(w => w.isVirtual && !w.idle).length;
            const effectiveActive = activePhysical + (activeVirtual * 0.5);
            efficiency = cores > 0 ? Math.floor((effectiveActive / cores) * 100) : 0;
            document.getElementById('efficiency').textContent = `${efficiency}%`;
            document.getElementById('efficiencyFill').style.width = `${efficiency}%`;

            // Queue metrics
            const queueDepth = taskQueue.length;
            document.getElementById('queueDepth').textContent = queueDepth;
            document.getElementById('queueCount').textContent = queueDepth;
            const queuePercentage = Math.min(100, (queueDepth / maxQueueSize) * 100);
            document.getElementById('queueFill').style.width = `${queuePercentage}%`;
            
            // Queue status indicator
            const queueCountEl = document.getElementById('queueCount');
            if (queueDepth > maxQueueSize * 0.8) {
                queueCountEl.className = 'queue-count queue-critical';
                document.getElementById('bottleneckIndicator').style.display = 'block';
            } else if (queueDepth > maxQueueSize * 0.5) {
                queueCountEl.className = 'queue-count queue-warning';
                document.getElementById('bottleneckIndicator').style.display = 'block';
            } else {
                queueCountEl.className = 'queue-count';
                document.getElementById('bottleneckIndicator').style.display = 'none';
            }

            // Average wait time
            const avgWait = tasksQueued > 0 ? Math.floor(totalWaitTime / tasksQueued) : 0;
            document.getElementById('avgWaitTime').textContent = `${avgWait}ms`;

            temperature = Math.floor(currentTemperature);
            const tempEl = document.getElementById('temperature');
            tempEl.textContent = `${temperature}°C`;
            
            // Color code temperature display
            if (temperature >= 90) {
                tempEl.style.color = '#ef4444'; // Red for critical
            } else if (temperature >= 80) {
                tempEl.style.color = '#f59e0b'; // Orange for hot
            } else if (temperature >= 70) {
                tempEl.style.color = '#eab308'; // Yellow for warm
            } else {
                tempEl.style.color = '#3b82f6'; // Blue for cool
            }
            
            const tempPercentage = Math.min(100, Math.max(0, ((temperature - T_AMBIENT) / (TJ_MAX - T_AMBIENT)) * 100));
            document.getElementById('tempFill').style.width = `${tempPercentage}%`;

            document.getElementById('power').textContent = `${Math.floor(powerDraw)}W`;
            const powerPercentage = Math.min(100, (powerDraw / POWER_LIMITS.PL2) * 100);
            document.getElementById('powerFill').style.width = `${powerPercentage}%`;

            const clockValueEl = document.getElementById('clockValue');
            if (Math.abs(clockSpeed - effectiveClockSpeed) > 0.1) {
                clockValueEl.textContent = `${effectiveClockSpeed.toFixed(1)} GHz`;
                clockValueEl.style.color = '#ef4444';
                clockValueEl.title = `Throttled from ${clockSpeed.toFixed(1)} GHz`;
            } else {
                clockValueEl.textContent = `${clockSpeed.toFixed(1)} GHz`;
                clockValueEl.style.color = '#3b82f6';
                clockValueEl.title = '';
            }
            
            // Show power limit warnings
            const powerEl = document.getElementById('power');
            const coolerLimit = COOLER_LIMITS[coolingSelectElement.value];
            if (powerDraw > coolerLimit * 0.9) {
                powerEl.style.color = '#ef4444';
                powerEl.title = `Cooler limit: ${coolerLimit}W`;
            } else if (powerDraw > coolerLimit * 0.75) {
                powerEl.style.color = '#f59e0b';
                powerEl.title = `Cooler limit: ${coolerLimit}W`;
            } else {
                powerEl.style.color = '#3b82f6';
                powerEl.title = '';
            }
            
            if (mode === 'advanced') {
                // Simplified pipeline efficiency
                pipelineEfficiency = Math.min(99, Math.floor(75 + (efficiency * 0.15)));
                document.getElementById('pipelineEff').textContent = `${pipelineEfficiency}%`;

                // Calculate IPC
                const totalInstructions = workers.reduce((sum, w) => sum + w.instructionsProcessed, 0);
                const cycles = frameCount * (effectiveClockSpeed / 60);
                ipc = cycles > 0 ? (totalInstructions / (cycles * 1000000000)).toFixed(2) : 0;
                document.getElementById('ipc').textContent = ipc;
            }
            
            checkAchievements();
        }

        function checkAchievements() {
            if (mode === 'advanced') {
                if (clockSpeed >= 5.0 && !achievements.overclocker.earned) {
                    achievements.overclocker.earned = true;
                    showAchievement(achievements.overclocker);
                }

                if (efficiency >= 95 && !achievements.efficiency.earned) {
                    achievements.efficiency.earned = true;
                    showAchievement(achievements.efficiency);
                }

                if (cores === 16 && efficiency > 80 && !achievements.multimaster.earned) {
                    achievements.multimaster.earned = true;
                    showAchievement(achievements.multimaster);
                }

                if (temperature <= 65 && efficiency > 70 && clockSpeed >= 4 && !achievements.cool.earned) {
                    achievements.cool.earned = true;
                    showAchievement(achievements.cool);
                }

                if (efficiency > 85 && temperature < 75 && powerDraw < 120 && !achievements.balanced.earned) {
                    achievements.balanced.earned = true;
                    showAchievement(achievements.balanced);
                }

                if (taskQueue.length === 0 && efficiency > 90 && totalTasks > 1000 && !achievements.queuemaster.earned) {
                    achievements.queuemaster.earned = true;
                    showAchievement(achievements.queuemaster);
                }
            }
        }

        function showAchievement(achievement) {
            const notification = document.getElementById('achievementNotification');
            document.getElementById('achievementTitle').textContent = `${achievement.icon} ${achievement.name}`;
            document.getElementById('achievementDesc').textContent = achievement.desc;
            
            notification.classList.add('show');
            
            setTimeout(() => {
                notification.classList.remove('show');
            }, 4000);
        }

        function getHeatColor(heat) {
            // Map heat (0-1) to realistic temperature colors
            if (heat < 0.3) {
                // Cool (< 60°C) - Blue to green
                return '#3b82f6';
            } else if (heat < 0.5) {
                // Warm (60-75°C) - Green
                return '#22c55e';
            } else if (heat < 0.7) {
                // Hot (75-85°C) - Yellow/Orange
                return '#f59e0b';
            } else {
                // Very hot (> 85°C) - Red
                return '#ef4444';
            }
        }

        function updateInfoPanel() {
            const statusEl = document.getElementById('currentStatus');
            let message = "✅ System running smoothly";

            // More realistic thermal and OC messages
            if (currentTemperature >= T_THROTTLE) {
                message = "🔥 THERMAL THROTTLING ACTIVE!";
                statusEl.style.color = '#ef4444';
            } else if (coolingSelectElement.value === 'stock' && clockSpeed > 3.5) {
                message = "⚠️ Stock cooler struggling with OC";
                statusEl.style.color = '#f59e0b';
            } else if (coolingSelectElement.value === 'tower' && clockSpeed >= 4.5 && temperature > 80) {
                message = "⚠️ Tower cooler near limits";
                statusEl.style.color = '#f59e0b';
            } else if (clockSpeed >= 5.0 && coolingSelectElement.value !== 'custom') {
                message = "⚡ Extreme OC - needs custom loop!";
                statusEl.style.color = '#f59e0b';
            } else if (powerDraw > 200) {
                message = `⚡ High power draw: ${Math.floor(powerDraw)}W`;
                statusEl.style.color = '#f59e0b';
            } else if (taskQueue.length > maxQueueSize * 0.8) {
                message = "🚨 Queue critical - add cores!";
                statusEl.style.color = '#ef4444';
            } else if (taskQueue.length > maxQueueSize * 0.5) {
                message = "⚠️ Queue building up";
                statusEl.style.color = '#f59e0b';
            } else if (temperature > 85) {
                message = "🌡️ Getting toasty! Consider better cooling";
                statusEl.style.color = '#f59e0b';
            } else if (temperature > 75 && clockSpeed > 4.0) {
                message = "🔥 Normal OC temps - monitor closely";
                statusEl.style.color = '#3b82f6';
            } else if (efficiency < 30 && tasks.length > 5) {
                message = "💤 Low efficiency - cores idle";
                statusEl.style.color = '#f59e0b';
            } else if (efficiency > 80 && temperature < 70 && taskQueue.length < 5) {
                message = "🎯 Perfect balance!";
                statusEl.style.color = '#22c55e';
            } else if (clockSpeed >= 4.5 && temperature < 75) {
                message = "💪 Great OC with good temps!";
                statusEl.style.color = '#22c55e';
            } else if (taskQueue.length === 0 && efficiency > 90) {
                message = "⚡ Peak performance!";
                statusEl.style.color = '#22c55e';
            } else if (tasks.length === 0 && taskQueue.length === 0) {
                message = "💤 CPU idle";
                statusEl.style.color = '#64748b';
            } else {
                message = `📊 ${Math.floor(tasksCompleted / (frameCount / 60) || 0)} tasks/sec`;
                statusEl.style.color = '#3b82f6';
            }
            
            statusEl.innerHTML = message;
        }

        function drawRAMSource(ctx) {
            const ramWidth = 40;
            const x = 0;
            const y = 0;
            const height = canvas.height;

            ctx.fillStyle = 'rgba(59, 130, 246, 0.08)';
            ctx.fillRect(x, y, ramWidth, height);

            ctx.strokeStyle = 'rgba(59, 130, 246, 0.5)';
            ctx.lineWidth = 1;
            ctx.beginPath();
            ctx.moveTo(x + ramWidth, y);
            ctx.lineTo(x + ramWidth, y + height);
            ctx.stroke();

            ctx.save();
            ctx.translate(x + ramWidth / 2 - 5, y + height / 2);
            ctx.rotate(-Math.PI / 2);
            ctx.font = 'bold 14px Inter';
            ctx.fillStyle = 'rgba(255, 255, 255, 0.6)';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            ctx.fillText('RAM', 0, 0);
            ctx.restore();
        }

        function drawQueueArea(ctx) {
            const queueX = 60;
            const queueWidth = 140;
            const queueHeight = canvas.height - 100;
            const queueY = 70;

            // Queue background
            ctx.fillStyle = 'rgba(30, 41, 59, 0.2)';
            ctx.fillRect(queueX, queueY, queueWidth, queueHeight);

            // Queue border
            ctx.strokeStyle = 'rgba(59, 130, 246, 0.3)';
            ctx.lineWidth = 1;
            ctx.strokeRect(queueX, queueY, queueWidth, queueHeight);

            // Queue label
            ctx.fillStyle = '#64748b';
            ctx.font = 'bold 12px Inter';
            ctx.textAlign = 'center';
            ctx.fillText('TASK QUEUE', queueX + queueWidth / 2, queueY - 10);

            // Draw queued tasks
            const taskSpacing = 35;
            const maxVisibleTasks = Math.floor(queueHeight / taskSpacing);
            const startIdx = Math.max(0, taskQueue.length - maxVisibleTasks);

            for (let i = 0; i < Math.min(taskQueue.length - startIdx, maxVisibleTasks); i++) {
                const task = taskQueue[startIdx + i];
                const yPos = queueY + 20 + i * taskSpacing;
                
                ctx.save();
                ctx.translate(queueX + queueWidth / 2, yPos);
                
                // Task in queue visualization
                const props = taskProperties[task.taskType];
                ctx.fillStyle = props.color;
                ctx.globalAlpha = 0.7;
                
                // Simple rectangle for performance
                ctx.fillRect(-20, -12, 40, 24);
                
                // Queue position number
                ctx.fillStyle = '#fff';
                ctx.globalAlpha = 1;
                ctx.font = 'bold 10px Inter';
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.fillText(`#${startIdx + i + 1}`, 0, 0);
                
                ctx.restore();
            }

            // Overflow indicator
            if (taskQueue.length > maxVisibleTasks) {
                ctx.fillStyle = '#f59e0b';
                ctx.font = 'bold 11px Inter';
                ctx.textAlign = 'center';
                ctx.fillText(`+${taskQueue.length - maxVisibleTasks} more`, queueX + queueWidth / 2, queueY + queueHeight - 10);
            }
        }

        function drawWorker(worker, ctx) {
            ctx.save();
            ctx.translate(worker.x, worker.y);

            const heatColor = getHeatColor(worker.heat);
            const size = 70; // Reduced from 80
            
            // Simple worker body
            ctx.fillStyle = worker.isVirtual ? '#64748b' : heatColor;
            ctx.fillRect(-size/2, -size/2, size, size);
            
            // Border
            ctx.strokeStyle = worker.isVirtual ? '#475569' : heatColor;
            ctx.lineWidth = 2;
            ctx.strokeRect(-size/2, -size/2, size, size);

            // Status indicator
            const indicatorY = -size / 2 - 15;
            ctx.beginPath();
            ctx.arc(0, indicatorY, 6, 0, Math.PI * 2);
            ctx.fillStyle = worker.idle ? '#22c55e' : '#f59e0b';
            ctx.fill();

            // Core label
            ctx.fillStyle = '#fff';
            ctx.font = 'bold 18px Inter';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            ctx.fillText(`C${worker.id}`, 0, 0);
            
            if (worker.isVirtual) {
                ctx.font = '12px Inter';
                ctx.fillText('(V)', 0, 18);
            }
            
            ctx.restore();
        }

        function drawTask(task, ctx) {
            ctx.save();
            ctx.translate(task.x, task.y);
            if (!reducedEffects) {
                ctx.rotate(task.rotation);
                ctx.scale(task.scale, task.scale);
            }
            ctx.globalAlpha = task.opacity;
            
            const size = task.size;
            
            // Simple task shape
            ctx.fillStyle = task.color;
            ctx.fillRect(-size/2, -size/2, size, size);
            
            // Progress bar
            if (task.assigned && task.progress > 0) {
                ctx.fillStyle = 'rgba(255, 255, 255, 0.3)';
                ctx.fillRect(-size/2, size/2 + 4, size, 3);
                
                ctx.fillStyle = '#22c55e';
                ctx.fillRect(-size/2, size/2 + 4, (size * task.progress) / 100, 3);
            }
            
            ctx.restore();
        }

        function drawFactory(ctx) {
            // Very subtle grid lines
            ctx.strokeStyle = 'rgba(59, 130, 246, 0.05)';
            ctx.lineWidth = 1;
            
            const gridSize = 80;
            for (let x = 0; x < canvas.width; x += gridSize) {
                ctx.beginPath();
                ctx.moveTo(x, 0);
                ctx.lineTo(x, canvas.height);
                ctx.stroke();
            }
            
            for (let y = 0; y < canvas.height; y += gridSize) {
                ctx.beginPath();
                ctx.moveTo(0, y);
                ctx.lineTo(canvas.width, y);
                ctx.stroke();
            }
        }

        function animate(currentTime) {
            const deltaTime = currentTime - lastFrameTime;
            lastFrameTime = currentTime;
            frameCount++;

            updateRealisticThermals(deltaTime / 1000);

            if (systemCrashed) {
                showSystemCrash();
                if (animationId) cancelAnimationFrame(animationId);
                return;
            }

            ctx.clearRect(0, 0, canvas.width, canvas.height);
            drawFactory(ctx);
            drawRAMSource(ctx);
            drawQueueArea(ctx);
            
            // Task generation logic
            const maxActiveTasks = Math.max(8, workers.length * 1.5); // Further reduced for performance
            const totalActiveTasks = tasks.length + taskQueue.length;
            
            if (totalActiveTasks < maxActiveTasks) {
                const coreScaling = 1 + (workers.length / 16) * 0.5;
                const taskRate = 0.02 * coreScaling * (1 + taskProperties[taskType].complexity * 0.02);
                if (Math.random() < taskRate * (clockSpeed / 3)) {
                    generateTask();
                }
            }
            
            // Assign tasks from queue to idle workers
            const idleWorkers = workers.filter(w => w.idle);
            for (let worker of idleWorkers) {
                const queuedTask = getFromQueue();
                if (queuedTask) {
                    queuedTask.assigned = true;
                    queuedTask.inQueue = false;
                    queuedTask.x = 200;
                    queuedTask.y = worker.targetY;
                    worker.currentTask = queuedTask;
                    worker.idle = false;
                    tasks.push(queuedTask);
                }
            }
            
            // Update tasks
            tasks = tasks.filter(task => {
                if (!task.assigned && !task.inQueue) {
                    task.x += task.speed * (1 + clockSpeed * 0.1);
                    task.opacity = Math.min(1, task.opacity + 0.05);
                    if (!reducedEffects) {
                        task.scale = Math.min(1, task.scale + 0.01);
                        task.rotation += 0.02;
                    }
                    task.y += (task.targetY - task.y) * 0.05;
                    
                    // Check if task reached queue area
                    if (task.x >= 150 && task.x < 200) {
                        task.inQueue = true;
                        addToQueue(task);
                        return false;
                    }
                    
                    // Try to assign to worker directly if close enough
                    for (let worker of workers) {
                        const xDistance = Math.abs(task.x - worker.x);
                        const yDistance = Math.abs(task.y - worker.targetY);
                        if (worker.idle && xDistance < 120 && yDistance < 80) {
                            task.assigned = true;
                            worker.currentTask = task;
                            worker.idle = false;
                            break;
                        }
                    }
                }
                
                if (task.assigned) {
                    const worker = workers.find(w => w.currentTask === task);
                    if (worker) {
                        // More realistic heat mapping based on temperature
                        const tempRange = TJ_MAX - T_AMBIENT;
                        const currentTempNormalized = (currentTemperature - T_AMBIENT) / tempRange;
                        worker.heat = Math.min(1, currentTempNormalized);
                        
                        task.x += (worker.x - task.x) * 0.1;
                        task.y += (worker.y + 80 - task.y) * 0.1;
                        const speedMultiplier = effectiveClockSpeed / 3;
                        const progressRate = speedMultiplier / task.complexity;
                        task.progress += progressRate * (deltaTime / 16);
                        
                        if (task.progress >= 100) {
                            worker.idle = true;
                            worker.currentTask = null;
                            worker.instructionsProcessed += task.complexity * 1000;
                            tasksCompleted++;
                            if (!lowParticles) {
                                createParticle(task.x, task.y, task.color, 'complete');
                            }
                            return false;
                        }
                    }
                }
                
                drawTask(task, ctx);
                
                return task.x < canvas.width + task.size || task.assigned || task.inQueue;
            });

            // Cool down idle cores - no individual core cooling needed since we use global temp
            workers.forEach(worker => {
                drawWorker(worker, ctx);
            });

            // Update and draw particles
            if (!lowParticles) {
                particles = particles.filter(particle => {
                    particle.x += particle.vx;
                    particle.y += particle.vy;
                    particle.vy += 0.3;
                    particle.life -= 0.03;
                    
                    ctx.globalAlpha = particle.life;
                    ctx.fillStyle = particle.color;
                    ctx.fillRect(particle.x - particle.size/2, particle.y - particle.size/2, particle.size, particle.size);
                    ctx.globalAlpha = 1;
                    
                    return particle.life > 0;
                });
            }
            
            updateMetrics();
            updateInfoPanel();
            
            if (detectSystemCrash()) {
                showSystemCrash();
                return;
            }
            
            animationId = requestAnimationFrame(animate);
        }

        function resetSimulation() {
            if (animationId) {
                cancelAnimationFrame(animationId);
            }
            
            tasksCompleted = 0;
            totalTasks = 0;
            tasks = [];
            taskQueue = [];
            particles = [];
            systemCrashed = false;
            frameCount = 0;
            totalWaitTime = 0;
            tasksQueued = 0;
            queueOverflowCount = 0;
            
            efficiency = 0;
            temperature = 42; // Realistic idle temp
            currentTemperature = T_AMBIENT + 20; // ~42°C idle
            powerDraw = 25; // Realistic idle power
            pipelineEfficiency = 0;
            ipc = 0;
            
            initializeWorkers();
            
            updateMetrics();
            
            animate();
            
            showToast('Simulation reset successfully!');
        }
        
        function resetFromCrash() {
            document.getElementById('crashOverlay').style.display = 'none';
            resetSimulation();
        }
        
        function detectSystemCrash() {
            if (taskQueue.length >= maxQueueSize) {
                crashReason = `Queue Overflow - Maximum queue size (${maxQueueSize}) exceeded`;
                return true;
            }
            
            if (tasks.length > Math.max(30, workers.length * 3)) { // Reduced threshold
                crashReason = 'Task Overflow - Too many active tasks in system';
                return true;
            }
            
            if (temperature > 105) {
                crashReason = 'Thermal Shutdown - CPU reached critical temperature';
                return true;
            }
            
            if (efficiency < 5 && taskQueue.length > 40) {
                crashReason = 'CPU Starvation - Workers cannot process queue fast enough';
                return true;
            }
            
            if (powerDraw > 300) {
                crashReason = 'Power Limit Exceeded - System drawing too much power';
                return true;
            }
            
            if (temperature > 95) {
                const oldSpeed = clockSpeed;
                clockSpeed = Math.max(1.0, clockSpeed * 0.98);
                if (oldSpeed !== clockSpeed) {
                    document.getElementById('clockSlider').value = clockSpeed;
                    document.getElementById('clockValue').textContent = `${clockSpeed.toFixed(1)} GHz`;
                    updateSliderVisual('clock', clockSpeed, 5);
                }
            }
            
            return false;
        }
        
        function showSystemCrash() {
            systemCrashed = true;
            document.getElementById('crashOverlay').style.display = 'flex';
            document.getElementById('crashTaskCount').textContent = tasks.length + taskQueue.length;
            document.getElementById('crashQueueDepth').textContent = taskQueue.length;
            document.getElementById('crashTemp').textContent = `${temperature}°C`;
            document.getElementById('crashEfficiency').textContent = `${efficiency}%`;
            
            // Show cooler type
            const coolerTypes = {
                'stock': 'Stock Cooler',
                'tower': 'Tower Cooler',
                'aio': 'AIO Liquid',
                'custom': 'Custom Loop'
            };
            document.getElementById('crashCooler').textContent = coolerTypes[coolingSelectElement.value] || 'Unknown';
            document.getElementById('crashReason').textContent = crashReason;
            
            if (animationId) {
                cancelAnimationFrame(animationId);
            }
        }

        function updateRealisticThermals(deltaTime) {
            if (systemCrashed) return;

            const workloadFactors = { simple: 1.0, complex: 1.25, heavy: 1.6, memory: 1.1 };
            const workloadFactor = workloadFactors[taskType] || 1.0;

            // Base power components - idle power varies with temperature
            const idlePowerPerCore = 2;
            const idlePower = 10 + cores * idlePowerPerCore;
            const baseLeakage = idlePower * (1 + (currentTemperature - T_AMBIENT) / 100);
            let staticLeakagePower = baseLeakage;

            const activeCores = workers.filter(w => !w.idle && !w.isVirtual).length;
            const activeVirtualCores = workers.filter(w => !w.idle && w.isVirtual).length;
            const activeLoad = activeCores > 0 || activeVirtualCores > 0;
            
            // Ensure temperature is valid
            if (isNaN(currentTemperature)) { currentTemperature = T_AMBIENT + 20; }

            const socBasePower = activeLoad ? 15 : 5;

            // Realistic voltage and power scaling
            let voltage = 0.9; // Base voltage
            let powerPerCore = 10; // Base power at 1 GHz
            
            // More realistic voltage curve
            if (clockSpeed <= 3.0) {
                // Linear scaling for low speeds
                voltage = 0.7 + (clockSpeed - 1.0) * 0.15;
                powerPerCore = 5 + (clockSpeed - 1.0) * 7.5;
            } else if (clockSpeed <= 4.0) {
                // Moderate exponential scaling
                voltage = 0.9 + (clockSpeed - 3.0) * 0.25;
                powerPerCore = 15 + (clockSpeed - 3.0) * 25;
            } else {
                // Aggressive exponential scaling for OC
                voltage = 1.15 + Math.pow(clockSpeed - 4.0, 1.5) * 0.3;
                powerPerCore = 40 + Math.pow(clockSpeed - 4.0, 2) * 40;
            }
            
            // Apply workload factor
            powerPerCore *= workloadFactor;
            
            // Calculate dynamic power (only for active cores)
            let activeDynamicPower = (activeCores * powerPerCore) + (activeVirtualCores * powerPerCore * 0.3);
            if (isNaN(activeDynamicPower)) { activeDynamicPower = 0; }

            let totalPower = staticLeakagePower + socBasePower + activeDynamicPower;
            if (isNaN(totalPower)) { totalPower = 20; }

            // Boost behavior with thermal limits
            if (activeLoad && totalPower > POWER_LIMITS.PL1 && !isBoosting && boostTimer <= 0 && currentTemperature < 80) {
                isBoosting = true;
                boostTimer = POWER_LIMITS.TAU;
            }
            
            // Disable boost if too hot
            if (currentTemperature > 85 && isBoosting) {
                isBoosting = false;
                boostTimer = 0;
            }

            if (isBoosting) {
                totalPower = Math.min(totalPower, POWER_LIMITS.PL2);
                boostTimer -= deltaTime;
                if (boostTimer <= 0) { isBoosting = false; boostTimer = 0; }
            } else if (totalPower > POWER_LIMITS.PL1) {
                totalPower = Math.min(totalPower, POWER_LIMITS.PL1);
            }
            
            powerDraw = totalPower;

            // Get selected cooler
            const selectedCooler = coolingSelectElement.value;
            let thermalResistance = COOLER_RESISTANCE[selectedCooler];
            const coolerLimit = COOLER_LIMITS[selectedCooler];
            
            // Check if cooler is overwhelmed
            let coolerOverwhelmed = false;
            if (totalPower > coolerLimit) {
                coolerOverwhelmed = true;
                // Cooler can't dissipate all the heat - temperature will spike
                thermalResistance *= (totalPower / coolerLimit);
            }
            
            effectiveClockSpeed = clockSpeed;
            
            // More aggressive thermal throttling
            if (currentTemperature >= T_THROTTLE) {
                const throttleAmount = (currentTemperature - T_THROTTLE) / 10;
                effectiveClockSpeed = Math.max(1.0, clockSpeed - throttleAmount);
                
                // Update UI to show throttling
                const statusEl = document.getElementById('currentStatus');
                statusEl.innerHTML = '🔥 THERMAL THROTTLING ACTIVE!';
                statusEl.style.color = '#ef4444';
            }
            
            // Calculate target temperature
            const targetTemperature = T_AMBIENT + (powerDraw * thermalResistance);
            
            // Temperature change rate depends on thermal mass
            const thermalInertiaFactor = coolerOverwhelmed ? 0.2 : 0.1;
            const tempChange = (targetTemperature - currentTemperature) * thermalInertiaFactor * deltaTime;
            
            // Apply temperature change
            currentTemperature += tempChange;
            
            // Clamp temperature to reasonable bounds
            currentTemperature = Math.max(T_AMBIENT, Math.min(TJ_MAX + 5, currentTemperature));

            // Show warnings based on cooler capability
            if (coolerOverwhelmed && frameCount % 60 === 0) {
                const statusEl = document.getElementById('currentStatus');
                if (selectedCooler === 'stock' && clockSpeed > 3.5) {
                    statusEl.innerHTML = '⚠️ Stock cooler insufficient for OC!';
                    statusEl.style.color = '#f59e0b';
                } else if (selectedCooler === 'tower' && clockSpeed > 4.5) {
                    statusEl.innerHTML = '⚠️ Tower cooler at limit!';
                    statusEl.style.color = '#f59e0b';
                } else if (selectedCooler === 'aio' && clockSpeed >= 5.0) {
                    statusEl.innerHTML = '⚡ Extreme OC - watch temps!';
                    statusEl.style.color = '#f59e0b';
                }
            }

            // Validate temperature bounds
            if (isNaN(currentTemperature) || currentTemperature < T_AMBIENT) {
                currentTemperature = T_AMBIENT + 20;
            }
            
            if (currentTemperature >= TJ_MAX) {
                systemCrashed = true;
                crashReason = `Thermal Shutdown - Exceeded TJ_MAX of ${TJ_MAX}°C`;
            }
        }

        // Start the application
        window.addEventListener('load', init);
        
        // Global functions for onclick handlers
        window.setMode = setMode;
        window.startTutorial = startTutorial;
        window.nextTutorialStep = nextTutorialStep;
        window.skipTutorial = skipTutorial;
        window.checkQuizAnswer = checkQuizAnswer;
        window.resetSimulation = resetSimulation;
        window.resetFromCrash = resetFromCrash;
    </script>
</body>
</html>