<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Star vs Mesh Network Topology Interactive Lab</title>
    <style>
        * {
            box-sizing: border-box;
            margin: 0;
            padding: 0;
        }
        
        body {
            font-family: 'Arial', sans-serif;
            background: linear-gradient(135deg, #1e3c72, #2a5298);
            color: #fff;
            min-height: 100vh;
            overflow-x: hidden;
        }
        
        .container {
            max-width: 1400px;
            margin: 0 auto;
            padding: 20px;
        }
        
        .header {
            text-align: center;
            margin-bottom: 30px;
            animation: fadeInDown 1s ease-out;
        }
        
        h1 {
            font-size: 2.5em;
            color: #64b5f6;
            margin-bottom: 10px;
            text-shadow: 0 0 20px rgba(100, 181, 246, 0.5);
        }
        
        .score-board {
            position: fixed;
            top: 20px;
            right: 20px;
            background: rgba(0, 0, 0, 0.7);
            padding: 15px;
            border-radius: 10px;
            border: 2px solid #64b5f6;
            z-index: 100;
        }
        
        .main-content {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 20px;
            margin-bottom: 30px;
        }
        
        .topology-container {
            background: rgba(255, 255, 255, 0.1);
            border-radius: 20px;
            padding: 20px;
            backdrop-filter: blur(10px);
            position: relative;
            min-height: 500px;
        }
        
        .topology-title {
            text-align: center;
            font-size: 1.5em;
            margin-bottom: 20px;
            color: #81c784;
        }
        
        .canvas-wrapper {
            position: relative;
            height: 400px;
            background: rgba(0, 0, 0, 0.3);
            border-radius: 15px;
            overflow: hidden;
        }
        
        canvas {
            width: 100%;
            height: 100%;
            cursor: crosshair;
        }
        
        .control-panel {
            background: rgba(0, 0, 0, 0.5);
            border-radius: 15px;
            padding: 20px;
            margin-bottom: 20px;
        }
        
        .btn-group {
            display: flex;
            gap: 10px;
            flex-wrap: wrap;
            justify-content: center;
            margin: 10px 0;
        }
        
        button {
            background: linear-gradient(135deg, #64b5f6, #42a5f5);
            color: white;
            border: none;
            padding: 12px 20px;
            border-radius: 8px;
            cursor: pointer;
            font-size: 16px;
            font-weight: bold;
            transition: all 0.3s;
            position: relative;
            overflow: hidden;
        }
        
        button:hover:not(:disabled) {
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(100, 181, 246, 0.5);
        }
        
        button:active:not(:disabled) {
            transform: translateY(0);
        }
        
        button:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }
        
        button:focus {
            outline: 3px solid #81c784;
            outline-offset: 2px;
        }
        
        .activity-panel {
            background: rgba(0, 0, 0, 0.5);
            border-radius: 15px;
            padding: 20px;
            margin-bottom: 20px;
        }
        
        .quiz-container {
            background: rgba(0, 0, 0, 0.6);
            border-radius: 15px;
            padding: 25px;
            margin: 20px 0;
            border: 2px solid #81c784;
        }
        
        .question {
            font-size: 1.2em;
            margin-bottom: 20px;
            color: #81c784;
        }
        
        .options {
            display: grid;
            gap: 10px;
        }
        
        .option {
            background: rgba(100, 181, 246, 0.2);
            border: 2px solid rgba(100, 181, 246, 0.5);
            padding: 15px;
            border-radius: 10px;
            cursor: pointer;
            transition: all 0.3s;
        }
        
        .option:hover:not(.disabled) {
            background: rgba(100, 181, 246, 0.3);
            transform: translateX(5px);
        }
        
        .option.selected {
            background: rgba(100, 181, 246, 0.5);
            border-color: #64b5f6;
        }
        
        .option.correct {
            background: rgba(129, 199, 132, 0.5);
            border-color: #81c784;
            animation: correctPulse 0.5s ease-out;
        }
        
        .option.incorrect {
            background: rgba(239, 83, 80, 0.5);
            border-color: #ef5350;
            animation: shake 0.5s ease-out;
        }
        
        .option.disabled {
            pointer-events: none;
            opacity: 0.7;
        }
        
        @keyframes correctPulse {
            0% { transform: scale(1); }
            50% { transform: scale(1.05); }
            100% { transform: scale(1); }
        }
        
        @keyframes shake {
            0%, 100% { transform: translateX(0); }
            25% { transform: translateX(-10px); }
            75% { transform: translateX(10px); }
        }
        
        .comparison-table {
            background: rgba(0, 0, 0, 0.6);
            border-radius: 15px;
            padding: 20px;
            margin: 20px 0;
            overflow-x: auto;
        }
        
        table {
            width: 100%;
            border-collapse: collapse;
        }
        
        th, td {
            padding: 12px;
            text-align: left;
            border-bottom: 1px solid rgba(255, 255, 255, 0.2);
        }
        
        th {
            background: rgba(100, 181, 246, 0.3);
            font-weight: bold;
        }
        
        .highlight {
            background: rgba(129, 199, 132, 0.3);
            animation: highlightPulse 2s infinite;
        }
        
        @keyframes highlightPulse {
            0%, 100% { opacity: 0.7; }
            50% { opacity: 1; }
        }
        
        .achievement {
            position: fixed;
            top: 100px;
            right: -400px;
            background: linear-gradient(135deg, #ffd700, #ffed4e);
            color: #000;
            padding: 20px;
            border-radius: 15px;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.3);
            transition: right 0.5s ease-out;
            z-index: 1000;
            max-width: 350px;
        }
        
        .achievement.show {
            right: 20px;
        }
        
        .scenario-box {
            background: rgba(129, 199, 132, 0.2);
            border: 2px solid #81c784;
            border-radius: 15px;
            padding: 20px;
            margin: 20px 0;
        }
        
        .stats-display {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 15px;
            margin: 20px 0;
        }
        
        .stat-card {
            background: rgba(0, 0, 0, 0.5);
            border-radius: 10px;
            padding: 15px;
            text-align: center;
            border: 1px solid rgba(100, 181, 246, 0.5);
        }
        
        .stat-value {
            font-size: 2em;
            color: #64b5f6;
            font-weight: bold;
        }
        
        .challenge-timer {
            font-size: 2em;
            text-align: center;
            color: #ef5350;
            margin: 20px 0;
        }
        
        .packet {
            position: absolute;
            width: 20px;
            height: 20px;
            background: radial-gradient(circle, #ffd700, #ff6b6b);
            border-radius: 50%;
            box-shadow: 0 0 10px rgba(255, 215, 0, 0.8);
            z-index: 10;
            pointer-events: none;
        }
        
        .node {
            cursor: pointer;
            transition: all 0.3s;
        }
        
        .node:hover {
            filter: brightness(1.3);
        }
        
        .failure-mode {
            animation: failureBlink 1s infinite;
        }
        
        @keyframes failureBlink {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.3; }
        }
        
        .tooltip {
            position: absolute;
            background: rgba(0, 0, 0, 0.9);
            color: white;
            padding: 10px;
            border-radius: 8px;
            font-size: 14px;
            pointer-events: none;
            z-index: 100;
            display: none;
        }
        
        .mini-game {
            background: rgba(0, 0, 0, 0.6);
            border-radius: 15px;
            padding: 20px;
            margin: 20px 0;
            text-align: center;
        }
        
        .progress-bar {
            background: rgba(255, 255, 255, 0.2);
            border-radius: 10px;
            height: 20px;
            margin: 10px 0;
            overflow: hidden;
        }
        
        .progress-fill {
            height: 100%;
            background: linear-gradient(90deg, #81c784, #4caf50);
            transition: width 0.5s ease-out;
        }
        
        @keyframes fadeInDown {
            from { opacity: 0; transform: translateY(-20px); }
            to { opacity: 1; transform: translateY(0); }
        }
        
        @keyframes fadeIn {
            from { opacity: 0; }
            to { opacity: 1; }
        }
        
        .interactive-prompt {
            background: rgba(255, 193, 7, 0.2);
            border: 2px solid #ffc107;
            border-radius: 10px;
            padding: 15px;
            margin: 10px 0;
            text-align: center;
            animation: promptPulse 2s infinite;
        }
        
        @keyframes promptPulse {
            0%, 100% { transform: scale(1); }
            50% { transform: scale(1.02); }
        }
        
        .error-message {
            background: rgba(239, 83, 80, 0.2);
            border: 2px solid #ef5350;
            border-radius: 10px;
            padding: 15px;
            margin: 10px 0;
            text-align: center;
        }
        
        .sr-only {
            position: absolute;
            width: 1px;
            height: 1px;
            padding: 0;
            margin: -1px;
            overflow: hidden;
            clip: rect(0, 0, 0, 0);
            white-space: nowrap;
            border: 0;
        }
        
        @media (max-width: 768px) {
            .main-content {
                grid-template-columns: 1fr;
            }
            
            .score-board {
                position: static;
                margin-bottom: 20px;
            }
            
            .stats-display {
                grid-template-columns: 1fr;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>🌐 Star vs Mesh Network Topology Lab</h1>
            <p>Learn, Build, and Master Network Topologies!</p>
        </div>
        
        <div class="score-board" role="status" aria-live="polite">
            <div>⭐ Score: <span id="score">0</span></div>
            <div>🎯 Level: <span id="level">1</span></div>
            <div>🏆 Achievements: <span id="achievements">0</span></div>
        </div>
        
        <div class="control-panel">
            <div class="btn-group" role="tablist">
                <button role="tab" aria-selected="true" data-mode="learn">📚 Learn Mode</button>
                <button role="tab" aria-selected="false" data-mode="build">🔨 Build Mode</button>
                <button role="tab" aria-selected="false" data-mode="test">🧪 Test Mode</button>
                <button role="tab" aria-selected="false" data-mode="challenge">🏆 Challenge Mode</button>
                <button data-action="compare">📊 Compare</button>
                <button data-action="reset">🔄 Reset</button>
            </div>
        </div>
        
        <div class="interactive-prompt" id="prompt" role="status" aria-live="polite">
            👋 Welcome! Start by exploring Learn Mode to understand Star and Mesh topologies!
        </div>
        
        <div class="main-content">
            <div class="topology-container">
                <h2 class="topology-title">⭐ Star Topology</h2>
                <div class="canvas-wrapper">
                    <canvas id="starCanvas" role="application" aria-label="Star network topology interactive diagram" tabindex="0"></canvas>
                    <div class="packet" id="starPacket" style="display: none;" aria-hidden="true"></div>
                </div>
                <div class="btn-group">
                    <button data-action="addNode" data-topology="star">➕ Add Node</button>
                    <button data-action="removeNode" data-topology="star">➖ Remove Node</button>
                    <button data-action="sendData" data-topology="star">📤 Send Data</button>
                    <button data-action="simulateFailure" data-topology="star">💥 Simulate Failure</button>
                </div>
            </div>
            
            <div class="topology-container">
                <h2 class="topology-title">🔗 Mesh Topology</h2>
                <div class="canvas-wrapper">
                    <canvas id="meshCanvas" role="application" aria-label="Mesh network topology interactive diagram" tabindex="0"></canvas>
                    <div class="packet" id="meshPacket" style="display: none;" aria-hidden="true"></div>
                </div>
                <div class="btn-group">
                    <button data-action="addNode" data-topology="mesh">➕ Add Node</button>
                    <button data-action="removeNode" data-topology="mesh">➖ Remove Node</button>
                    <button data-action="sendData" data-topology="mesh">📤 Send Data</button>
                    <button data-action="simulateFailure" data-topology="mesh">💥 Simulate Failure</button>
                </div>
            </div>
        </div>
        
        <div class="activity-panel" id="activityPanel" role="region" aria-label="Activity content">
            <!-- Dynamic content loads here -->
        </div>
        
        <div class="stats-display">
            <div class="stat-card">
                <div class="stat-value" id="starNodeCount">1</div>
                <div>Star Nodes</div>
            </div>
            <div class="stat-card">
                <div class="stat-value" id="meshNodeCount">4</div>
                <div>Mesh Nodes</div>
            </div>
            <div class="stat-card">
                <div class="stat-value" id="connectionCount">0</div>
                <div>Total Connections</div>
            </div>
        </div>
        
        <div class="achievement" id="achievement" role="alert" aria-live="assertive">
            <h3>🏆 Achievement Unlocked!</h3>
            <p id="achievementText"></p>
        </div>
        
        <div class="tooltip" id="tooltip" role="tooltip" aria-hidden="true"></div>
    </div>
    
    <script>
        'use strict';
        
        // Constants and Configuration
        const CONFIG = {
            MAX_NODES: 8,
            MIN_NODES: 2,
            NODE_RADIUS: 20,
            SWITCH_RADIUS: 25, /* Changed HUB_RADIUS to SWITCH_RADIUS */
            ANIMATION_DURATION: 1000,
            CANVAS_PADDING: 50,
            STAR_LAYOUT_RADIUS: 120,
            ACHIEVEMENT_DISPLAY_TIME: 5000,
            PROMPT_ANIMATION_DELAY: 10
        };
        
        const TOPOLOGY_TYPES = {
            STAR: 'star',
            MESH: 'mesh'
        };
        
        const NODE_STATES = {
            ACTIVE: 'active',
            FAILED: 'failed',
            SENDING: 'sending',
            RECEIVING: 'receiving'
        };
        
        const GAME_MODES = {
            LEARN: 'learn',
            BUILD: 'build',
            TEST: 'test',
            CHALLENGE: 'challenge'
        };
        
        const EVENTS = {
            NODE_ADDED: 'nodeAdded',
            NODE_REMOVED: 'nodeRemoved',
            DATA_SENT: 'dataSent',
            FAILURE_SIMULATED: 'failureSimulated',
            MODE_CHANGED: 'modeChanged',
            SCORE_UPDATED: 'scoreUpdated',
            ACHIEVEMENT_UNLOCKED: 'achievementUnlocked'
        };
        
        // Utility Functions
        class Utils {
            static getCanvasCoordinates(canvas, event) {
                const rect = canvas.getBoundingClientRect();
                const scaleX = canvas.width / rect.width;
                const scaleY = canvas.height / rect.height;
                
                return {
                    x: (event.clientX - rect.left) * scaleX,
                    y: (event.clientY - rect.top) * scaleY
                };
            }
            
            static distance(p1, p2) {
                const dx = p2.x - p1.x;
                const dy = p2.y - p1.y;
                return Math.sqrt(dx * dx + dy * dy);
            }
            
            static sanitizeText(text) {
                const div = document.createElement('div');
                div.textContent = text;
                return div.innerHTML;
            }
            
            static debounce(func, wait) {
                let timeout;
                return function executedFunction(...args) {
                    const later = () => {
                        clearTimeout(timeout);
                        func(...args);
                    };
                    clearTimeout(timeout);
                    timeout = setTimeout(later, wait);
                };
            }
        }
        
        // Event Emitter for decoupled communication
        class EventEmitter {
            constructor() {
                this.events = {};
            }
            
            on(event, listener) {
                if (!this.events[event]) {
                    this.events[event] = [];
                }
                this.events[event].push(listener);
                
                // Return unsubscribe function
                return () => {
                    this.events[event] = this.events[event].filter(l => l !== listener);
                };
            }
            
            emit(event, data) {
                if (!this.events[event]) return;
                this.events[event].forEach(listener => listener(data));
            }
        }
        
        // State Manager
        class StateManager extends EventEmitter {
            constructor(initialState) {
                super();
                this.state = initialState;
                this.history = [];
            }
            
            setState(updates) {
                const oldState = { ...this.state };
                this.state = { ...this.state, ...updates };
                this.history.push(oldState);
                this.emit('stateChanged', { oldState, newState: this.state });
            }
            
            getState() {
                return { ...this.state };
            }
        }
        
        // Node Model
        class Node {
            constructor(id, x, y, type = 'node', color = '#64b5f6') {
                this.id = id;
                this.x = x;
                this.y = y;
                this.type = type;
                this.color = color; /* Changed 'hub' to 'switch' for radius check */
                this.radius = type === 'switch' ? CONFIG.SWITCH_RADIUS : CONFIG.NODE_RADIUS;
                this.state = NODE_STATES.ACTIVE;
            }
            
            fail() {
                this.state = NODE_STATES.FAILED;
            }
            
            restore() {
                this.state = NODE_STATES.ACTIVE;
            }
            
            isActive() {
                return this.state === NODE_STATES.ACTIVE;
            }
        }
        
        // Topology Base Class
        class Topology extends EventEmitter {
            constructor(type, canvas) {
                super();
                this.type = type;
                this.canvas = canvas;
                this.ctx = canvas.getContext('2d');
                this.nodes = [];
                this.isDirty = true;
            }
            
            addNode(node) {
                if (this.canAddNode()) {
                    this.nodes.push(node);
                    this.isDirty = true;
                    this.emit(EVENTS.NODE_ADDED, { topology: this.type, node });
                    return true;
                }
                return false;
            }
            
            removeNode() {
                if (this.canRemoveNode()) {
                    const removed = this.nodes.pop();
                    this.isDirty = true;
                    this.emit(EVENTS.NODE_REMOVED, { topology: this.type, node: removed });
                    return true;
                }
                return false;
            }
            
            canAddNode() {
                return this.nodes.length < CONFIG.MAX_NODES;
            }
            
            canRemoveNode() {
                return this.nodes.length > CONFIG.MIN_NODES;
            }
            
            getActiveNodes() {
                return this.nodes.filter(node => node.isActive());
            }
            
            findNodeAt(x, y) {
                return this.nodes.find(node => {
                    return Utils.distance({ x, y }, node) <= node.radius;
                });
            }
            
            markDirty() {
                this.isDirty = true;
            }
            
            render() {
                if (!this.isDirty) return;
                
                this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
                this.drawConnections();
                this.drawNodes();
                
                this.isDirty = false;
            }
            
            drawNode(node) {
                const ctx = this.ctx;
                
                // Node circle
                ctx.fillStyle = node.state === NODE_STATES.FAILED ? '#ef5350' : node.color;
                ctx.strokeStyle = '#fff';
                ctx.lineWidth = 3;
                
                ctx.beginPath();
                ctx.arc(node.x, node.y, node.radius, 0, Math.PI * 2);
                ctx.fill();
                ctx.stroke();
                
                // Node label
                ctx.fillStyle = '#fff';
                ctx.font = '12px Arial';
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                
                const label = node.type === 'switch' ? 'SWITCH' : 'N'; /* Changed 'hub' to 'switch' for label */
                ctx.fillText(label, node.x, node.y);
            }
            
            drawNodes() {
                this.nodes.forEach(node => this.drawNode(node));
            }
            
            // Abstract methods to be implemented by subclasses
            drawConnections() {
                throw new Error('drawConnections must be implemented by subclass');
            }
        }
        
        // Star Topology Implementation
        class StarTopology extends Topology {
            constructor(canvas) {
                super(TOPOLOGY_TYPES.STAR, canvas);
                this.initializeSwitch(); /* Renamed method */
            }
            
            initializeSwitch() { /* Renamed method and node type */
                const switchDevice = new Node(
                    'switch', // id
                    this.canvas.width / 2,
                    this.canvas.height / 2,
                    'switch', // type
                    '#ffd700'
                );
                this.nodes.push(switchDevice);
            }
            
            addNode(nodeData = {}) {
                const nodeCount = this.nodes.filter(n => n.type === 'node').length;
                const angle = (nodeCount * 2 * Math.PI) / 8;
                const switchDevice = this.nodes[0]; // Central device is now a switch
                
                const node = new Node(
                    `star${nodeCount}`,
                    switchDevice.x + Math.cos(angle) * CONFIG.STAR_LAYOUT_RADIUS,
                    switchDevice.y + Math.sin(angle) * CONFIG.STAR_LAYOUT_RADIUS,
                    'node',
                    '#81c784'
                );
                
                return super.addNode(node);
            }
            
            removeNode() {
                const nonHubNodes = this.nodes.filter(n => n.type === 'node');
                if (nonHubNodes.length > CONFIG.MIN_NODES) {
                    this.nodes = [this.nodes[0], ...this.nodes.slice(1, -1)];
                    this.isDirty = true;
                    this.emit(EVENTS.NODE_REMOVED, { topology: this.type });
                    return true;
                }
                return false;
            }
            
            drawConnections() {
                const switchDevice = this.nodes[0]; // Central device
                if (!switchDevice) return;
                
                this.ctx.strokeStyle = switchDevice.isActive() ? '#64b5f6' : '#ef5350';
                this.ctx.lineWidth = switchDevice.isActive() ? 3 : 1;
                
                this.nodes.forEach(node => {
                    if (node.type === 'node') {
                        this.ctx.beginPath();
                        this.ctx.moveTo(switchDevice.x, switchDevice.y);
                        this.ctx.lineTo(node.x, node.y);
                        this.ctx.stroke();
                    }
                });
            }
            
            simulateFailure() {
                const switchDevice = this.nodes[0]; // Central device
                if (Math.random() < 0.5 && switchDevice) { // Check if switchDevice exists
                    switchDevice.fail();
                    this.isDirty = true;
                    return { type: 'switch', message: '💥 Central switch failed! Entire network is down!' }; /* Changed type and message */
                } else {
                    const activeNodes = this.nodes.filter(n => n.type === 'node' && n.isActive());
                    if (activeNodes.length > 0) {
                        const randomNode = activeNodes[Math.floor(Math.random() * activeNodes.length)];
                        randomNode.fail();
                        this.isDirty = true;
                        return { type: 'node', message: '💥 A node failed! Other nodes can still communicate via the switch.' }; /* Updated message */
                    }
                }
                return null;
            }
            
            canSendData() {
                const switchDevice = this.nodes[0]; // Central device
                const activeNodes = this.getActiveNodes().filter(n => n.type === 'node');
                return switchDevice && switchDevice.isActive() && activeNodes.length >= 2;
            }
            
            getDataPath() {
                const activeNodes = this.getActiveNodes().filter(n => n.type === 'node');
                if (activeNodes.length < 2) return null;
                
                const source = activeNodes[Math.floor(Math.random() * activeNodes.length)];
                let dest = activeNodes[Math.floor(Math.random() * activeNodes.length)];
                while (dest === source) {
                    dest = activeNodes[Math.floor(Math.random() * activeNodes.length)];
                }
                
                return {
                    path: [source, this.nodes[0], dest],
                    description: 'Data travels through central switch' /* Updated description */
                };
            }
        }
        
        // Mesh Topology Implementation
        class MeshTopology extends Topology {
            constructor(canvas) {
                super(TOPOLOGY_TYPES.MESH, canvas);
                this.initializeNodes();
            }
            
            initializeNodes() {
                const positions = [
                    { x: 0.3, y: 0.3 },
                    { x: 0.7, y: 0.3 },
                    { x: 0.7, y: 0.7 },
                    { x: 0.3, y: 0.7 }
                ];
                
                positions.forEach((pos, i) => {
                    const node = new Node(
                        `mesh${i}`,
                        this.canvas.width * pos.x,
                        this.canvas.height * pos.y,
                        'node',
                        '#64b5f6'
                    );
                    this.nodes.push(node);
                });
            }
            
            addNode(nodeData = {}) {
                const x = Math.random() * (this.canvas.width - 100) + 50;
                const y = Math.random() * (this.canvas.height - 100) + 50;
                
                const node = new Node(
                    `mesh${this.nodes.length}`,
                    x,
                    y,
                    'node',
                    '#64b5f6'
                );
                
                return super.addNode(node);
            }
            
            drawConnections() {
                this.ctx.strokeStyle = '#64b5f6';
                this.ctx.lineWidth = 2;
                
                for (let i = 0; i < this.nodes.length; i++) {
                    for (let j = i + 1; j < this.nodes.length; j++) {
                        const node1 = this.nodes[i];
                        const node2 = this.nodes[j];
                        
                        if (!node1.isActive() || !node2.isActive()) {
                            this.ctx.strokeStyle = '#ef5350';
                            this.ctx.lineWidth = 1;
                        } else {
                            this.ctx.strokeStyle = '#64b5f6';
                            this.ctx.lineWidth = 2;
                        }
                        
                        this.ctx.beginPath();
                        this.ctx.moveTo(node1.x, node1.y);
                        this.ctx.lineTo(node2.x, node2.y);
                        this.ctx.stroke();
                    }
                }
            }
            
            simulateFailure() {
                const activeNodes = this.getActiveNodes();
                if (activeNodes.length > 0) {
                    const randomNode = activeNodes[Math.floor(Math.random() * activeNodes.length)];
                    randomNode.fail();
                    this.isDirty = true;
                    return { type: 'node', message: '💥 A node failed! Other nodes can still communicate through alternate paths!' };
                }
                return null;
            }
            
            canSendData() {
                return this.getActiveNodes().length >= 2;
            }
            
            getDataPath() {
                const activeNodes = this.getActiveNodes();
                if (activeNodes.length < 2) return null;
                
                const source = activeNodes[Math.floor(Math.random() * activeNodes.length)];
                let dest = activeNodes[Math.floor(Math.random() * activeNodes.length)];
                while (dest === source) {
                    dest = activeNodes[Math.floor(Math.random() * activeNodes.length)];
                }
                
                return {
                    path: [source, dest],
                    description: 'Data travels directly between nodes'
                };
            }
            
            getConnectionCount() {
                const n = this.nodes.length;
                return (n * (n - 1)) / 2;
            }
        }
        
        // Animation Manager
        class AnimationManager {
            constructor() {
                this.animations = new Map();
                this.isAnimating = false;
            }
            
            async animatePacket(packet, path, duration = CONFIG.ANIMATION_DURATION) {
                if (path.length < 2) return;
                
                this.isAnimating = true;
                
                for (let i = 0; i < path.length - 1; i++) {
                    await this.animateSegment(packet, path[i], path[i + 1], duration);
                }
                
                this.isAnimating = false;
            }
            
            animateSegment(packet, from, to, duration) {
                return new Promise((resolve) => {
                    const startTime = Date.now();
                    packet.style.display = 'block';
                    
                    const animate = () => {
                        const elapsed = Date.now() - startTime;
                        const progress = Math.min(elapsed / duration, 1);
                        
                        const x = from.x + (to.x - from.x) * progress;
                        const y = from.y + (to.y - from.y) * progress;
                        
                        packet.style.left = (x - 10) + 'px';
                        packet.style.top = (y - 10) + 'px';
                        
                        if (progress < 1) {
                            requestAnimationFrame(animate);
                        } else {
                            resolve();
                        }
                    };
                    
                    animate();
                });
            }
        }
        
        // Renderer Class
        class Renderer {
            constructor() {
                this.isRunning = false;
                this.animationId = null;
                this.renderables = new Set();
            }
            
            add(renderable) {
                this.renderables.add(renderable);
            }
            
            remove(renderable) {
                this.renderables.delete(renderable);
            }
            
            start() {
                if (this.isRunning) return;
                this.isRunning = true;
                this.animate();
            }
            
            animate = () => {
                if (!this.isRunning) return;
                
                this.renderables.forEach(renderable => {
                    if (renderable.render) {
                        renderable.render();
                    }
                });
                
                this.animationId = requestAnimationFrame(this.animate);
            }
            
            stop() {
                this.isRunning = false;
                if (this.animationId) {
                    cancelAnimationFrame(this.animationId);
                    this.animationId = null;
                }
            }
        }
        
        // Quiz Manager
        class QuizManager {
            constructor() {
                this.questions = [
                    {
                        question: "In a Star topology, where do all nodes connect?",
                        options: [
                            "To each other directly",
                            "To a central hub or switch",
                            "In a circle formation",
                            "Randomly to any node"
                        ],
                        correct: 1,
                        explanation: "Star topology has all nodes connected to a central hub/switch!",
                        points: 10
                    },
                    {
                        question: "What happens in a Star topology if the central hub fails?",
                        options: [
                            "Nothing, network continues",
                            "Only some nodes lose connection",
                            "Entire network fails",
                            "Network becomes faster"
                        ],
                        correct: 2,
                        explanation: "If the central hub fails, the entire Star network goes down!",
                        points: 15
                    },
                    {
                        question: "How many connections does each node have in a full Mesh topology with 5 nodes?",
                        options: ["1", "2", "3", "4"],
                        correct: 3,
                        explanation: "In a full mesh, each node connects to every other node. With 5 nodes, each connects to 4 others!",
                        points: 20
                    },
                    {
                        question: "Which topology is more fault-tolerant?",
                        options: [
                            "Star topology",
                            "Mesh topology",
                            "Both are equal",
                            "Neither"
                        ],
                        correct: 1,
                        explanation: "Mesh topology is more fault-tolerant due to multiple paths between nodes!",
                        points: 10
                    },
                    {
                        question: "What is a major disadvantage of Mesh topology?",
                        options: [
                            "Low reliability",
                            "High cost and complexity",
                            "Slow data transfer",
                            "Central point of failure"
                        ],
                        correct: 1,
                        explanation: "Mesh topology requires many cables and is complex to set up, making it expensive!",
                        points: 15
                    }
                ];
                
                this.currentQuestion = 0;
            }
            
            getQuestion(index) {
                return this.questions[index % this.questions.length];
            }
            
            checkAnswer(questionIndex, answerIndex) {
                const question = this.getQuestion(questionIndex);
                return {
                    correct: answerIndex === question.correct,
                    explanation: question.explanation,
                    points: answerIndex === question.correct ? question.points : 0
                };
            }
        }
        
        // UI Manager
        class UIManager extends EventEmitter {
            constructor() {
                super();
                this.elements = this.cacheElements();
                this.setupEventListeners();
            }
            
            cacheElements() {
                return {
                    score: document.getElementById('score'),
                    level: document.getElementById('level'),
                    achievements: document.getElementById('achievements'),
                    prompt: document.getElementById('prompt'),
                    activityPanel: document.getElementById('activityPanel'),
                    achievement: document.getElementById('achievement'),
                    achievementText: document.getElementById('achievementText'),
                    tooltip: document.getElementById('tooltip'),
                    starNodeCount: document.getElementById('starNodeCount'),
                    meshNodeCount: document.getElementById('meshNodeCount'),
                    connectionCount: document.getElementById('connectionCount')
                };
            }
            
            setupEventListeners() {
                // Mode buttons
                document.querySelectorAll('[data-mode]').forEach(btn => {
                    btn.addEventListener('click', (e) => {
                        const mode = e.target.dataset.mode;
                        this.emit('modeChange', mode);
                        this.updateModeButtons(mode);
                    });
                });
                
                // Action buttons
                document.querySelectorAll('[data-action]').forEach(btn => {
                    btn.addEventListener('click', (e) => {
                        const action = e.target.dataset.action;
                        const topology = e.target.dataset.topology;
                        this.emit('action', { action, topology });
                    });
                });
            }
            
            updateModeButtons(activeMode) {
                document.querySelectorAll('[data-mode]').forEach(btn => {
                    const isActive = btn.dataset.mode === activeMode;
                    btn.setAttribute('aria-selected', isActive.toString());
                });
            }
            
            updateScore(score) {
                if (this.elements.score) {
                    this.elements.score.textContent = score;
                }
            }
            
            updateLevel(level) {
                if (this.elements.level) {
                    this.elements.level.textContent = level;
                }
            }
            
            updateAchievements(count) {
                if (this.elements.achievements) {
                    this.elements.achievements.textContent = count;
                }
            }
            
            updateStats(starCount, meshCount, connectionCount) {
                requestAnimationFrame(() => {
                    if (this.elements.starNodeCount) {
                        this.elements.starNodeCount.textContent = starCount;
                    }
                    if (this.elements.meshNodeCount) {
                        this.elements.meshNodeCount.textContent = meshCount;
                    }
                    if (this.elements.connectionCount) {
                        this.elements.connectionCount.textContent = connectionCount;
                    }
                });
            }
            
            showPrompt(message) {
                if (this.elements.prompt) {
                    this.elements.prompt.textContent = message;
                    this.elements.prompt.style.animation = 'none';
                    setTimeout(() => {
                        this.elements.prompt.style.animation = 'promptPulse 2s infinite';
                    }, CONFIG.PROMPT_ANIMATION_DELAY);
                }
            }
            
            showAchievement(title, description) {
                if (this.elements.achievement && this.elements.achievementText) {
                    this.elements.achievementText.textContent = description;
                    this.elements.achievement.classList.add('show');
                    
                    setTimeout(() => {
                        this.elements.achievement.classList.remove('show');
                    }, CONFIG.ACHIEVEMENT_DISPLAY_TIME);
                }
            }
            
            showTooltip(x, y, text) {
                if (this.elements.tooltip) {
                    this.elements.tooltip.textContent = text;
                    this.elements.tooltip.style.display = 'block';
                    this.elements.tooltip.style.left = x + 10 + 'px';
                    this.elements.tooltip.style.top = y + 10 + 'px';
                    this.elements.tooltip.setAttribute('aria-hidden', 'false');
                }
            }
            
            hideTooltip() {
                if (this.elements.tooltip) {
                    this.elements.tooltip.style.display = 'none';
                    this.elements.tooltip.setAttribute('aria-hidden', 'true');
                }
            }
            
            loadContent(content) {
                if (this.elements.activityPanel) {
                    // Clear existing content
                    this.elements.activityPanel.innerHTML = '';
                    
                    // Create new content safely
                    if (typeof content === 'string') {
                        // For HTML content, create elements programmatically
                        const tempDiv = document.createElement('div');
                        tempDiv.innerHTML = content;
                        
                        // Move children to activity panel
                        while (tempDiv.firstChild) {
                            this.elements.activityPanel.appendChild(tempDiv.firstChild);
                        }
                    } else if (content instanceof HTMLElement) {
                        this.elements.activityPanel.appendChild(content);
                    }
                }
            }
            
            createQuizElement(question, questionIndex) {
                const container = document.createElement('div');
                container.className = 'quiz-container';
                
                const title = document.createElement('h3');
                title.textContent = `Question ${questionIndex + 1}`;
                container.appendChild(title);
                
                const questionText = document.createElement('p');
                questionText.className = 'question';
                questionText.textContent = question.question;
                container.appendChild(questionText);
                
                const optionsDiv = document.createElement('div');
                optionsDiv.className = 'options';
                
                question.options.forEach((option, i) => {
                    const optionEl = document.createElement('div');
                    optionEl.className = 'option';
                    optionEl.textContent = option;
                    optionEl.addEventListener('click', () => {
                        this.selectQuizOption(optionEl, optionsDiv);
                    });
                    optionEl.dataset.index = i;
                    optionsDiv.appendChild(optionEl);
                });
                
                container.appendChild(optionsDiv);
                
                const submitBtn = document.createElement('button');
                submitBtn.textContent = 'Submit Answer';
                submitBtn.disabled = true;
                submitBtn.addEventListener('click', () => {
                    this.emit('submitAnswer', {
                        questionIndex,
                        answerIndex: parseInt(optionsDiv.querySelector('.selected')?.dataset.index)
                    });
                });
                container.appendChild(submitBtn);
                
                return container;
            }
            
            selectQuizOption(selected, container) {
                container.querySelectorAll('.option').forEach(opt => {
                    opt.classList.remove('selected');
                });
                selected.classList.add('selected');
                
                const submitBtn = container.parentElement.querySelector('button');
                if (submitBtn) {
                    submitBtn.disabled = false;
                }
            }
            
            showQuizResult(optionElements, correctIndex, selectedIndex) {
                optionElements.forEach((el, i) => {
                    el.classList.add('disabled');
                    if (i === correctIndex) {
                        el.classList.add('correct');
                    } else if (i === selectedIndex && i !== correctIndex) {
                        el.classList.add('incorrect');
                    }
                });
            }
        }
        
        // Main Application Class
        class NetworkTopologySimulator {
            constructor() {
                this.state = new StateManager({
                    score: 0,
                    level: 1,
                    achievements: [],
                    mode: GAME_MODES.LEARN,
                    questionsAnswered: 0,
                    correctAnswers: 0
                });
                
                this.ui = new UIManager();
                this.renderer = new Renderer();
                this.animationManager = new AnimationManager();
                this.quizManager = new QuizManager();
                
                this.topologies = {};
                this.eventUnsubscribers = [];
                
                this.initialize();
            }
            
            initialize() {
                // Set up canvases
                const starCanvas = document.getElementById('starCanvas');
                const meshCanvas = document.getElementById('meshCanvas');
                
                if (!starCanvas || !meshCanvas) {
                    console.error('Canvas elements not found');
                    return;
                }
                
                this.setupCanvases(starCanvas, meshCanvas);
                
                // Create topologies
                this.topologies.star = new StarTopology(starCanvas);
                this.topologies.mesh = new MeshTopology(meshCanvas);
                
                // Add initial nodes
                for (let i = 0; i < 4; i++) {
                    this.topologies.star.addNode();
                }
                
                // Set up rendering
                this.renderer.add(this.topologies.star);
                this.renderer.add(this.topologies.mesh);
                this.renderer.start();
                
                // Set up event listeners
                this.setupEventListeners();
                
                // Initial UI update
                this.updateUI();
                
                // Load initial mode
                this.setMode(GAME_MODES.LEARN);
                
                // Welcome message
                this.ui.showPrompt('Welcome to the Network Topology Lab! Start with Learn Mode to understand Star and Mesh topologies.');
            }
            
            setupCanvases(starCanvas, meshCanvas) {
                const resizeCanvas = (canvas) => {
                    const rect = canvas.parentElement.getBoundingClientRect();
                    canvas.width = rect.width;
                    canvas.height = rect.height;
                };
                
                resizeCanvas(starCanvas);
                resizeCanvas(meshCanvas);
                
                const debouncedResize = Utils.debounce(() => {
                    resizeCanvas(starCanvas);
                    resizeCanvas(meshCanvas);
                    this.topologies.star?.markDirty();
                    this.topologies.mesh?.markDirty();
                }, 250);
                
                window.addEventListener('resize', debouncedResize);
                
                // Canvas interaction
                this.setupCanvasInteraction(starCanvas, TOPOLOGY_TYPES.STAR);
                this.setupCanvasInteraction(meshCanvas, TOPOLOGY_TYPES.MESH);
            }
            
            setupCanvasInteraction(canvas, topologyType) {
                // Click handler
                canvas.addEventListener('click', (e) => {
                    if (this.state.getState().mode === GAME_MODES.BUILD) {
                        const coords = Utils.getCanvasCoordinates(canvas, e);
                        const topology = this.topologies[topologyType];
                        const node = topology.findNodeAt(coords.x, coords.y);
                        
                        if (node) {
                            if (node.isActive()) {
                                node.fail();
                            } else {
                                node.restore();
                            }
                            topology.markDirty();
                            this.ui.showPrompt(`Node ${node.isActive() ? 'restored' : 'disabled'}`);
                        }
                    }
                });
                
                // Hover handler
                canvas.addEventListener('mousemove', (e) => {
                    const coords = Utils.getCanvasCoordinates(canvas, e);
                    const topology = this.topologies[topologyType];
                    const node = topology.findNodeAt(coords.x, coords.y);
                    
                    if (node) {
                        let tooltip = ''; /* Changed 'hub' to 'switch' for tooltip */
                        if (node.type === 'switch') {
                            tooltip = 'Central Switch - All data passes through here';
                        } else if (node.type === 'node') {
                            tooltip = node.isActive() ? 'Network Node - Click to disable' : 'Failed Node - Click to restore';
                        }
                        this.ui.showTooltip(e.clientX, e.clientY, tooltip);
                    } else {
                        this.ui.hideTooltip();
                    }
                });
                
                canvas.addEventListener('mouseleave', () => {
                    this.ui.hideTooltip();
                });
                
                // Keyboard accessibility
                canvas.addEventListener('keydown', (e) => {
                    if (e.key === 'Enter' || e.key === ' ') {
                        e.preventDefault();
                        this.handleAction('sendData', topologyType);
                    }
                });
            }
            
            setupEventListeners() {
                // UI Events
                this.eventUnsubscribers.push(
                    this.ui.on('modeChange', (mode) => this.setMode(mode))
                );
                
                this.eventUnsubscribers.push(
                    this.ui.on('action', ({ action, topology }) => {
                        this.handleAction(action, topology);
                    })
                );
                
                this.eventUnsubscribers.push(
                    this.ui.on('submitAnswer', ({ questionIndex, answerIndex }) => {
                        this.handleQuizAnswer(questionIndex, answerIndex);
                    })
                );
                
                // Topology Events
                Object.values(this.topologies).forEach(topology => {
                    this.eventUnsubscribers.push(
                        topology.on(EVENTS.NODE_ADDED, () => this.updateUI())
                    );
                    
                    this.eventUnsubscribers.push(
                        topology.on(EVENTS.NODE_REMOVED, () => this.updateUI())
                    );
                });
            }
            
            handleAction(action, topology) {
                try {
                    switch (action) {
                        case 'addNode':
                            this.addNode(topology);
                            break;
                        case 'removeNode':
                            this.removeNode(topology);
                            break;
                        case 'sendData':
                            this.sendData(topology);
                            break;
                        case 'simulateFailure':
                            this.simulateFailure(topology);
                            break;
                        case 'compare':
                            this.showComparison();
                            break;
                        case 'reset':
                            this.resetAll();
                            break;
                    }
                } catch (error) {
                    console.error('Action failed:', error);
                    this.ui.showPrompt('An error occurred. Please try again.');
                }
            }
            
            addNode(topologyType) {
                const topology = this.topologies[topologyType];
                if (!topology) return;
                
                if (topology.addNode()) {
                    this.updateScore(5);
                    this.ui.showPrompt(
                        topologyType === TOPOLOGY_TYPES.STAR
                            ? "Node added to Star topology! Notice how it connects only to the central switch." /* Updated prompt */
                            : "Node added to Mesh topology! It can connect to all other nodes." 
                    );
                    this.checkAchievements();
                } else {
                    this.ui.showPrompt("Maximum nodes reached!");
                }
            }
            
            removeNode(topologyType) {
                const topology = this.topologies[topologyType];
                if (!topology) return;
                
                if (topology.removeNode()) {
                    this.ui.showPrompt(`Node removed from ${topologyType} topology.`);
                } else {
                    this.ui.showPrompt("Minimum nodes reached!");
                }
            }
            
            async sendData(topologyType) {
                const topology = this.topologies[topologyType];
                if (!topology) return;
                
                if (!topology.canSendData()) {
                    this.ui.showPrompt("Cannot send data - need at least 2 active nodes!");
                    return;
                }
                
                const dataPath = topology.getDataPath();
                if (!dataPath) return;
                
                const packet = document.getElementById(`${topologyType}Packet`);
                if (!packet) return;
                
                this.updateScore(10);
                
                await this.animationManager.animatePacket(packet, dataPath.path);
                
                packet.style.display = 'none';
                this.ui.showPrompt(`✅ Data sent! ${dataPath.description}`);
            }
            
            simulateFailure(topologyType) {
                const topology = this.topologies[topologyType];
                if (!topology) return;
                
                const result = topology.simulateFailure();
                if (result) {
                    this.ui.showPrompt(result.message);
                    this.updateScore(15);
                    this.checkAchievements();
                    
                    if (this.state.getState().mode === GAME_MODES.LEARN && result.type === 'switch') { /* Changed 'hub' to 'switch' */
                        setTimeout(() => {
                            this.loadQuizQuestion();
                        }, 2000);
                    }
                }
            }
            
            resetAll() {
                // Restore all nodes
                Object.values(this.topologies).forEach(topology => {
                    topology.nodes.forEach(node => node.restore());
                    topology.markDirty();
                });
                
                this.ui.showPrompt("Networks reset to initial state!");
                this.updateUI();
            }
            
            setMode(mode) {
                if (!Object.values(GAME_MODES).includes(mode)) return;
                
                this.state.setState({ mode });
                
                switch (mode) {
                    case GAME_MODES.LEARN:
                        this.loadLearnMode();
                        break;
                    case GAME_MODES.BUILD:
                        this.loadBuildMode();
                        break;
                    case GAME_MODES.TEST:
                        this.loadTestMode();
                        break;
                    case GAME_MODES.CHALLENGE:
                        this.loadChallengeMode();
                        break;
                }
            }
            
            loadLearnMode() {
                const content = `
                    <h2>📚 Learning Mode - Interactive Lessons</h2>
                    <div class="scenario-box">
                        <h3>🎯 Today's Scenario</h3>
                        <p>You're the network administrator for a small company with 10 computers. You need to choose between Star and Mesh topology.</p>
                        
                        <div style="margin: 20px 0;">
                            <h4>Try This:</h4>
                            <ol>
                                <li>Click "Send Data" on both topologies and observe the paths</li>
                                <li>Click "Simulate Failure" on both and see what happens</li>
                                <li>Add/remove nodes and watch the connections</li>
                            </ol>
                        </div>
                    </div>
                `;
                
                this.ui.loadContent(content);
                this.ui.showPrompt("Welcome to Learn Mode! Explore both topologies and discover their differences!");
            }
            
            loadBuildMode() {
                const content = `
                    <h2>🔨 Build Mode - Design Your Network</h2>
                    <div class="mini-game">
                        <h3>Network Design Challenge</h3>
                        <p>Click on nodes to enable/disable them. Build networks according to requirements!</p>
                        
                        <div class="scenario-box">
                            <h4>Current Challenge: Office Network</h4>
                            <p>Requirements:</p>
                            <ul>
                                <li>✓ Must handle node failures gracefully</li>
                                <li>✓ Budget: Limited (prefer fewer cables)</li>
                                <li>✓ Easy to manage and expand</li>
                            </ul>
                        </div>
                    </div>
                `;
                
                this.ui.loadContent(content);
                this.ui.showPrompt("Build Mode: Click on nodes to toggle their state!");
            }
            
            loadTestMode() {
                const content = document.createElement('div');
                content.innerHTML = `
                    <h2>🧪 Test Mode - Topology Analysis</h2>
                    <p>Run automated tests to understand topology behaviors!</p>
                `;
                
                const testBtn = document.createElement('button');
                testBtn.textContent = 'Run All Tests';
                testBtn.addEventListener('click', () => this.runTests());
                content.appendChild(testBtn);
                
                const resultsDiv = document.createElement('div');
                resultsDiv.id = 'testResults';
                resultsDiv.style.marginTop = '20px';
                content.appendChild(resultsDiv);
                
                this.ui.loadContent(content);
            }
            
            loadChallengeMode() {
                const content = `
                    <h2>🏆 Challenge Mode - Test Your Skills!</h2>
                    <div class="mini-game">
                        <h3>Network Survival Challenge</h3>
                        <p>Keep the network running as failures occur!</p>
                        <div class="challenge-timer" id="challengeTimer">Press Start to Begin</div>
                    </div>
                `;
                
                this.ui.loadContent(content);
                
                const startBtn = document.createElement('button');
                startBtn.textContent = 'Start Challenge';
                startBtn.addEventListener('click', () => this.startChallenge());
                document.getElementById('activityPanel').appendChild(startBtn);
            }
            
            loadQuizQuestion() {
                const state = this.state.getState();
                const question = this.quizManager.getQuestion(state.questionsAnswered);
                const quizElement = this.ui.createQuizElement(question, state.questionsAnswered);
                
                this.ui.loadContent(quizElement);
            }
            
            handleQuizAnswer(questionIndex, answerIndex) {
                if (answerIndex === undefined) return;
                
                const result = this.quizManager.checkAnswer(questionIndex, answerIndex);
                const optionElements = document.querySelectorAll('.option');
                const question = this.quizManager.getQuestion(questionIndex);
                
                this.ui.showQuizResult(optionElements, question.correct, answerIndex);
                
                if (result.correct) {
                    this.updateScore(result.points);
                    this.state.setState({
                        correctAnswers: this.state.getState().correctAnswers + 1
                    });
                }
                
                this.state.setState({
                    questionsAnswered: this.state.getState().questionsAnswered + 1
                });
                
                this.ui.showPrompt(result.explanation);
                
                // Load next question after delay
                setTimeout(() => {
                    if (this.state.getState().questionsAnswered < this.quizManager.questions.length) {
                        this.loadQuizQuestion();
                    } else {
                        this.showQuizComplete();
                    }
                }, 2000);
            }
            
            showQuizComplete() {
                const state = this.state.getState();
                const accuracy = Math.round((state.correctAnswers / state.questionsAnswered) * 100);
                
                const content = `
                    <div class="quiz-container">
                        <h2>Quiz Complete!</h2>
                        <p>Accuracy: ${accuracy}%</p>
                        <p>Score earned: ${state.correctAnswers * 10} points</p>
                    </div>
                `;
                
                this.ui.loadContent(content);
                
                if (accuracy >= 80) {
                    this.unlockAchievement("Quiz Master", "Score 80% or higher on the topology quiz!");
                }
            }
            
            showComparison() {
                const content = `
                    <h2>📊 Star vs Mesh Comparison</h2>
                    <div class="comparison-table">
                        <table>
                            <tr>
                                <th>Feature</th>
                                <th>⭐ Star Topology</th>
                                <th>🔗 Mesh Topology</th>
                            </tr>
                            <tr>
                                <td>Connection Pattern</td> /* Updated description */
                                <td>All nodes connect to central switch</td>
                                <td>Every node connects to every other node</td>
                            </tr>
                            <tr class="highlight">
                                <td>Fault Tolerance</td>
                                <td>❌ Low - Central point of failure</td>
                                <td>✅ High - Multiple paths available</td>
                            </tr>
                            <tr>
                                <td>Cost</td>
                                <td>✅ Low - Fewer cables needed</td>
                                <td>❌ High - Many cables required</td>
                            </tr>
                            <tr>
                                <td>Complexity</td>
                                <td>✅ Simple to set up and manage</td>
                                <td>❌ Complex configuration</td>
                            </tr>
                            <tr>
                                <td>Scalability</td>
                                <td>✅ Easy to add new nodes</td>
                                <td>❌ Difficult - needs many new connections</td>
                            </tr>
                            <tr>
                                <td>Performance</td>
                                <td>⚠️ All traffic through hub</td>
                                <td>✅ Direct paths, no bottleneck</td>
                            </tr>
                            <tr>
                                <td>Best Use Case</td>
                                <td>Small networks, offices, homes</td>
                                <td>Critical systems, military, banking</td>
                            </tr>
                        </table>
                    </div>
                `;
                
                this.ui.loadContent(content);
            }
            
            async runTests() {
                const resultsDiv = document.getElementById('testResults');
                if (!resultsDiv) return;
                
                const tests = [
                    { name: "Connection Count", fn: () => this.testConnections() },
                    { name: "Failure Impact", fn: () => this.testFailureImpact() },
                    { name: "Scalability", fn: () => this.testScalability() }
                ];
                
                resultsDiv.innerHTML = '<h3>Test Results:</h3>';
                
                for (const test of tests) {
                    const result = test.fn();
                    const p = document.createElement('p');
                    p.style.color = '#81c784';
                    p.textContent = `✓ ${test.name}: ${result}`;
                    resultsDiv.appendChild(p);
                    await new Promise(resolve => setTimeout(resolve, 1000));
                }
                
                this.updateScore(50);
            }
            
            testConnections() {
                const starConnections = this.topologies.star.nodes.filter(n => n.type === 'node').length;
                const meshConnections = this.topologies.mesh.getConnectionCount();
                return `Star uses ${starConnections} cables, Mesh uses ${meshConnections} cables`;
            }
            
            testFailureImpact() {
                return "Star has single point of failure (switch), Mesh has redundant paths"; /* Updated text */
            }
            
            testScalability() {
                return "Star: O(n) connections, Mesh: O(n²) connections";
            }
            
            async startChallenge() {
                let timeLeft = 60;
                let dataDelivered = 0;
                
                const timerEl = document.getElementById('challengeTimer');
                
                const challengeInterval = setInterval(async () => {
                    timeLeft--;
                    if (timerEl) {
                        timerEl.textContent = `Time: ${timeLeft}s`;
                    }
                    
                    // Random events
                    if (Math.random() < 0.2) {
                        const topology = Math.random() < 0.5 ? TOPOLOGY_TYPES.STAR : TOPOLOGY_TYPES.MESH;
                        this.simulateFailure(topology);
                    }
                    
                    if (Math.random() < 0.3) {
                        const topology = Math.random() < 0.5 ? TOPOLOGY_TYPES.STAR : TOPOLOGY_TYPES.MESH;
                        if (this.topologies[topology].canSendData()) {
                            await this.sendData(topology);
                            dataDelivered++;
                        }
                    }
                    
                    if (timeLeft <= 0) {
                        clearInterval(challengeInterval);
                        this.endChallenge(dataDelivered);
                    }
                }, 1000);
            }
            
            endChallenge(dataDelivered) {
                const score = dataDelivered * 20;
                this.updateScore(score);
                
                this.ui.showPrompt(`Challenge complete! Data delivered: ${dataDelivered}, Score: ${score}`);
                
                if (score > 200) {
                    this.unlockAchievement("Network Master", "Score over 200 in Challenge Mode!");
                }
            }
            
            updateScore(points) {
                const currentState = this.state.getState();
                const newScore = currentState.score + points;
                const newLevel = Math.floor(newScore / 100) + 1;
                
                this.state.setState({
                    score: newScore,
                    level: newLevel
                });
                
                this.ui.updateScore(newScore);
                
                if (newLevel > currentState.level) {
                    this.ui.updateLevel(newLevel);
                    this.ui.showPrompt(`🎉 Level Up! You're now level ${newLevel}!`);
                }
            }
            
            checkAchievements() {
                const achievements = [
                    {
                        id: 'first_failure',
                        name: 'Failure Explorer',
                        condition: () => {
                            return Object.values(this.topologies).some(t => 
                                t.nodes.some(n => !n.isActive())
                            );
                        },
                        description: 'Simulate your first network failure'
                    },
                    {
                        id: 'max_nodes',
                        name: 'Network Builder',
                        condition: () => {
                            return this.topologies.star.nodes.filter(n => n.type === 'node').length >= 8 ||
                                   this.topologies.mesh.nodes.length >= 8;
                        },
                        description: 'Build a network with 8 nodes'
                    }
                ];
                
                const currentAchievements = this.state.getState().achievements;
                
                achievements.forEach(achievement => {
                    if (!currentAchievements.includes(achievement.id) && achievement.condition()) {
                        this.unlockAchievement(achievement.name, achievement.description);
                        currentAchievements.push(achievement.id);
                    }
                });
            }
            
            unlockAchievement(name, description) {
                const currentAchievements = [...this.state.getState().achievements, name];
                this.state.setState({ achievements: currentAchievements });
                
                this.ui.updateAchievements(currentAchievements.length);
                this.ui.showAchievement(name, description);
                this.updateScore(50);
            }
            
            updateUI() {
                const starNodeCount = this.topologies.star.nodes.filter(n => n.type === 'node').length;
                const meshNodeCount = this.topologies.mesh.nodes.length;
                const meshConnections = this.topologies.mesh.getConnectionCount();
                const starConnections = starNodeCount;
                
                this.ui.updateStats(starNodeCount, meshNodeCount, starConnections + meshConnections);
                
                const state = this.state.getState();
                this.ui.updateScore(state.score);
                this.ui.updateLevel(state.level);
                this.ui.updateAchievements(state.achievements.length);
            }
            
            destroy() {
                // Stop renderer
                this.renderer.stop();
                
                // Unsubscribe from all events
                this.eventUnsubscribers.forEach(unsubscribe => unsubscribe());
                
                // Remove global event listeners
                window.removeEventListener('resize', this.resizeHandler);
            }
        }
        
        // Initialize the application
        let app;
        
        document.addEventListener('DOMContentLoaded', () => {
            app = new NetworkTopologySimulator();
        });
        
        // Cleanup on page unload
        window.addEventListener('beforeunload', () => {
            if (app) {
                app.destroy();
            }
        });
    </script>
</body>
</html>